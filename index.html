<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Breach Cost Estimator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.js" integrity="sha512-+k1pnlgt4F1H8L7t3z95o3/KO+o78INEcXTbnoJQ/F2VqDVhWoaiVml/OEHv9HsVgxUaVW+IbiZPUJQfF/YxZw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js" integrity="sha512-OIkF2zyWS+sUanhT2i75RexNDQ2EKHayyeOxBx4Z4ct0D+dlPzZPhHTi7xZ5eU7aznNLMX7pCZyZVSi25+EGMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/4.0.10/dexie.min.js" integrity="sha512-jF+6XYwL495BDSom6h9X0w5EvtDrXfevVM17XSnhXHxP/iwallbjIo4TPbGltrj/gkCN4qde+S/HjiF8J5ATKQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <style>
        /* Dark mode by default */
        body.dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .dark .bg-white { background-color: #2d3748 !important; }
        .dark .text-black { color: #e2e8f0 !important; }
        .dark .bg-gray-100 { background-color: #1a202c !important; }
        .dark .border-gray-300 { border-color: #4a5568 !important; }
    
        /* Progress Bar */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .progress-bar li {
            list-style: none;
            width: 100%;
            text-align: center;
            position: relative;
            font-weight: bold;
            color: gray;
        }
        .progress-bar li:before {
            content: attr(data-step);
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: gray;
            color: white;
        }
        .progress-bar li.active {
            color: #3490dc;
        }
        .progress-bar li.active:before {
            background-color: #3490dc;
        }
    
        /* Hide all form steps by default */
        .form-step {
            display: none;
        }
    
        /* Only display the form-step that has the 'active' class */
        .form-step.active {
            display: block;
        }
    
        /* Styling for asset selection */
        #asset-category-container label {
            display: block;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
        }
        #asset-category-container input[type="radio"] {
            display: none;
        }
        #asset-category-container input[type="radio"]:checked + label {
            background-color: #3490dc;
            color: white;
            border-color: #3490dc;
        }
    
        /* Styling for form fields */
        select, input[type="text"], input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #ddd;
            padding: 8px;
            width: 100%;
            border-radius: 5px;
        }
    
        /* Button styles */
        button {
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
        }
        .btn-primary {
            background-color: #3490dc;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #38a169;
            color: white;
        }
        .btn-danger {
            background-color: #e3342f;
            color: white;
        }
        .btn-primary:hover { background-color: #2779bd; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success:hover { background-color: #2f855a; }
        .btn-danger:hover { background-color: #cc1f1a; }
    
        /* JSON Output */
        #json-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f7fafc;
            color: black;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        /* JSON Styling */
        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
        }
        #progress-container {
            display: none;
        }

        #radial-tree-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            position: relative;
        }

    </style>
    
</head>
<body class="dark flex justify-center items-center min-h-screen">
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed bottom-5 right-5 space-y-2 z-50"></div>
    <!-- Main Form Container -->
    <div class="bg-white shadow-md rounded-lg p-6 w-full max-w-2xl">
            <!-- Progress Bar -->
            <div id="progress-container" class="w-full bg-gray-300 rounded mt-4 hidden">
                <div id="progress-bar" class="h-4 bg-blue-500 rounded w-0"></div>
            </div>
        <div class="flex justify-between items-center">
            <h2 class="text-xl font-bold">Data Breach Cost Estimator</h2>
            <button id="darkModeToggle" class="px-3 py-1 text-sm bg-gray-700 text-white rounded">
                <span id="darkModeIcon" class="material-symbols-outlined">dark_mode</span>
            </button>            
        </div>

        <!-- Progress Bar -->
        <ol class="progress-bar flex">
            <li data-step="1" class="active">Initializing</li>
            <li data-step="2">Asset Types</li>
            <li data-step="3">MITRE ATT&CK Inventory</li>
            <li data-step="4">ATT&CK Technique Visualization</li>
            <li data-step="5">Organization Details</li>
        </ol>  

        <div id="form-navigation" class="flex justify-between mt-4">
            <button type="button" id="prev-step" class="hidden bg-gray-500 text-white px-4 py-2 rounded">Back</button>
            <button type="button" id="next-step" class="bg-blue-500 text-white px-4 py-2 rounded">Next</button>
        </div>

        <form id="multiStepForm">
            <!-- Step 1: Initializing -->
            <div class="form-step active">
                <h3 class="text-lg font-semibold mb-2">Initializing</h3>
                <div id="loading-logs" class="text-sm text-gray-400 h-32 overflow-auto border p-2 rounded mt-2">
                <!-- As data loads, you append or stream logs here. -->
                </div>
                <div class="mt-2 text-right">
                <!-- On completion, show the Next button. Hide it by default. -->
                <button type="button" id="initialNextBtn" class="bg-blue-500 text-white px-4 py-2 rounded hidden">
                    Next
                </button>
                </div>
            </div>
            
            <!-- Step 2: Asset Types -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Define Asset Types</h3>
                <p class="text-sm text-gray-600 mb-2">Select an asset category to continue.</p>

                <!-- Asset Category Selection -->
                <div id="asset-category-container">
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="devices" class="mr-2"> Devices
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="networks" class="mr-2"> Networks
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="applications" class="mr-2"> Applications & Workloads
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="data" class="mr-2"> Data
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="identities" class="mr-2"> Identities
                    </label>
                </div>

                <!-- Asset Type Selection -->
                <label class="block mt-2">Select Asset Type:
                    <select id="asset-type-dropdown" class="border p-2 w-full" disabled>
                        <option value="">Select an asset category first</option>
                    </select>
                </label>

                <!-- Environment Selection -->
                <div id="environment-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Environment:
                        <select id="environment-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Record Count Selection (Only for Data) -->
                <div id="record-count-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Estimated Record Count:
                        <select id="record-count-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Monitoring Coverage Selection -->
                <div id="monitoring-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Monitoring Coverage:</label>
                    <div id="network-monitoring" data-label="Network Monitoring"></div>
                    <div id="process-monitoring" data-label="Process Monitoring"></div>
                    <div id="file-monitoring" data-label="File Monitoring"></div>
                    <div id="cloud-monitoring" data-label="Cloud Monitoring"></div>
                    <div id="hardware-monitoring" data-label="Hardware Monitoring"></div>
                </div>

                <!-- Table listing the existing modelInstances asset-type records -->
                <div class="mt-6">
                    <h4 class="text-md font-semibold">Current Asset Instances</h4>
                    <table id="asset-type-instances-table" class="w-full border-collapse border border-gray-300 text-sm mt-2">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                        <th class="border border-gray-300 px-4 py-2">Environment</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                        <th class="border border-gray-300 px-4 py-2">Monitoring Coverage</th>
                        <th class="border border-gray-300 px-4 py-2">Record Count</th>
                        <!-- You can add more columns if needed -->
                        </tr>
                    </thead>
                    <tbody id="asset-type-instances-body"></tbody>
                    </table>
                </div>

                <!-- Submit Asset Type -->
                <button type="button" id="submit-asset-type" class="bg-green-500 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    Add Asset Type
                </button>

                <!-- Display Model Definition in JSON -->
                <button type="button" id="view-model-definition" class="bg-gray-700 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    View Model JSON
                </button>
            </div>

            <!-- Step 3: Technique Scoring -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">MITRE ATT&CK Techniques Inventory</h3>
                <p class="text-sm text-gray-600 mb-4">Review the MITRE ATT&CK techniques relevant to each asset type.</p>
            
                <!-- Summary Table -->
                <table id="model-summary-table" class="w-full border-collapse border border-gray-300 text-sm">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                            <th class="border border-gray-300 px-4 py-2">Environment</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                            <th class="border border-gray-300 px-4 py-2">Count of MITRE ATT&CK Techniques</th>
                        </tr>
                    </thead>
                    <tbody id="model-summary-body"></tbody>
                </table>
            
                <!-- Techniques Table Container -->
                <div id="techniques-container" class="hidden mt-6">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-semibold">Techniques for <span id="selected-asset-type"></span></h4>
                        <button id="toggle-techniques-btn" type="button" bg-gray-600 text-white px-3 py-1 rounded">
                            Hide Techniques
                        </button>
                    </div>

                    <table id="techniques-table" class="w-full border-collapse border border-gray-300 text-sm">
                        <thead>
                            <tr class="bg-gray-700 text-white">
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique ID</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique Name</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Score</th>
                            </tr>
                        </thead>
                        <tbody id="techniques-body"></tbody>
                    </table>
                </div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>

            </div>

            <!-- Step 4: Radial Tree Visualization -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">ATT&CK Technique Visualization</h3>
                <p class="text-sm text-gray-600 mb-4">Select a category to visualize:</p>

                <!-- Radio Button Selection for Correlation Type -->
                <div id="visualization-selection" class="mb-4">
                    <label><input type="radio" name="visualization-type" value="detections" checked> ATT&CK Detections</label>
                    <label><input type="radio" name="visualization-type" value="mitigations"> ATT&CK Mitigations</label>
                    <label><input type="radio" name="visualization-type" value="nist"> NIST Controls</label>
                    <label><input type="radio" name="visualization-type" value="cis"> CIS Safeguards</label>
                    <label><input type="radio" name="visualization-type" value="aws"> AWS Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="gcp"> GCP Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="azure"> Azure Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="m365"> M365 Capabilities</label>
                </div>

                <!-- Radial Tree Visualization Container -->
                <div id="radial-tree-container" class="w-full h-96 border border-gray-300 rounded bg-white"></div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>
            </div>

            <!-- Step 5: Organization Details -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Organization Details</h3>
                <p class="text-sm text-gray-600 mb-2">Define your organization's security practices.</p>

                <div id="organization-details">
                    <label class="block mt-2">
                        <input type="checkbox" id="ai_automation" class="mr-2">
                        AI & Automation for Information Security
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_security_staff" class="mr-2">
                        Cybersecurity Training for Security Staff
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_all_employees" class="mr-2">
                        Cybersecurity Training for All Employees
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="incident_response_testing" class="mr-2">
                        Conduct Incident Response Tests
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="law_enforcement_ransomware" class="mr-2">
                        Engage Law Enforcement for Ransomware
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="data_encryption" class="mr-2">
                        Encrypt Stored Data (Beyond Disk Encryption)
                    </label>
                </div>
            </div>

        </form>

        <!-- JSON Output -->
        <pre id="json-output" class="bg-gray-100 text-black p-4 rounded mt-4" style="display: none;"></pre>
    </div>
    <script>

        // Target JSON structure for modelInstances asset-type-instances:
        // {
        //     "asset-category": "devices", // user input, radio button selection enum is the unique array of values from capabilities.capability_group where capabilities.type = "asset-type"
        //     "asset-type": "Linux Server OS", // user input, drop-down selection enum is the unique array of values from capabilities.capability_id where capabilities.type = "asset-type"
        //     "environment": "AWS", // from user input, enum ["AWS", "GCP", "Azure", "M365"]
        //     "record-count": "500-2k", // "record-count" is only present if "asset-category" is "data", from user drop-down selection; enum ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"]
        //     "monitoring-coverage": { // from user input, enum ["None", "Low", "Medium", "High"]
        //         "network-monitoring": "High",
        //         "process-monitoring": "Medium",
        //         "file-monitoring": "Low",
        //         "cloud-monitoring": "None",
        //         "hardware-monitoring": "None"
        //     },
        //     "abused-by-techniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "abused-by"
        //         "T1001": { // from capabilities.[].attack_object_id where capabilities.[].capability_id = asset-type for this record, capabilities.[].record_type = "asset-type" and capabilities.[].mapping_type = "abused-by"
        //             "technique_name": "Data Obfuscation", // from attack store
        //             "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
        //             "data-sources": [], // from the attack store
        //             "nist-controls": [], // from capabilities where record_type is "nist-controls"
        //             "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
        //             "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
        //             "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
        //             "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
        //             "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
        //             "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
        //             "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
        //             "initial-score": 0.5 // float to the tenthousandths; initialScore = prevalenceScore + chokepointScore + actionabilityScore
        //         }
        //     },
        //     "targeted-by-techniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "targeted-by"
        //         "T1002": { // one technique record per attack_object_id found in the mapex files
        //             "technique_name": "Data Compressed",
        //             "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
        //             "data-sources": [], // from the attack store
        //             "nist-controls": [], // from capabilities where record_type is "nist-controls"
        //             "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
        //             "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
        //             "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
        //             "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
        //             "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
        //             "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
        //             "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
        //             "initial-score": 0.5265 // float to the tenthousandths; initialScore = prevalenceScore + chokepointScore + actionabilityScore
        //         }
        //     }
        // }
        // // from STIX, external_references.[].external_id where "type": "attack-pattern"
        // target json structure for techniques records: 
        // {
        //     "technique_id": "T1001", // one technique record per attack_object_id 
        //     "technique_name": "Data Compressed", // from "attack" store where type="attack-pattern" and external_references.[].external_id=technique_id, get name
        //     "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
        //     "data-sources": [], // from the attack store
        //     "nist-controls": [], // from capabilities where record_type is "nist-controls"
        //     "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
        //     "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
        //     "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
        //     "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
        //     "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
        //     "mitigations": [], // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
        //     "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
        //     "initial-score": 0.5 // initialScore = prevalenceScore + chokepointScore + actionabilityScore
        // }
        //
        //
        function initShuffleDb() {
            const db = new Dexie("shuffledb");
            db.version(1).stores({
                modelInstances: "++id, record_type, assetCategory, assetType, environment, monitoringCoverage, recordCount, abusedByTechniques, targetedByTechniques, &[assetType+environment+monitoringCoverage]", // tracks all info about asset type instances selected by the user
                techniques: "++id, &technique_id, technique_name, monitoring_coverage_eval, data_sources, nist_controls, cis_safeguards, aws_capabilities, gcp_capabilities, azure_capabilities, m365_capabilities, mitigations", // imported from assetType files
                capabilities: "++id, record_type, capability_group, capability_id, capability_description, mapping_type, attack_object_id, attack_object_name", // imported from MAPEX files and CIS_safeguard_to_technique.json file
                staticVariables: "++id, record_type", // imported from static-variables.json and weight-keywords.json, if from static-variables.json, record_type = "static", if from weight-keywords.json, record_type = "keyword", if from attack-prev-tid.json, record_type = "calc"
                attack: "&id, type, record_type" // imported from enterprise-attack.json "objects" array
            });
            db.open().catch((err) => {
                console.error("Failed to open db:", err);
            }); 
            return db;
        }    
        
        const filesArr = [
            { file: "static-variables.json", format: "json", store: "staticVariables", record_type: "static", import_from: "." },
            { file: "weight-keywords.json", format: "json", store: "staticVariables", record_type: "keyword", import_from: "." },
            { file: "attack-prev-tid.json", format: "json", store: "staticVariables", record_type: "calc", import_from: "." },
            { file: "enterprise-attack.json", format: "stix", store: "attack", record_type: "attack_objects", import_from: "objects" },
            { file: "cis_safeguard_to_techniques.json", format: "json", store: "capabilities", record_type: "cis_safeguards", import_from: "." },
            { file: "enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects"},
            { file: "enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "nist_800_53-rev5_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "nist_controls", import_from: "mapping_objects" },
            { file: "m365-12.11.2023_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "m365_capabilities", import_from: "mapping_objects" },
            { file: "gcp-06.28.2022_attack-10.0-enterprise.json", format: "mapex", store: "capabilities", record_type: "gcp_capabilities", import_from: "mapping_objects" },
            { file: "azure-06.29.2021_attack-8.2-enterprise.json", format: "mapex", store: "capabilities", record_type: "azure_capabilities", import_from: "mapping_objects" },
            { file: "aws-12.12.2024_attack-16.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "aws_capabilities", import_from: "mapping_objects" }
        ];

        /**
         * Fetches a single JSON file, extracts the relevant data, sets the record_type,
         * and bulk puts them into the specified store. Logs start and finish messages.
         *
         * @param {Dexie} db      - The Dexie database instance.
         * @param {Object} fileDef  - An object describing how to import the file.
         *    @property {string} file         - The file name to fetch (e.g. "static-variables.json")
         *    @property {string} format       - The file format (e.g. "json", "stix", "mapex")
         *    @property {string} store        - The Dexie store name (e.g. "staticVariables")
         *    @property {string} record_type  - The record_type to inject into each object
         *    @property {string} import_from  - The property name in the JSON (".", "objects", "mapping_objects")
         */
        async function importSingleJsonFile(db, fileDef) {
        try {
            // Log start
            console.log(`Starting import: ${fileDef.file}`);
            addLogMessage(`Starting import: ${fileDef.file}`);

            // 1) Fetch the JSON
            const response = await fetch(fileDef.file);
            if (!response.ok) {
            throw new Error(`Failed to fetch ${fileDef.file}: ${response.statusText}`);
            }
            let data = await response.json();

            // 2) Based on import_from, extract the array of objects we want to import
            let recordsToImport = [];
            if (fileDef.import_from === ".") {
            // Could be an array or object at the root
            if (Array.isArray(data)) {
                recordsToImport = data;
            } else if (typeof data === "object") {
                // If the data is an object, you might push it as a single record,
                // or handle however your format requires. Example:
                recordsToImport = [data];
            }
            } else {
            // e.g. "objects", "mapping_objects"
            if (!data[fileDef.import_from]) {
                console.warn(`Property "${fileDef.import_from}" not found in ${fileDef.file}`);
                recordsToImport = [];
            } else {
                // if data[fileDef.import_from] is an array, use it directly
                // if it’s an object, put that in an array, etc.
                const subData = data[fileDef.import_from];
                recordsToImport = Array.isArray(subData) ? subData : [subData];
            }
            }

            // 3) If format is "mapex" or "stix", you might do additional parsing
            //    For example, STIX might store an array in "objects".
            //    But in this example, we rely purely on import_from to find the array
            //    so you can simply rely on the logic above.

            // 4) For each object, inject the record_type from fileDef.
            recordsToImport.forEach(obj => {
            obj.record_type = fileDef.record_type;
            });

            // 5) Bulk put into the specified store.
            //    Dexie’s .bulkPut() will handle either an empty array or large arrays.
            if (recordsToImport.length > 0) {
            await db[fileDef.store].bulkPut(recordsToImport);
            }

            // Log finish, show how many objects were imported
            console.log(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);
            addLogMessage(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);

        } catch (err) {
            console.error(`Error importing ${fileDef.file}:`, err);
            addLogMessage(`Error importing ${fileDef.file}: ${err.message}`);
        }
        }

        /**
         * Utility function to append messages to the #loading-logs element on the page.
         *
         * @param {string} message - The log message to display.
         */
        function addLogMessage(message) {
        const logsEl = document.getElementById("loading-logs");
        if (!logsEl) {
            console.warn("No element with id='loading-logs' found.");
            return;
        }
        const newLine = document.createElement("div");
        newLine.textContent = message;
        logsEl.appendChild(newLine);
        }


        // Run the function when the page loads
        document.addEventListener("DOMContentLoaded", async () => {
            const db = initShuffleDb();
            await runInitializationSequence(db)
            showStep(0);

            // set dark mode
            const savedMode = await getObjectById("settings", "darkMode");
            if (savedMode) document.body.classList.toggle("dark", savedMode.value === "dark");
            
            // // populate environment dropdown
            // populateEnvironmentSelection();

            // // populate record count dropdown
            // populateRecordCountSelection();

            // //populate monitoring coverage radio sets
            // populateMonitoringCoverageSelections();

            // set event listeners
            // Listen for user selecting an asset category radio button
            document.querySelectorAll("#asset-category-container input[type='radio']")
            .forEach(radio => {
                radio.addEventListener("change", async (e) => {
                    const selectedCategory = e.target.value; // e.g. "devices", "data"
                    // If you have db loaded, call:
                    await populateAssetTypeDropdown(db, selectedCategory);

                    // Optionally show/hide record count selection if category="data"
                    const recordCountDiv = document.getElementById("record-count-selection");
                    if (selectedCategory === "data") {
                    recordCountDiv.style.display = "block";
                    } else {
                    recordCountDiv.style.display = "none";
                    }

                    // You can also show environment-selection and monitoring-selection by default
                    document.getElementById("environment-selection").style.display = "block";
                    document.getElementById("monitoring-selection").style.display = "block";
                });
            });
        });
    

        /*******************************************************
         * 1. Populate Asset Type Dropdown
         * 
         * - Queries Dexie capabilities store for records:
         *    record_type="asset-types" and capability_group = selectedCategory
         * - Fills the <select id="asset-type-dropdown"> with options.
         * - If none found, leaves a placeholder option.
         *******************************************************/
        async function populateAssetTypeDropdown(db, selectedCategory) {
        const assetTypeDropdown = document.getElementById("asset-type-dropdown");
        if (!assetTypeDropdown) return;

        // Clear existing options
        assetTypeDropdown.innerHTML = "";

        // If no category is selected, disable and show placeholder
        if (!selectedCategory) {
            assetTypeDropdown.disabled = true;
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select an asset category first";
            assetTypeDropdown.appendChild(placeholder);
            return;
        }

        // Query Dexie for asset-type records
        const entries = await db.capabilities
            .where("record_type").equals("asset_types")
            .and(c => c.capability_group === selectedCategory)
            .toArray();

        // Hide loading indicator
        if (loadingIcon) loadingIcon.style.display = "none";

        // If we found none, show a “No Asset Types Available” option
        if (!entries.length) {
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = `No asset types found for ${selectedCategory}`;
            assetTypeDropdown.appendChild(placeholder);
            assetTypeDropdown.disabled = true;
            return;
        }

        // Otherwise populate
        assetTypeDropdown.disabled = false;
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select an asset type";
        assetTypeDropdown.appendChild(placeholder);

        // Each entry’s capability_id is the name
        // Some categories might have duplicates, so we can deduplicate in a Set
        const seen = new Set();
        entries.forEach(entry => {
            if (entry.capability_id && !seen.has(entry.capability_id)) {
            seen.add(entry.capability_id);
            const opt = document.createElement("option");
            opt.value = entry.capability_id;
            opt.textContent = entry.capability_id;
            assetTypeDropdown.appendChild(opt);
            }
        });
        }

        /*******************************************************
         * 2. Populate Environment Dropdown
         * 
         * Populates <select id="environment-dropdown"> with:
         *   "AWS", "Azure", "GCP", "M365"
         *******************************************************/
        function populateEnvironmentSelection() {
        const envDropdown = document.getElementById("environment-dropdown");
        if (!envDropdown) return;

        envDropdown.innerHTML = "";
        const environments = ["AWS", "Azure", "GCP", "M365"];
        environments.forEach(env => {
            const opt = document.createElement("option");
            opt.value = env;
            opt.textContent = env;
            envDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 3. Populate Record Count Selection
         * 
         * Populates <select id="record-count-dropdown"> with:
         *   "<500", "500-2k", "2k-10k", "10k-100k", ">100k"
         * 
         * Only displayed if the selected asset category = "data"
         *******************************************************/
        function populateRecordCountSelection() {
        const recordCountDropdown = document.getElementById("record-count-dropdown");
        if (!recordCountDropdown) return;

        recordCountDropdown.innerHTML = "";
        const recordCounts = ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"];
        recordCounts.forEach(count => {
            const opt = document.createElement("option");
            opt.value = count;
            opt.textContent = count;
            recordCountDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 4. Populate Monitoring Coverage Selections
         * 
         * For each of:
         *   #network-monitoring
         *   #process-monitoring
         *   #file-monitoring
         *   #cloud-monitoring
         *   #hardware-monitoring
         * Provide a set of radio buttons (or a <select>) for:
         *   "High", "Medium", "Low", "None"
         *******************************************************/
        function populateMonitoringCoverageSelections() {
        const coverageLevels = ["High", "Medium", "Low", "None"];

        // Helper to build radio group or dropdown inside a container
        function buildCoverageRadios(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ""; // clear existing

            const labelText = container.dataset.label || containerId;
            const labelEl = document.createElement("div");
            labelEl.classList.add("font-semibold", "mb-1");
            labelEl.textContent = labelText;
            container.appendChild(labelEl);

            coverageLevels.forEach(level => {
            const wrapper = document.createElement("label");
            wrapper.classList.add("inline-flex", "items-center", "mr-3");

            const input = document.createElement("input");
            input.type = "radio";
            input.name = containerId; // so all are in one group
            input.value = level;
            input.classList.add("mr-1");

            wrapper.appendChild(input);
            wrapper.appendChild(document.createTextNode(level));
            container.appendChild(wrapper);
            });
        }

        // Build coverage for each ID
        buildCoverageRadios("network-monitoring");
        buildCoverageRadios("process-monitoring");
        buildCoverageRadios("file-monitoring");
        buildCoverageRadios("cloud-monitoring");
        buildCoverageRadios("hardware-monitoring");
        }

        // re‑render the AssetTypeInstancesTable in Step 2 each time you insert a new asset‑type‑instance record into modelInstances store
        async function refreshAssetTypeInstancesTable() {
            const tableBody = document.getElementById("asset-type-instances-body");
            tableBody.innerHTML = "";

            // Get all asset-type-instance records from Dexie
            const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset_type_instance")
                .toArray(); 
                // Or adapt if you’re labeling them differently

            allInstances.forEach(instance => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                <td class="border border-gray-300 px-4 py-2">${instance.environment || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-category"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-type"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">
                    ${JSON.stringify(instance["monitoring-coverage"] || {})}
                </td>
                <td class="border border-gray-300 px-4 py-2">${instance["record-count"] || ""}</td>
                `;
                tableBody.appendChild(tr);
            });
        }

    
        // Generate Radial Tree Visualization
        // Must be root > environments > asset-categories > asset-types > techniques > [mitigations, detections, nist-controls, cis-safeguards, aws-capabilities, gcp-capabilities, azure-capabilities, m365-capabilities] 
        async function generateRadialTree() {
            const techniques = await getAllObjects("visualizationTree");
    
            const svg = d3.select("#radial-tree-container").append("svg")
                .attr("width", 800).attr("height", 600)
                .append("g").attr("transform", "translate(400,300)");
    
            const hierarchy = d3.hierarchy({ children: techniques });
            const treeLayout = d3.tree().size([360, 250]);
            treeLayout(hierarchy);
    
            svg.selectAll("line")
                .data(hierarchy.links())
                .enter()
                .append("line")
                .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y)
                .attr("stroke", "black");
        }

        // Function to Handle Navigation Between Steps
        let currentStep = 0;
        const steps = document.querySelectorAll(".form-step");
        const nextButton = document.getElementById("next-step");
        const prevButton = document.getElementById("prev-step");
        const progressItems = document.querySelectorAll(".progress-bar li");

        // Function to update steps
        function showStep(step) {
            // Hide all steps and remove active class
            steps.forEach((el, index) => {
                el.classList.toggle("active", index === step);
                el.style.display = index === step ? "block" : "none";
            });

            // Update progress bar
            progressItems.forEach((el, index) => {
                el.classList.toggle("active", index === step);
            });

            // Hide back button on first step
            prevButton.classList.toggle("hidden", step === 0);

            // Change "Next" button to "Finish" on the last step
            nextButton.innerText = step === steps.length - 1 ? "Finish" : "Next";
        }

        // Function to Hide the Techniques Table and JSON Output
        function hideDynamicElements() {
            document.getElementById("techniques-container").classList.add("hidden");
            document.getElementById("json-output").style.display = "none";
        }

        // Next Button Click Event
        nextButton.addEventListener("click", async () => {
            if (currentStep < steps.length - 1) {
                if (currentStep === 0) {
                    buildOrganizationAttributes();
                }
                if (currentStep === 1) {
                    // ✅ Only recalculate if scores do not exist
                    const scoresExist = modelDefinition.asset_types.some(asset => asset.attack_scores?.length > 0);
                    if (!scoresExist) {
                        await calculateAllTechniqueScores();
                    }
                    updateModelDisplay();
                    generateModelSummaryTable();
                }
                if (currentStep === 2) {
                    // ✅ Wait for JSON files to be fully loaded before updating model
                    if (!jsonCache.nistMapping || !jsonCache.enterpriseAttack) {
                        console.error("❌ Error: Required JSON files not loaded.");
                        showToast("Error: Required JSON files not loaded.", "error");
                        return;
                    }
                    generateRadialTree();
                }

                currentStep++;
                showStep(currentStep);
                hideDynamicElements();
            } else {
                alert("Form Submitted!"); // Replace this with actual form submission logic
            }
        });

        // Back Button Click Event
        prevButton.addEventListener("click", () => {
            if (currentStep > 0) {
                currentStep--;
                showStep(currentStep);
                hideDynamicElements();
                updateModelDisplay(); // ✅ Ensure JSON output is updated
            }
        });
   
        // Dark Mode Toggle
        async function toggleDarkMode() {
            const body = document.body;
            body.classList.toggle("dark");
            const mode = body.classList.contains("dark") ? "dark" : "light";
            await storeObject("settings", { key: "darkMode", value: mode });
        }

        // function to build json representation of model with selected asset-type-instance records and users' responses to organizational attributes
        async function buildModelJson() {

        }
    
        // JSON Export & Download
        async function exportModelAsJSON() {
            const techniques = await getAllObjects("techniques");
            const blob = new Blob([JSON.stringify(techniques, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "model-data.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    
        document.getElementById("download-json").addEventListener("click", exportModelAsJSON);

        // Function to Build Organization Attributes from Checkboxes
        function buildOrganizationAttributes() {
            document.querySelectorAll("#organization-details input[type='checkbox']").forEach(input => {
                modelDefinition.organization_attributes[input.id] = input.checked;  // ✅ Ensure proper assignment
            });

            // console.log("Saved Organization Attributes:", modelDefinition.organization_attributes);
        }

        // Function to generate a table showing the asset-type-instance records and the average ATT&CK score for each
        function generateModelSummaryTable() {
            const tableBody = document.getElementById("model-summary-body");
            tableBody.innerHTML = "";

            modelDefinition.asset_types.forEach(asset => {
                const techniques = asset.attack_scores || [];

                const avgScore = techniques.length
                    ? (techniques.reduce((sum, t) => sum + parseFloat(t.score), 0) / techniques.length).toFixed(4)
                    : "N/A";

                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${asset.environment}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_category}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_type}</td>
                    <td class="border border-gray-300 px-4 py-2 text-blue-500 cursor-pointer">
                        ${techniques.length} techniques (Avg Score: ${avgScore})
                    </td>
                `;

                // ✅ Pass asset type name instead of JSON
                row.querySelector("td:last-child").addEventListener("click", () => {
                    displayTechniquesTable(asset.asset_type);
                });

                tableBody.appendChild(row);
            });
        }

        // function to create a table showing the ATT&CK techniques for a given asset type and the ATT&CK score for each technique
        async function displayTechniquesTable(assetTypeName) {
            const tableBody = document.getElementById("techniques-body");
            tableBody.innerHTML = "";

            document.getElementById("selected-asset-type").textContent = assetTypeName;
            document.getElementById("techniques-container").classList.remove("hidden");

            // Find the asset type object
            const selectedAssetType = modelDefinition.asset_types.find(asset => asset.asset_type === assetTypeName);
            if (!selectedAssetType) {
                console.error(`Error: Asset type '${assetTypeName}' not found in model definition.`);
                return;
            }

            // Use precomputed attack scores
            const techniques = selectedAssetType.attack_scores || [];

            techniques.forEach(technique => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_id}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_name}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.score}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        document.getElementById("submit-asset-type").addEventListener("click", async () => {
            const assetTypeName = document.getElementById("asset-type-dropdown").value;
            const environment   = document.getElementById("environment-dropdown").value;
            const selectedCategory = document.querySelector('input[name="asset-category"]:checked').value;
            // gather monitoring coverage inputs, e.g.:
            const coverage = {
                "network-monitoring": selectedNetworkCoverage,
                "process-monitoring": selectedProcessCoverage,
                "file-monitoring": selectedFileCoverage,
                "cloud-monitoring": selectedCloudCoverage,
                "hardware-monitoring": selectedHardwareCoverage
            };
            let recordCount;
            if (selectedCategory === "data") {
                recordCount = parseInt(document.getElementById("record-count-dropdown").value, 10);
            }

            await updateModelValuesForAssetType(assetTypeName, environment, coverage, recordCount);
            // Possibly show a success message or move to the next step.
        });

        /************************************************************
         * countDetections
         * ----------------------------------------------------------
         * 1. From the "attack" store, find the relationship objects:
         *    type="relationship", relationship_type="detects", target_ref=patternId
         * 2. Return the count of detections.
         ************************************************************/
        async function countDetections(db, patternId) {
        // find all relationship objects that mitigate this pattern
        const relationships = await db.attack
            .where("type").equals("relationship")
            .and(rel => rel.relationship_type === "detects" && rel.target_ref === patternId)
            .toArray();

        return relationships.length;
        }

        /************************************************************
         * Main entry point: createAllTechniques
         * ----------------------------------------------------------
         * 1. Gathers all unique attack_object_id values from the
         *    "capabilities" store (the techniques).
         * 2. Builds a technique record for each technique_id.
         * 3. bulkPut() them all into the "techniques" store.
         * 
         * Adjust naming and references to match your project’s code.
         ************************************************************/
        async function createAllTechniques(db) {
        // 1) Gather all unique technique IDs from capabilities
            const uniqueTechniqueIds = await gatherUniqueTechniqueIds(db);
            console.log("Starting createAllTechniques...")
            // 2) Build the records
            const techniqueRecords = [];
            for (const techniqueId of uniqueTechniqueIds) {
                // For each techniqueId (e.g., "T1001") create a record
                const record = await buildTechniqueRecord(db, techniqueId);
                if (record) {
                techniqueRecords.push(record);
                }
            }

            // 3) Insert them into the "techniques" store
            if (techniqueRecords.length) {
                await db.techniques.bulkPut(techniqueRecords);
                console.log(`Created ${techniqueRecords.length} techniques in the techniques store.`);
            } else {
                console.log(`No techniques found to create.`);
            }
        }

        /************************************************************
         * gatherUniqueTechniqueIds
         * ----------------------------------------------------------
         * Reads from the "capabilities" store and extracts the
         * unique "attack_object_id" values. Returns them as a set or array.
         ************************************************************/
        async function gatherUniqueTechniqueIds(db) {
            const capabilityEntries = await db.capabilities.toArray();
            const techniqueIdSet = new Set();

            capabilityEntries.forEach(entry => {
                if (entry.attack_object_id) {
                techniqueIdSet.add(entry.attack_object_id);
                }
            });
            
            console.log("createAllTechniques: Returning techniqueIdSet...")
            return Array.from(techniqueIdSet);
        }

        /************************************************************
         * buildTechniqueRecord
         * ----------------------------------------------------------
         * Builds the final technique object for a given techniqueId.
         * Follows the data sources specified in the instructions:
         *   - "attack" store for name, data-sources, mitigations, etc.
         *   - "capabilities" store for nist-controls, cis-safeguards, etc.
         *   - "staticVariables" store for keywords (monitoring coverage)
         *     and "calc" entries (prevEntry).
         ************************************************************/
        async function buildTechniqueRecord(db, techniqueId) {
            // 1) From "attack" store, get the single pattern object
            const patternObj = await db.attack
                .where("type").equals("attack-pattern")
                .filter(obj => hasExternalReference(obj, "mitre-attack", techniqueId))
                .first();

            // If we can’t find a matching pattern, skip
            if (!patternObj) {
                console.warn(`No attack-pattern found for techniqueId: ${techniqueId}`);
                return null;
            }

            // Extract the name, ID, data-sources, and the official technique URL
            const technique_name = patternObj.name || techniqueId;
            const patternId = patternObj.id; // e.g. "attack-pattern--005a06c6..."
            const dataSources = patternObj.x_mitre_data_sources || [];
            const technique_url = getMitreUrlFromPattern(patternObj, techniqueId);

            // 2) Gather mitigations and count detections
            const mitigations = await gatherMitigations(db, patternId);
            const countDetectionsVal = await countDetections(db, patternId);

            // 3) Gather relevant capabilities (NIST, CIS, etc.)
            const nistControls       = await gatherCapabilityIds(db, "nist_controls",      techniqueId);
            const cisSafeguards      = await gatherCapabilityIds(db, "cis_safeguards",     techniqueId);
            const awsCapabilities    = await gatherCapabilityIds(db, "aws_capabilities",   techniqueId);
            const gcpCapabilities    = await gatherCapabilityIds(db, "gcp_capabilities",   techniqueId);
            const azureCapabilities  = await gatherCapabilityIds(db, "azure_capabilities", techniqueId);
            const m365Capabilities   = await gatherCapabilityIds(db, "m365_capabilities",  techniqueId);

            // 4) Build “monitoring-coverage-eval” by comparing data-sources to your weight-keywords
            const monitoringCoverageEval = await buildMonitoringCoverageEval(db, dataSources);

            // 5) Build “prevEntry” from staticVariables "calc" records
            const prevEntry = await buildPrevEntry(db, techniqueId, patternId);

            // 6) Compute “initial-score”
            const [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections] = prevEntry;
            const chokepointScore = computeChokepointFromValues(db, calc_tid_before, calc_tid_after);
            const actionabilityScore = computeActionabilityScore(db, nistControls.length, cisSafeguards.length, countDetectionsVal);
            const prevalenceScore = parseFloat(calc_prev_score) || 0;
            const initialScore = chokepointScore + actionabilityScore + prevalenceScore;

            // 7) Return the final object shaped as desired
            console.log("createAllTechniques: returning contextualized technique object for", $(techniqueid))
            return {
                technique_id: techniqueId,
                technique_url,
                technique_name,
                prevEntry,
                "data_sources": dataSources,
                "nist_controls": nistControls,
                "cis_safeguards": cisSafeguards,
                "aws_capabilities": awsCapabilities,
                "gcp_capabilities": gcpCapabilities,
                "azure_capabilities": azureCapabilities,
                "m365_capabilities": m365Capabilities,
                mitigations,
                "monitoring_coverage_eval": monitoringCoverageEval,
                "initial_score": parseFloat(initialScore).toFixed(4)
                // "initial_score": parseFloat(initialScore.toFixed(4)) // keep it to four decimals if desired
            };
        }

        /************************************************************
         * Helper: Check if STIX object has external_references
         * with source_name="mitre-attack" and external_id=techniqueId
         ************************************************************/
        function hasExternalReference(obj, sourceName, techniqueId) {
        if (!obj.external_references || !Array.isArray(obj.external_references)) return false;
        return obj.external_references.some(ref =>
            ref.source_name === sourceName && ref.external_id === techniqueId
        );
        }

        /************************************************************
         * Helper: Extract the official MITRE Attack URL from the
         * patternObj’s external_references, specifically where
         * source_name="mitre-attack" and external_id=techniqueId.
         ************************************************************/
        function getMitreUrlFromPattern(patternObj, techniqueId) {
        if (!patternObj.external_references) return "";
        const ref = patternObj.external_references.find(r =>
            r.source_name === "mitre-attack" && r.external_id === techniqueId
        );
        return ref && ref.url ? ref.url : "";
        }

        /************************************************************
         * gatherMitigations
         * ----------------------------------------------------------
         * 1. From the "attack" store, find the relationship objects:
         *    type="relationship", relationship_type="mitigates", target_ref=patternId
         * 2. For each relationship, retrieve the source_ref object
         *    from "attack" store if it's type="course-of-action".
         * 3. Extract the external_references from that course-of-action
         *    (especially external_id, name, etc.), building an array
         *    of mitigation info.
         ************************************************************/
        async function gatherMitigations(db, patternId) {
        // find all relationship objects that mitigate this pattern
        const relationships = await db.attack
            .where("type").equals("relationship")
            .and(rel => rel.relationship_type === "mitigates" && rel.target_ref === patternId)
            .toArray();

        const mitigations = [];
        // for each relationship, get the “course-of-action” record
        for (const rel of relationships) {
            const sourceRefId = rel.source_ref; // e.g. "course-of-action--abc123..."
            const coa = await db.attack
            .where("type").equals("course-of-action")
            .and(obj => obj.id === sourceRefId)
            .first();
            if (coa && Array.isArray(coa.external_references)) {
            // Extract external_id and name from those references
            const foundMitreRef = coa.external_references.find(r => r.source_name === "mitre-attack");
            const mitigation_id = foundMitreRef?.external_id || "";
            const mitigation_name = coa.name || "";
            mitigations.push({
                mitigation_id,
                mitigation_name
            });
            }
        }

        console.log("createAllTechniques: returning mitigations for", $(techniqueid))
        return mitigations;
        }

        /************************************************************
         * gatherCapabilityIds
         * ----------------------------------------------------------
         * For the given record_type in the "capabilities" store,
         * return an array of capability_id values where
         * attack_object_id = techniqueId.
         ************************************************************/
        async function gatherCapabilityIds(db, recordType, techniqueId) {
        const entries = await db.capabilities
            .where("record_type").equals(recordType)
            .and(c => c.attack_object_id === techniqueId)
            .toArray();

        return entries.map(e => e.capability_id);
        }

        /************************************************************
         * buildMonitoringCoverageEval
         * ----------------------------------------------------------
         * - Query the "staticVariables" store for record_type="keywords".
         * - The store presumably includes key-value pairs like:
         *     { key: "Command", value: "process" }
         *   or
         *     { "Command": "process", "File": "file", ...}
         * - For each keyword => if dataSources includes a string
         *   that (case-insensitive) contains the keyword, push
         *   the value into an array.
         * - Deduplicate and return the array.
         ************************************************************/
        async function buildMonitoringCoverageEval(db, dataSources) {
        // convert dataSources to lowercase for matching
        const lowerSources = dataSources.map(s => s.toLowerCase());

        // fetch all keyword entries
        // your store might store them in different shapes,
        // so adapt as needed:
        const keywords = await db.staticVariables
            .where("record_type").equals("keywords")
            .toArray();

        // If your “keywords” records are shaped like:
        //   { key: "Command", value: "process" }
        // then do this. If shaped differently, adapt accordingly.
        // 
        // (Some designs store them in a single record. Others store
        // each key-value pair in separate records.)
        const coverage = new Set();

        // Flatten out all the key-value pairs
        // e.g. if keywords = [ { key: "Command", value: "process" },
        //                      { key: "File",    value: "file" } ]
        // then we just iterate each record:
        for (const kw of keywords) {
            const theKey = kw.key || "";
            const theVal = kw.value || "";
            if (!theKey || !theVal) continue;

            // if dataSources contain theKey substring
            // (case-insensitive compare)
            const lowerKey = theKey.toLowerCase();
            const matched = lowerSources.some(ds => ds.includes(lowerKey));
            if (matched) {
            coverage.add(theVal);
            }
        }

        console.log("createAllTechniques: returning monitoring coverage eval array")
        return Array.from(coverage);
        }

        /************************************************************
         * buildPrevEntry
         * ----------------------------------------------------------
         * - From staticVariables store where record_type="calc" and
         *   attack_object_id=techniqueId => get calc_tid_before,
         *   calc_tid_after, calc_prev_score
         * - From "attack" store => type="relationship",
         *   relationship_type="detects", target_ref=patternId => count
         *   unique relationships => that is calc_detections
         * - Return the array: [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections]
         ************************************************************/
        async function buildPrevEntry(db, techniqueId, patternId) {
        // 1) Get any "calc" record from staticVariables
        const calcEntry = await db.staticVariables
            .where("record_type").equals("calc")
            .and(r => r.attack_object_id === techniqueId)
            .first();

        const calc_tid_before = parseFloat(calcEntry?.calc_tid_before) || 0;
        const calc_tid_after  = parseFloat(calcEntry?.calc_tid_after)  || 0;
        const calc_prev_score = parseFloat(calcEntry?.calc_prev_score) || 0;

        // 2) Count the “detects” relationships for this pattern
        const detectsList = await db.attack
            .where("type").equals("relationship")
            .and(rel => rel.relationship_type === "detects" && rel.target_ref === patternId)
            .toArray();
        const calc_detections = detectsList.length;

        return [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections];
        }

        /************************************************************
         * computeChokepointFromValues
         ************************************************************/
        async function computeChokepointFromValues(db, tidBefore, tidAfter) {
            try {
            // 1. Retrieve Static Variables
            const beforeLower = await db.staticVariables.chokepoint_before_lower_cutoff || 0;
            const beforeUpper = await db.staticVariables.chokepoint_before_upper_cutoff || 1;
            const afterLower  = await db.staticVariables.chokepoint_after_lower_cutoff  || 0;
            const afterUpper  = await db.staticVariables.chokepoint_after_upper_cutoff  || 1;
            const wBefore1    = await db.staticVariables.chokepoint_w_before1           || 1;
            const ratio       = await db.staticVariables.chokepoint_before_to_after_ratio || 1;
            
            // 2. Clamp function to ensure values stay within [0, 1]
            function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
                }

                // 3. Compute the clamped "utilities" for before/after
                //    Scale tidBefore and tidAfter based on lower/upper cutoffs and clamp
                const beforeClamped = clamp(
                (tidBefore - beforeLower) / (beforeUpper - beforeLower),
                0, 
                1
                );
                const afterClamped  = clamp(
                (tidAfter  - afterLower)  / (afterUpper  - afterLower),
                0, 
                1
                );

                // 4. Compute weights for the formula
                //    a) Weight portion for "after" (wAfter1)
                const wAfter1 = (wBefore1 / ratio) 
                                * (afterUpper - afterLower)
                                / (beforeUpper - beforeLower);

                //    b) WeightBefore & WeightAfter
                const weightBefore = wBefore1 / (wAfter1 + wBefore1);
                const weightAfter  = wAfter1 / (wAfter1 + wBefore1);

                // 5. Combine them for the final chokepointScore
                const chokepointScore = (weightBefore * beforeClamped) 
                                    + (weightAfter  * afterClamped);

                console.log("createAllTechniques: returning chokepointScore", $(chokepointScore))
                return chokepointScore;

            } catch (error) {
                console.error("Error in computeChokepointFromValues:", error);
                return 0; // Return 0 if something goes wrong
            }
        } 

        /************************************************************
         * computeActionabilityScore
         * ----------------------------------------------------------
         * Another placeholder that might rely on static variables
         * for weighting. Provide your actual logic here.
         ************************************************************/
        async function computeActionabilityScore(db, nistCount, cisCount, detectionCount) {
            try {
                const mitigationsLowerCutoff = await db.staticVariables.actionability_mitigations_lower_cutoff || 0;
                const mitigationsUpperCutoff = await db.staticVariables.actionability_mitigations_upper_cutoff || 1;
                const detectionsLowerCutoff  = await db.staticVariables.actionability_detections_lower_cutoff  || 0;
                const detectionsUpperCutoff  = await db.staticVariables.actionability_detections_upper_cutoff  || 1;

                // 1. Compute the "mitigationsUtility" (clamped between 0 and 1)
                const rawMiti = (nistCount + cisCount) - mitigationsLowerCutoff;
                const mitigationsUtility = Math.min(
                Math.max(rawMiti / (mitigationsUpperCutoff - mitigationsLowerCutoff), 0),
                1
                );

                // 2. Compute the "detectionsUtility" (clamped as well)
                const rawDetect = detectionCount - detectionsLowerCutoff;
                const detectionsUtility = Math.min(
                Math.max(rawDetect / (detectionsUpperCutoff - detectionsLowerCutoff), 0),
                1
                );

                // 3. Weigh them according to your actionability formula
                const wMiti1 = await db.staticVariables.actionability_w_miti1 || 1;
                const ratio  = await db.staticVariables.actionability_mitigations_to_detections_ratio || 1;

                // 4. The partial weight for detections
                const actionabilityWeightDetect1 = (wMiti1 / ratio) *
                (detectionsUpperCutoff - detectionsLowerCutoff) /
                (mitigationsUpperCutoff - mitigationsLowerCutoff);

                // 5. The relative weights for mitigations & detections
                const actionabilityWeightMiti   = wMiti1 / (actionabilityWeightDetect1 + wMiti1);
                const actionabilityWeightDetect = actionabilityWeightDetect1 / (actionabilityWeightDetect1 + wMiti1);

                // 6. Combine them for the final "actionabilityScore"
                const actionabilityScore =
                (actionabilityWeightMiti   * mitigationsUtility) +
                (actionabilityWeightDetect * detectionsUtility);

                console.log("createAllTechniques: returning actionabilityScore", $(actionabilityScore))
                return actionabilityScore;

            } catch (error) {
                console.error("Error in computeActionablityScore:", error);
                return 0; // fallback if something goes wrong
            }
        }

        /************************************************************
         * USAGE (example)
         * ----------------------------------------------------------
         * const db = initShuffleDb();
         * await createAllTechniques(db);
         ************************************************************/


        //
        // Contextual Asset Type Construction
        //
        /*
        * IMPORTANT - Needs to be updated to use Dexie.js and new shuffledb schema
         * Builds a contextualized asset-type-instance object for each unique assetType found in your
         * MAPEX “assetTypeMappings” (devicesMappings, networksMappings, etc.) and enriches
         * them with the relevant technique data (prevEntry, data-sources, etc.).
         * 
         * Finally, writes them to the "contextualizedAssetTypes" store in IndexedDB,
         * keyed by a field "assetTypeId" (e.g. "Linux Server OS").
         */
        async function buildContextualAssetTypes() {
            try {
                const db = await initIndexedDB();

                // 1. Gather all assetTypeMappings from your MAPEX store(s).
                //    For example, if you've stored them in "devicesMappings", "networksMappings", etc.,
                //    you can fetch them all or you can unify them into a single store. 
                //    Here is a conceptual example of retrieving them:
                const storeNames = [
                "devicesMappings",
                "networksMappings",
                "applicationsMappings",
                "dataMappings",
                "identitiesMappings"
                ];

                // We'll gather them into a single array in memory
                let allAssetMappings = [];
                for (const storeName of storeNames) {
                // If these object stores exist, fetch everything
                if (db.objectStoreNames.contains(storeName)) {
                    const storeData = await getAllFromStore(db, storeName);
                    allAssetMappings = allAssetMappings.concat(storeData);
                }
                }

                // 2. Group assetTypeMappings by capability_id (e.g. "Linux Server OS").
                //    We'll create a dictionary: { "Linux Server OS": [ {capability_id..., attack_object_id..., ...}, ... ] }
                const groupedByAssetType = {};
                for (const entry of allAssetMappings) {
                const assetTypeName = entry.capability_id;    // e.g. "Linux Server OS"
                const assetCategory = entry.capability_group; // e.g. "devices"

                if (!groupedByAssetType[assetTypeName]) {
                    groupedByAssetType[assetTypeName] = {
                    assetCategory,
                    entries: [] // all technique mappings referencing this asset type
                    };
                }
                groupedByAssetType[assetTypeName].entries.push(entry);
                }

                // 3. For each unique asset type, build the final object shape:
                //    {
                //       assetTypeId: "Linux Server OS",
                //       "asset-category": "devices",
                //       "asset-type": "Linux Server OS",
                //       "model-values": {},  // We'll populate in Step 2 (Add Asset Type) 
                //       "techniques": { "T1001": {...}, "T1002": {...} }
                //    }
                const contextualAssetTypes = {};

                for (const [assetTypeName, info] of Object.entries(groupedByAssetType)) {
                const assetCategory = info.assetCategory;
                // Build the skeleton object
                const assetTypeObj = {
                    assetTypeId: assetTypeName,  // our unique keyPath
                    "asset-category": assetCategory,
                    "asset-type": assetTypeName,
                    "model-values": {}, 
                    "techniques": {}
                };

                // For each technique mapping referencing this asset type
                for (const mapping of info.entries) {
                    const techniqueId   = mapping.attack_object_id;   // e.g. "T1001"
                    const techniqueName = mapping.attack_object_name; // e.g. "Data Obfuscation"

                    // Build the partial technique object
                    // We'll call a helper "buildContextualTechniqueObject(techniqueId, techniqueName)" 
                    // that merges in STIX data (data-sources, mitigations, prevEntry, etc.).
                    // Or you can do it inline. For clarity, let's just call a helper:
                    const techniqueObj = await buildContextualTechniqueObject(techniqueId, techniqueName);

                    // Add it to the assetTypeObj
                    assetTypeObj.techniques[techniqueId] = techniqueObj;
                }

                contextualAssetTypes[assetTypeName] = assetTypeObj;
                }

                // 4. Write these new objects to the "contextualizedAssetTypes" store in a single transaction
                const txWrite = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = txWrite.objectStore("contextualizedAssetTypes");

                for (const [assetTypeName, assetTypeObj] of Object.entries(contextualAssetTypes)) {
                store.put(assetTypeObj);
                }

                await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
                });

                console.log("✅ Built contextual asset types and stored in 'contextualizedAssetTypes'.");
                return contextualAssetTypes;

            } catch (error) {
                console.error("Error in buildContextualAssetTypes:", error);
                return {};
            }
        }

        

        /*
        * IMPORTANT - Needs to be updated to use Dexie.js and new shuffledb schema
         * Called when the user clicks "Add Asset Type" in Step 2,
         * after selecting environment, coverage, record count, etc.
         * This attaches "model-values" to the relevant record in "contextualizedAssetTypes".
         * 
         * @param {string} assetTypeName  e.g. "Linux Server OS"
         * @param {string} environment    e.g. "AWS"
         * @param {Object} coverageObj    e.g. { "network-monitoring": "High", ...}
         * @param {number} [recordCount]  e.g. 1000 (if user selected it, and assetCategory === "data")
         */
        async function updateModelValuesForAssetType(assetTypeName, environment, coverageObj, recordCount) {
            try {
                const db = await initIndexedDB();
                const tx = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = tx.objectStore("contextualizedAssetTypes");

                // 1. Retrieve the existing assetType record by key. The keyPath is "assetTypeId" (the name).
                const existingRecord = await new Promise((resolve, reject) => {
                const req = store.get(assetTypeName);
                req.onsuccess = () => resolve(req.result);
                req.onerror   = () => reject(req.error);
                });

                if (!existingRecord) {
                console.warn(`No record found for assetTypeId: ${assetTypeName}`);
                return;
                }

                // 2. Attach/update the "model-values"
                existingRecord["model-values"] = {
                environment,
                "monitoring-coverage": coverageObj || {}
                };
                if (recordCount != null) {
                existingRecord["model-values"]["record-count"] = recordCount;
                }

                // 3. Write it back to the store
                store.put(existingRecord);

                await new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror    = () => reject(tx.error);
                });

                console.log(`✅ Updated model-values for assetTypeId: ${assetTypeName}`);
            } catch (error) {
                console.error("Error in updateModelValuesForAssetType:", error);
            }
        }

        /**
         * Top-level function to iterate through the files array, fetch each JSON,
         * parse, and import into the specified Dexie store. It also logs progress
         * messages to the "loading-logs" element.
         *
         * @param {Dexie} db        - The Dexie database instance.
         * @param {Array} filesArr  - The array of file metadata objects.
         *    e.g. { file, format, store, record_type, import_from }
         */
         async function importAllJsonFiles(db, filesArr) {
            for (const fileDef of filesArr) {
                await importSingleJsonFile(db, fileDef);
            }
        }

        async function runInitializationSequence(db) {
            // Show the progress bar
            document.getElementById("progress-container").style.display = "block";

            // For example, if you have 5 main tasks:
            const totalSteps = 6;
            let currentStep = 0;

            // Function to update progress visually
            function updateProgress(logMessage) {
                currentStep++;
                const progressPercent = (currentStep / totalSteps) * 100;
                document.getElementById("progress-bar").style.width = progressPercent + "%";

                // Append the log
                const logsDiv = document.getElementById("loading-logs");
                const newLogLine = document.createElement("div");
                newLogLine.textContent = `(${currentStep}/${totalSteps}) ${logMessage}`;
                logsDiv.appendChild(newLogLine);
            }

            // 1) Initialize Dexie
            await initShuffleDb(db);
            updateProgress("shuffledb initialized.");

            // 2) Import staticVariables
            await importAllJsonFiles(db, filesArr);
            updateProgress("imported json files.");

            // 3) Import capabilities
            // await importRecords("capabilities");
            // updateProgress("capabilities imported.");

            // 4) Import attack store
            // await importRecords("attack");
            // updateProgress("attack data imported.");

            // 5) Create “techniques” store records
            await createAllTechniques(db);
            updateProgress("techniques store records created.");

            // populate environment dropdown
            populateEnvironmentSelection();
            updateProgress("Environment selections populated.");

            // populate record count dropdown
            populateRecordCountSelection();
            updateProgress("Record count selections populated.");

            //populate monitoring coverage radio sets
            populateMonitoringCoverageSelections();
            updateProgress("Monitoring coverage selections populated.");

            // All done: reveal the Next button
            document.getElementById("initialNextBtn").classList.remove("hidden");
            // Optional: hide the progress bar, or leave it fully at 100%
        }

    </script>
         
  
</body>

</html>
