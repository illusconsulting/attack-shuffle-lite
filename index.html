<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Breach Cost Estimator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.js" integrity="sha512-+k1pnlgt4F1H8L7t3z95o3/KO+o78INEcXTbnoJQ/F2VqDVhWoaiVml/OEHv9HsVgxUaVW+IbiZPUJQfF/YxZw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js" integrity="sha512-OIkF2zyWS+sUanhT2i75RexNDQ2EKHayyeOxBx4Z4ct0D+dlPzZPhHTi7xZ5eU7aznNLMX7pCZyZVSi25+EGMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/4.0.10/dexie.min.js" integrity="sha512-jF+6XYwL495BDSom6h9X0w5EvtDrXfevVM17XSnhXHxP/iwallbjIo4TPbGltrj/gkCN4qde+S/HjiF8J5ATKQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <style>
        /* Dark mode by default */
        body.dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .dark .bg-white { background-color: #2d3748 !important; }
        .dark .text-black { color: #e2e8f0 !important; }
        .dark .bg-gray-100 { background-color: #1a202c !important; }
        .dark .border-gray-300 { border-color: #4a5568 !important; }
    
        /* Progress Bar */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .progress-bar li {
            list-style: none;
            width: 100%;
            text-align: center;
            position: relative;
            font-weight: bold;
            color: gray;
        }
        .progress-bar li:before {
            content: attr(data-step);
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: gray;
            color: white;
        }
        .progress-bar li.active {
            color: #3490dc;
        }
        .progress-bar li.active:before {
            background-color: #3490dc;
        }
    
        /* Hide all form steps by default */
        .form-step {
            display: none;
        }
    
        /* Only display the form-step that has the 'active' class */
        .form-step.active {
            display: block;
        }
    
        /* Styling for asset selection */
        #asset-category-container label {
            display: block;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
        }
        #asset-category-container input[type="radio"] {
            display: none;
        }
        #asset-category-container input[type="radio"]:checked + label {
            background-color: #3490dc;
            color: white;
            border-color: #3490dc;
        }
    
        /* Styling for form fields */
        select, input[type="text"], input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #ddd;
            padding: 8px;
            width: 100%;
            border-radius: 5px;
        }
    
        /* Button styles */
        button {
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
        }
        .btn-primary {
            background-color: #3490dc;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #38a169;
            color: white;
        }
        .btn-danger {
            background-color: #e3342f;
            color: white;
        }
        .btn-primary:hover { background-color: #2779bd; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success:hover { background-color: #2f855a; }
        .btn-danger:hover { background-color: #cc1f1a; }
    
        /* JSON Output */
        #json-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f7fafc;
            color: black;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        /* JSON Styling */
        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
        }
        #progress-container {
            display: none;
        }

        #radial-tree-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            position: relative;
        }

    </style>
    
</head>
<body class="dark flex justify-center items-center min-h-screen">
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed bottom-5 right-5 space-y-2 z-50"></div>
    <!-- Main Form Container -->
    <div class="bg-white shadow-md rounded-lg p-6 w-full max-w-2xl">
            <!-- Progress Bar -->
            <div id="progress-container" class="w-full bg-gray-300 rounded mt-4 hidden">
                <div id="loading-progress-bar" class="h-4 bg-blue-500 rounded w-0 hidden"></div>
            </div>
        <div class="flex justify-between items-center">
            <h2 class="text-xl font-bold">Data Breach Cost Estimator</h2>
            <button id="darkModeToggle" class="px-3 py-1 text-sm bg-gray-700 text-white rounded">
                <span id="darkModeIcon" class="material-symbols-outlined">dark_mode</span>
            </button>            
        </div>

        <!-- Progress Bar -->
        <ol class="progress-bar flex">
            <li data-step="1" class="active">Initializing</li>
            <li data-step="2">Asset Types</li>
            <li data-step="3">MITRE ATT&CK Inventory</li>
            <li data-step="4">ATT&CK Technique Visualization</li>
            <li data-step="5">Organization Details</li>
        </ol>  

        <div id="form-navigation" class="flex justify-between mt-4">
            <button type="button" id="prev-step" class="hidden bg-gray-500 text-white px-4 py-2 rounded">Back</button>
            <button type="button" id="next-step" class="bg-blue-500 text-white px-4 py-2 rounded hidden">Next</button>
        </div>

        <form id="multiStepForm">
            <!-- Step 1: Initializing -->
            <div class="form-step active">
                <h3 class="text-lg font-semibold mb-2">Initializing</h3>
                <div id="loading-logs" class="text-sm text-gray-400 h-32 overflow-auto border p-2 rounded mt-2">
                <!-- As data loads, you append or stream logs here. -->
                </div>
                <div class="mt-2 text-right">
                <!-- On completion, show the Next button. Hide it by default. -->
                </div>
            </div>
            
            <!-- Step 2: Asset Types -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Define Asset Types</h3>
                <p class="text-sm text-gray-600 mb-2">Select an asset category to continue.</p>

                <!-- Asset Category Selection -->
                <div id="asset-category-container">
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Devices" class="mr-2"> Devices
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Networks" class="mr-2"> Networks
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Applications & Workloads" class="mr-2"> Applications & Workloads
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Data" class="mr-2"> Data
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Identities" class="mr-2"> Identities
                    </label>
                </div>

                <!-- Asset Type Selection -->
                <label class="block mt-2">Select Asset Type:
                    <select id="asset-type-dropdown" class="border p-2 w-full" disabled>
                        <option value="">Select an asset category first</option>
                    </select>
                </label>

                <!-- Environment Selection -->
                <div id="environment-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Environment:
                        <select id="environment-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Record Count Selection (Only for Data) -->
                <div id="record-count-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Estimated Record Count:
                        <select id="record-count-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Monitoring Coverage Selection -->
                <div id="monitoring-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Monitoring Coverage:</label>
                    <div id="network-monitoring" data-label="Network Monitoring"></div>
                    <div id="process-monitoring" data-label="Process Monitoring"></div>
                    <div id="file-monitoring" data-label="File Monitoring"></div>
                    <div id="cloud-monitoring" data-label="Cloud Monitoring"></div>
                    <div id="hardware-monitoring" data-label="Hardware Monitoring"></div>
                </div>
                
                <!-- Submit Asset Type -->
                <button type="button" id="submit-asset-type" class="bg-green-500 text-white px-4 py-2 rounded mt-4" style="display: block;">
                    Add Asset Type
                </button>
                <!-- Display Model Definition in JSON -->
                <button type="button" id="view-model-definition" class="bg-gray-700 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    View Model JSON
                </button>

                <!-- Table listing the existing modelInstances asset-type records -->
                <div class="mt-6">
                    <h4 class="text-md font-semibold">Current Asset Instances</h4>
                    <table id="asset-type-instances-table" class="w-full border-collapse border border-gray-300 text-sm mt-2">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                        <th class="border border-gray-300 px-4 py-2">Environment</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                        <th class="border border-gray-300 px-4 py-2">Monitoring Coverage</th>
                        <th class="border border-gray-300 px-4 py-2">Record Count</th>
                        <!-- You can add more columns if needed -->
                        </tr>
                    </thead>
                    <tbody id="asset-type-instances-body"></tbody>
                    </table>
                </div>
            </div>

            <!-- Step 3: Technique Scoring -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">MITRE ATT&CK Techniques Inventory</h3>
                <p class="text-sm text-gray-600 mb-4">Review the MITRE ATT&CK techniques relevant to each asset type.</p>
            
                <!-- Summary Table -->
                <table id="model-summary-table" class="w-full border-collapse border border-gray-300 text-sm">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                            <th class="border border-gray-300 px-4 py-2">Environment</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                            <th class="border border-gray-300 px-4 py-2">Count of MITRE ATT&CK Techniques</th>
                        </tr>
                    </thead>
                    <tbody id="model-summary-body"></tbody>
                </table>
            
                <!-- Techniques Table Container -->
                <div id="techniques-container" class="hidden mt-6">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-semibold">Techniques for <span id="selected-asset-type"></span></h4>
                        <button id="toggle-techniques-btn" type="button" bg-gray-600 text-white px-3 py-1 rounded">
                            Hide Techniques
                        </button>
                    </div>

                    <table id="techniques-table" class="w-full border-collapse border border-gray-300 text-sm">
                        <thead>
                            <tr class="bg-gray-700 text-white">
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique ID</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique Name</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Score</th>
                            </tr>
                        </thead>
                        <tbody id="techniques-body"></tbody>
                    </table>
                </div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>

            </div>

            <!-- Step 4: Radial Tree Visualization -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">ATT&CK Technique Visualization</h3>
                <p class="text-sm text-gray-600 mb-4">Select a category to visualize:</p>

                <!-- Radio Button Selection for Correlation Type -->
                <div id="visualization-selection" class="mb-4">
                    <!-- commenting out detections for now until we add detections to technique obj -->
                    <!-- <label><input type="radio" name="visualization-type" value="detections" checked> ATT&CK Detections</label> -->
                    <label><input type="radio" name="visualization-type" value="mitigations"> ATT&CK Mitigations</label>
                    <label><input type="radio" name="visualization-type" value="nist-controls" checked> NIST Controls</label>
                    <label><input type="radio" name="visualization-type" value="cis-safeguards"> CIS Safeguards</label>
                    <label><input type="radio" name="visualization-type" value="aws-capabilities"> AWS Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="gcp-capabilities"> GCP Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="azure-capabilities"> Azure Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="m365-capabilities"> M365 Capabilities</label>
                </div>

                <!-- Radial Tree Visualization Container -->
                <div id="radial-tree-container" class="w-full h-96 border border-gray-300 rounded bg-white"></div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>
            </div>

            <!-- Step 5: Organization Details -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Organization Details</h3>
                <p class="text-sm text-gray-600 mb-2">Define your organization's security practices.</p>

                <div id="organization-details">
                    <label class="block mt-2">
                        <input type="checkbox" id="ai_automation" class="mr-2">
                        AI & Automation for Information Security
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_security_staff" class="mr-2">
                        Cybersecurity Training for Security Staff
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_all_employees" class="mr-2">
                        Cybersecurity Training for All Employees
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="incident_response_testing" class="mr-2">
                        Conduct Incident Response Tests
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="law_enforcement_ransomware" class="mr-2">
                        Engage Law Enforcement for Ransomware
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="data_encryption" class="mr-2">
                        Encrypt Stored Data (Beyond Disk Encryption)
                    </label>
                </div>
            </div>

        </form>

        <!-- JSON Output -->
        <pre id="json-output" class="bg-gray-100 text-black p-4 rounded mt-4" style="display: none;"></pre>
    </div>
    <script>

        // Target JSON structure for modelInstances asset-type-instances:
        // {
        //     "asset-category": "devices", // user input, radio button selection enum is the unique array of values from capabilities.capability_group where capabilities.type = "asset-type"
        //     "asset-type": "Linux Server OS", // user input, drop-down selection enum is the unique array of values from capabilities.capability_id where capabilities.type = "asset-type"
        //     "environment": "AWS", // from user input, enum ["AWS", "GCP", "Azure", "M365"]
        //     "record-count": "500-2k", // "record-count" is only present if "asset-category" is "data", from user drop-down selection; enum ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"]
        //     "monitoring-coverage": { // from user input, enum ["None", "Low", "Medium", "High"]
        //         "network-monitoring": "High",
        //         "process-monitoring": "Medium",
        //         "file-monitoring": "Low",
        //         "cloud-monitoring": "None",
        //         "hardware-monitoring": "None"
        //     },
            // "abusedByTechniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "abused-by"
            //     "T1001": { // from capabilities.[].attack_object_id where capabilities.[].capability_id = asset-type for this record, capabilities.[].record_type = "asset-type" and capabilities.[].mapping_type = "abused-by"
            //         "technique_name": "Data Obfuscation", // from attack store
            //         "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
            //         "data-sources": [], // from the attack store
            //         "nist-controls": [], // from capabilities where record_type is "nist-controls"
            //         "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
            //         "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
            //         "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
            //         "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
            //         "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
            //         "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
            //         "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
            //         "attack-score": 0.5 // float to the tenthousandths; attack-score = initial-score * (1 + weightSum)
            //     }
            // },
        //     "targetedByTechniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "targeted-by"
            //     "T1002": { // one technique record per attack_object_id found in the mapex files
            //         "technique_name": "Data Compressed",
            //         "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
            //         "data-sources": [], // from the attack store
            //         "nist-controls": [], // from capabilities where record_type is "nist-controls"
            //         "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
            //         "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
            //         "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
            //         "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
            //         "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
            //         "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
            //         "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
            //         "attack-score": 0.5265 // float to the tenthousandths; attack-score = initial-score * (1 + weightSum)
            //     }
            // }
        // }
        // // from STIX, external_references.[].external_id where "type": "attack-pattern"
        // target json structure for techniques records: 
        // {
        //     "technique_id": "T1001", // one technique record per attack_object_id 
        //     "technique_name": "Data Compressed", // from "attack" store where type="attack-pattern" and external_references.[].external_id=technique_id, get name
        //     "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
        //     "data-sources": [], // from the attack store
        //     "nist-controls": [], // from capabilities where record_type is "nist-controls"
        //     "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
        //     "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
        //     "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
        //     "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
        //     "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
        //     "mitigations": [], // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
        //     "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
        //     "initial-score": 0.5 // initialScore = prevalenceScore + chokepointScore + actionabilityScore
        // }
        //
        //
        function initShuffleDb() {
            const db = new Dexie("shuffledb");
            db.version(1).stores({
                modelInstances: "++id, record_type, assetCategory, assetType, environment, monitoringCoverage, recordCount, abusedByTechniques, targetedByTechniques", // tracks all info about asset type instances selected by the user
                techniques: "++id, technique_id, technique_name, monitoring_coverage_eval, data_sources, nist_controls, cis_safeguards, aws_capabilities, gcp_capabilities, azure_capabilities, m365_capabilities, mitigations", // imported from assetType files
                capabilities: "++id, record_type, capability_group, capability_id, capability_description, mapping_type, attack_object_id, attack_object_name", // imported from MAPEX files and CIS_safeguard_to_technique.json file
                staticVariables: "++id, record_type", // imported from static-variables.json and weight-keywords.json, if from static-variables.json, record_type = "static", if from weight-keywords.json, record_type = "keyword", if from attack-prev-tid.json, record_type = "calc"
                attack: "&id, type, record_type" // imported from enterprise-attack.json "objects" array
            });
            db.open().catch((err) => {
                console.error("Failed to open db:", err);
            }); 
            return db;
        }    
        
        const filesArr = [
            { file: "static-variables.json", format: "json", store: "staticVariables", record_type: "static", import_from: "." },
            { file: "weight-keywords.json", format: "json", store: "staticVariables", record_type: "keyword", import_from: "." },
            { file: "attack-prev-tid.json", format: "json", store: "staticVariables", record_type: "calc", import_from: "." },
            { file: "enterprise-attack.json", format: "stix", store: "attack", record_type: "attack_objects", import_from: "objects" },
            { file: "cis_safeguard_to_techniques.json", format: "json", store: "capabilities", record_type: "cis_safeguards", import_from: "." },
            { file: "enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects"},
            { file: "enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "nist_800_53-rev5_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "nist_controls", import_from: "mapping_objects" },
            { file: "m365-12.11.2023_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "m365_capabilities", import_from: "mapping_objects" },
            { file: "gcp-06.28.2022_attack-10.0-enterprise.json", format: "mapex", store: "capabilities", record_type: "gcp_capabilities", import_from: "mapping_objects" },
            { file: "azure-06.29.2021_attack-8.2-enterprise.json", format: "mapex", store: "capabilities", record_type: "azure_capabilities", import_from: "mapping_objects" },
            { file: "aws-12.12.2024_attack-16.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "aws_capabilities", import_from: "mapping_objects" }
        ];

        /**
         * Fetches a single JSON file, extracts the relevant data, sets the record_type,
         * and bulk puts them into the specified store. Logs start and finish messages.
         *
         * @param {Dexie} db      - The Dexie database instance.
         * @param {Object} fileDef  - An object describing how to import the file.
         *    @property {string} file         - The file name to fetch (e.g. "static-variables.json")
         *    @property {string} format       - The file format (e.g. "json", "stix", "mapex")
         *    @property {string} store        - The Dexie store name (e.g. "staticVariables")
         *    @property {string} record_type  - The record_type to inject into each object
         *    @property {string} import_from  - The property name in the JSON (".", "objects", "mapping_objects")
         */
        async function importSingleJsonFile(db, fileDef) {
        try {
            // Log start
            console.log(`Starting import: ${fileDef.file}`);
            addLogMessage(`Starting import: ${fileDef.file}`);

            // 1) Fetch the JSON
            const response = await fetch(fileDef.file);
            if (!response.ok) {
            throw new Error(`Failed to fetch ${fileDef.file}: ${response.statusText}`);
            }
            let data = await response.json();

            // 2) Based on import_from, extract the array of objects we want to import
            let recordsToImport = [];
            if (fileDef.import_from === ".") {
            // Could be an array or object at the root
            if (Array.isArray(data)) {
                recordsToImport = data;
            } else if (typeof data === "object") {
                // If the data is an object, you might push it as a single record,
                // or handle however your format requires. Example:
                recordsToImport = [data];
            }
            } else {
            // e.g. "objects", "mapping_objects"
            if (!data[fileDef.import_from]) {
                console.warn(`Property "${fileDef.import_from}" not found in ${fileDef.file}`);
                recordsToImport = [];
            } else {
                // if data[fileDef.import_from] is an array, use it directly
                // if it’s an object, put that in an array, etc.
                const subData = data[fileDef.import_from];
                recordsToImport = Array.isArray(subData) ? subData : [subData];
            }
            }

            // 3) If format is "mapex" or "stix", you might do additional parsing
            //    For example, STIX might store an array in "objects".
            //    But in this example, we rely purely on import_from to find the array
            //    so you can simply rely on the logic above.

            // 4) For each object, inject the record_type from fileDef.
            recordsToImport.forEach(obj => {
            obj.record_type = fileDef.record_type;
            });

            // 5) Bulk put into the specified store.
            //    Dexie’s .bulkPut() will handle either an empty array or large arrays.
            if (recordsToImport.length > 0) {
            await db[fileDef.store].bulkPut(recordsToImport);
            }

            // Log finish, show how many objects were imported
            console.log(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);
            addLogMessage(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);

        } catch (err) {
            console.error(`Error importing ${fileDef.file}:`, err);
            addLogMessage(`Error importing ${fileDef.file}: ${err.message}`);
        }
        }

        /**
         * Utility function to append messages to the #loading-logs element on the page.
         *
         * @param {string} message - The log message to display.
         */
        function addLogMessage(message) {
        const logsEl = document.getElementById("loading-logs");
        if (!logsEl) {
            console.warn("No element with id='loading-logs' found.");
            return;
        }
        const newLine = document.createElement("div");
        newLine.textContent = message;
        logsEl.prepend(newLine);
        }


        // Run the function when the page loads
        document.addEventListener("DOMContentLoaded", async () => {
            const db = initShuffleDb();
            await runInitializationSequence(db)
            showStep(0);

            // set dark mode
            // const savedMode = await getObjectById(db, "settings", "darkMode");
            // if (savedMode) {
            // document.body.classList.toggle("dark", savedMode.value === "dark");
            // }

            // // populate environment dropdown
            // populateEnvironmentSelection();

            // // populate record count dropdown
            // populateRecordCountSelection();

            // //populate monitoring coverage radio sets
            // populateMonitoringCoverageSelections();

            // set event listeners
            // Listen for user selecting an asset category radio button
            document.querySelectorAll("#asset-category-container input[type='radio']")
            .forEach(radio => {
                radio.addEventListener("change", async (e) => {
                    const selectedCategory = e.target.value; // e.g. "devices", "data"
                    // If you have db loaded, call:
                    await populateAssetTypeDropdown(db, selectedCategory);

                    // Optionally show/hide record count selection if category="data"
                    const recordCountDiv = document.getElementById("record-count-selection");
                    if (selectedCategory === "data") {
                    recordCountDiv.style.display = "block";
                    } else {
                    recordCountDiv.style.display = "none";
                    }

                    // You can also show environment-selection and monitoring-selection by default
                    document.getElementById("environment-selection").style.display = "block";
                    document.getElementById("monitoring-selection").style.display = "block";
                });
            });
            // listen for user to select a different visualization-type for radial tree diagram
            document.querySelectorAll('input[name="visualization-type"]').forEach(radio => {
                radio.addEventListener("change", () => {
                    generateRadialTree();
                });
            });
        });
    
        /**
         * getObjectById
         * 
         * Retrieves a single record from the specified Dexie store by its primary key.
         * In the example call, we do: getObjectById("settings", "darkMode"),
         * which looks up the record in the "settings" store with key="darkMode".
         *
         * @param {string} storeName - The name of the IndexedDB store, e.g. "settings".
         * @param {string} objectId  - The primary key to retrieve, e.g. "darkMode".
         * @returns {Promise<Object|null>} The matching record, or null if not found.
         */
        async function getObjectById(db, storeName, objectId) {
        try {
            // If you have a global 'db' already initialized, use that.
            // Otherwise, call initShuffleDb() here or pass the db as a parameter.
            return await db[storeName].get(objectId);
        } catch (error) {
            console.error(`Error in getObjectById(${storeName}, ${objectId}):`, error);
            return null;
        }
        }


        /*******************************************************
         * 1. Populate Asset Type Dropdown
         * 
         * - Queries Dexie capabilities store for records:
         *    record_type="asset-types" and capability_group = selectedCategory
         * - Fills the <select id="asset-type-dropdown"> with options.
         * - If none found, leaves a placeholder option.
         *******************************************************/
        async function populateAssetTypeDropdown(db, selectedCategory) {
        const assetTypeDropdown = document.getElementById("asset-type-dropdown");
        if (!assetTypeDropdown) return;

        // Clear existing options
        assetTypeDropdown.innerHTML = "";

        // If no category is selected, disable and show placeholder
        if (!selectedCategory) {
            assetTypeDropdown.disabled = true;
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select an asset category first";
            assetTypeDropdown.appendChild(placeholder);
            return;
        }

        // Query Dexie for asset-type records
        const entries = await db.capabilities
            .where("record_type").equals("asset_types")
            .and(c => c.capability_group === selectedCategory)
            .toArray();

        // If we found none, show a “No Asset Types Available” option
        if (!entries.length) {
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = `No asset types found for ${selectedCategory}`;
            assetTypeDropdown.appendChild(placeholder);
            assetTypeDropdown.disabled = true;
            return;
        }

        // Otherwise populate
        assetTypeDropdown.disabled = false;
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select an asset type";
        assetTypeDropdown.appendChild(placeholder);

        // Each entry’s capability_id is the name
        // Some categories might have duplicates, so we can deduplicate in a Set
        const seen = new Set();
        entries.forEach(entry => {
            if (entry.capability_id && !seen.has(entry.capability_id)) {
            seen.add(entry.capability_id);
            const opt = document.createElement("option");
            opt.value = entry.capability_id;
            opt.textContent = entry.capability_id;
            assetTypeDropdown.appendChild(opt);
            }
        });
        }

        /*******************************************************
         * 2. Populate Environment Dropdown
         * 
         * Populates <select id="environment-dropdown"> with:
         *   "AWS", "Azure", "GCP", "M365"
         *******************************************************/
        function populateEnvironmentSelection() {
        const envDropdown = document.getElementById("environment-dropdown");
        if (!envDropdown) return;

        envDropdown.innerHTML = "";
        const environments = ["AWS", "Azure", "GCP", "M365"];
        environments.forEach(env => {
            const opt = document.createElement("option");
            opt.value = env;
            opt.textContent = env;
            envDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 3. Populate Record Count Selection
         * 
         * Populates <select id="record-count-dropdown"> with:
         *   "<500", "500-2k", "2k-10k", "10k-100k", ">100k"
         * 
         * Only displayed if the selected asset category = "data"
         *******************************************************/
        function populateRecordCountSelection() {
        const recordCountDropdown = document.getElementById("record-count-dropdown");
        if (!recordCountDropdown) return;

        recordCountDropdown.innerHTML = "";
        const recordCounts = ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"];
        recordCounts.forEach(count => {
            const opt = document.createElement("option");
            opt.value = count;
            opt.textContent = count;
            recordCountDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 4. Populate Monitoring Coverage Selections
         * 
         * For each of:
         *   #network-monitoring
         *   #process-monitoring
         *   #file-monitoring
         *   #cloud-monitoring
         *   #hardware-monitoring
         * Provide a set of radio buttons (or a <select>) for:
         *   "High", "Medium", "Low", "None"
         *******************************************************/
        function populateMonitoringCoverageSelections() {
        const coverageLevels = ["High", "Medium", "Low", "None"];

        // Helper to build radio group or dropdown inside a container
        function buildCoverageRadios(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ""; // clear existing

            const labelText = container.dataset.label || containerId;
            const labelEl = document.createElement("div");
            labelEl.classList.add("font-semibold", "mb-1");
            labelEl.textContent = labelText;
            container.appendChild(labelEl);

            coverageLevels.forEach(level => {
            const wrapper = document.createElement("label");
            wrapper.classList.add("inline-flex", "items-center", "mr-3");

            const input = document.createElement("input");
            input.type = "radio";
            input.name = containerId; // so all are in one group
            input.value = level;
            input.classList.add("mr-1");

            wrapper.appendChild(input);
            wrapper.appendChild(document.createTextNode(level));
            container.appendChild(wrapper);
            });
        }

        // Build coverage for each ID
        buildCoverageRadios("network-monitoring");
        buildCoverageRadios("process-monitoring");
        buildCoverageRadios("file-monitoring");
        buildCoverageRadios("cloud-monitoring");
        buildCoverageRadios("hardware-monitoring");
        }

        // re‑render the AssetTypeInstancesTable in Step 2 each time you insert a new asset‑type‑instance record into modelInstances store
        async function refreshAssetTypeInstancesTable(db) {
            const tableBody = document.getElementById("asset-type-instances-body");
            tableBody.innerHTML = "";

            // Get all asset-type-instance records from Dexie
            const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray(); 
                // Or adapt if you’re labeling them differently
            console.log("refreshAssetTypeInstancesTable allInstances:", allInstances)
            allInstances.forEach(instance => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                <td class="border border-gray-300 px-4 py-2">${instance.environment || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-category"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-type"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">
                    ${JSON.stringify(instance["monitoring-coverage"] || {})}
                </td>
                <td class="border border-gray-300 px-4 py-2">${instance["record-count"] || ""}</td>
                `;
                tableBody.appendChild(tr);
            });
        }

    


        // Function to Handle Navigation Between Steps
        let currentStep = 0;
        const steps = document.querySelectorAll(".form-step");
        const nextButton = document.getElementById("next-step");
        const prevButton = document.getElementById("prev-step");
        const progressItems = document.querySelectorAll(".progress-bar li");

        // Function to update steps
        function showStep(step) {
            // Hide all steps and remove active class
            steps.forEach((el, index) => {
                el.classList.toggle("active", index === step);
                el.style.display = index === step ? "block" : "none";
            });

            // Update progress bar
            progressItems.forEach((el, index) => {
                el.classList.toggle("active", index === step);
            });

            // Hide back button on first step
            prevButton.classList.toggle("hidden", step === 0);

            // Change "Next" button to "Finish" on the last step
            nextButton.innerText = step === steps.length - 1 ? "Finish" : "Next";
        }

        // Function to Hide the Techniques Table and JSON Output
        function hideDynamicElements() {
            document.getElementById("techniques-container").classList.add("hidden");
            document.getElementById("json-output").style.display = "none";
        }

        // Next Button Click Event
        nextButton.addEventListener("click", async () => {
            const db = await initShuffleDb();
            const modelDefinition = {
                organization_attributes: {}
            };
            if (currentStep < steps.length - 1) {
                
                if (currentStep === 0) {
                    
                }
                if (currentStep === 1) {
                    // ✅ Only recalculate if scores do not exist
                    // const scoresExist = modelDefinition.asset_types.some(asset => asset.attack_scores?.length > 0);
                    // if (!scoresExist) {
                    //     await calculateAllTechniqueScores();
                    // }
                    //updateModelDisplay();
                    generateModelSummaryTable(db);
                }
                if (currentStep === 2) {
                    // ✅ Wait for JSON files to be fully loaded before updating model
                    // if (!jsonCache.nistMapping || !jsonCache.enterpriseAttack) {
                    //     console.error("❌ Error: Required JSON files not loaded.");
                    //     showToast("Error: Required JSON files not loaded.", "error");
                    //     return;
                    // }
                    generateRadialTree();
                }
                if (currentStep === 4) {
                    buildOrganizationAttributes(modelDefinition);
                }

                currentStep++;
                showStep(currentStep);
                hideDynamicElements();
            } else {
                alert("Form Submitted!"); // Replace this with actual form submission logic
            }
        });

        // Back Button Click Event
        prevButton.addEventListener("click", () => {
            if (currentStep > 0) {
                currentStep--;
                showStep(currentStep);
                hideDynamicElements();
                updateModelDisplay(); 
            }
        });
   
        // Dark Mode Toggle
        async function toggleDarkMode() {
            const body = document.body;
            body.classList.toggle("dark");
            const mode = body.classList.contains("dark") ? "dark" : "light";
            await storeObject("settings", { key: "darkMode", value: mode });
        }

        // function to build json representation of model with selected asset-type-instance records and users' responses to organizational attributes
        async function buildModelJson() {

        }
    
        // JSON Export & Download
        async function exportModelAsJSON() {
            const techniques = await getAllObjects("techniques");
            const blob = new Blob([JSON.stringify(techniques, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "model-data.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    
        document.getElementById("download-json").addEventListener("click", exportModelAsJSON);

        // Function to Build Organization Attributes from Checkboxes
        function buildOrganizationAttributes(modelDefinition) {
            document.querySelectorAll("#organization-details input[type='checkbox']").forEach(input => {
                modelDefinition.organization_attributes[input.id] = input.checked;  // ✅ Ensure proper assignment
            });

            // console.log("Saved Organization Attributes:", modelDefinition.organization_attributes);
        }

        // Function to Update and Display Model Definition JSON
        function updateModelDisplay() {
            const jsonOutput = document.getElementById("json-output");
            jsonOutput.textContent = JSON.stringify(modelDefinition, null, 4);
        }
    
        document.getElementById("view-model-definition").addEventListener("click", () => {
            const jsonOutput = document.getElementById("json-output");

            // Toggle visibility
            if (jsonOutput.style.display === "none" || jsonOutput.style.display === "") {
                jsonOutput.style.display = "block";  // Show JSON
            } else {
                jsonOutput.style.display = "none";   // Hide JSON
            }
        });

        // Function to generate a table showing the asset-type-instance records and the average ATT&CK score for each
        async function generateModelSummaryTable(db) {
            const tableBody = document.getElementById("model-summary-body");
            tableBody.innerHTML = "";

            // 1) Query Dexie for all asset-type-instance records
            const allAssetInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray();

            // 2) Loop through each asset and compute summary
            for (const asset of allAssetInstances) {
                // Assume the attack scores are stored in a property "attack_scores"
                // Adjust if you store them differently (e.g. "abused-by-techniques")
                const abusedArr = asset.abusedByTechniques
                    ? Object.values(asset.abusedByTechniques)
                    : [];

                    // Similarly for targetedByTechniques
                    const targetedArr = asset.targetedByTechniques
                    ? Object.values(asset.targetedByTechniques)
                    : [];
                const techniques = [...abusedArr, ...targetedArr] || [];
                // console.log("techniques array: ", techniques)

                const avgScore = techniques.length
                    ? (
                        techniques.reduce((sum, t) => sum + parseFloat(t["attack-score"] || 0), 0) / techniques.length
                    ).toFixed(4)
                    : "N/A";

                // 3) Create row
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${asset.environment || ""}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset["asset-category"] || ""}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset["asset-type"] || ""}</td>
                    <td class="border border-gray-300 px-4 py-2 text-blue-500 cursor-pointer">
                        ${techniques.length} techniques (Avg Score: ${avgScore})
                    </td>
                `;

                // 4) Pass asset type name (or ID) into your detail function
                row.querySelector("td:last-child").addEventListener("click", () => {
                    displayTechniquesTable(asset["asset-type"]);
                });

                tableBody.appendChild(row);
            }
        }



        // function to create a table showing the ATT&CK techniques for a given asset type and the ATT&CK score for each technique
        async function displayTechniquesTable(assetTypeName) {
            const db = await initShuffleDb();
            const tableBody = document.getElementById("techniques-body");
            tableBody.innerHTML = "";

            document.getElementById("selected-asset-type").textContent = assetTypeName;
            document.getElementById("techniques-container").classList.remove("hidden");

            // 1) Fetch this asset-instance from Dexie
            const assetRecord = await db.modelInstances
                .where("record_type").equals("asset-type-instance")
                .and(x => x["asset-type"] === assetTypeName)
                .first(); // or .toArray() if you expect multiple

            if (!assetRecord) {
                console.error(`No asset instance found for asset-type '${assetTypeName}' in Dexie.`);
                return;
            }

            // 2) Extract technique data
            const abusedByTechniques = assetRecord.abusedByTechniques 
                ? Object.entries(assetRecord.abusedByTechniques)
                : [];
            const targetedByTechniques = assetRecord.targetedByTechniques
            ? Object.entries(assetRecord.targetedByTechniques)
            : [];            
            const techniques = [...abusedByTechniques, ...targetedByTechniques]

            // // Getting the technique key (e.g., "T1002")
            // const techniqueId = Object.keys(techniques)[0]; // "T1002"

            // // Getting the values inside the object
            // const techniqueDetails = techniques[techniqueId];

            // // Extracting specific values
            // const techniqueName = techniqueDetails["technique_name"]; // "Data Compressed"
            // const attackScore = techniqueDetails["attack-score"]; // 0.5265

            // 3) Build table rows
            // for (const [techniqueId, details] of Object.entries(techniques)) {
                for (const [techniqueId, details] of techniques) {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${techniqueId}</td>
                    <td class="border border-gray-300 px-4 py-2">${details["technique_name"]}</td>
                    <td class="border border-gray-300 px-4 py-2">${details["attack-score"]}</td>
                `;
                tableBody.appendChild(row);
            };
        }


        function getCoverageValue(id) {
            // This grabs the checked radio button in the container with `id`
            const checkedRadio = document.querySelector(`#${id} input[type="radio"]:checked`);
            // If none is checked, default to "" or "None"
            return checkedRadio ? checkedRadio.value : "None";
        }

        document.getElementById("submit-asset-type").addEventListener("click", async () => {
            const assetTypeName = document.getElementById("asset-type-dropdown").value;
            const environment   = document.getElementById("environment-dropdown").value;
            const selectedCategory = document.querySelector('input[name="asset-category"]:checked').value;
            const selectedNetworkCoverage   = getCoverageValue("network-monitoring");
            const selectedProcessCoverage   = getCoverageValue("process-monitoring");
            const selectedFileCoverage      = getCoverageValue("file-monitoring");
            const selectedCloudCoverage     = getCoverageValue("cloud-monitoring");
            const selectedHardwareCoverage  = getCoverageValue("hardware-monitoring");

            //console.log("getCoverageValue:", assetTypeName, environment, selectedCategory, selectedProcessCoverage, selectedFileCoverage, selectedNetworkCoverage, selectedHardwareCoverage)
            
            // gather monitoring coverage inputs, e.g.:
            const coverage = {
                "network-monitoring": selectedNetworkCoverage,
                "process-monitoring": selectedProcessCoverage,
                "file-monitoring": selectedFileCoverage,
                "cloud-monitoring": selectedCloudCoverage,
                "hardware-monitoring": selectedHardwareCoverage
            };
            let recordCount;
            if (selectedCategory === "Data") {
                recordCount = parseInt(document.getElementById("record-count-dropdown").value, 100);
            }

            await updateModelValuesForAssetType(selectedCategory, assetTypeName, environment, coverage, recordCount);
            // Possibly show a success message or move to the next step.
        });

        /**
         * buildInMemoryCaches
         *
         * Fetches and stores large collections of STIX objects, relationships,
         * capabilities, and staticVariables in memory. This approach drastically
         * reduces repeated DB queries and allows parallel data retrieval.
         *
         * @param {Dexie} db - The Dexie database instance
         * @returns {Object}  An object containing caches:
         *   {
         *     allCapabilities,  // Array of all records in db.capabilities
         *     capabilityByTechnique, // Map<string, Array<object>> keyed by attack_object_id
         *     patternsMap,      // Map<string, object> keyed by techniqueId => STIX pattern object
         *     relationshipsMap, // Map<string, Array<object>> keyed by "target_ref" => array of "relationship" objects
         *     courseOfActionMap,// Map<string, object> keyed by "course-of-action" ID => STIX CoA object
         *     staticVarsAll     // Array of all staticVariables
         *     staticVarsCalc    // Map<string, object> keyed by techniqueId => the "calc" object
         *     monitoringKeywords // Array of keyword entries from staticVariables
         *   }
         */
        async function buildInMemoryCaches(db) {
        // We’ll do multiple fetches in parallel using Promise.all
        const [
            allCapabilities,
            allAttack,
            staticVarsAll
        ] = await Promise.all([
            db.capabilities.toArray(),
            db.attack.toArray(),
            db.staticVariables.toArray()
        ]);

        // 1) Build a quick lookup of capabilities by techniqueId
        //    e.g. capabilityByTechnique["T1001"] -> array of capabilities that have attack_object_id="T1001"
        const capabilityByTechnique = {};
        for (const cap of allCapabilities) {
            if (!cap.attack_object_id) continue;
            if (!capabilityByTechnique[cap.attack_object_id]) {
            capabilityByTechnique[cap.attack_object_id] = [];
            }
            capabilityByTechnique[cap.attack_object_id].push(cap);
        }

        // 2) Separate out STIX objects from the "attack" store
        //    We'll want to map:
        //      - "attack-pattern" by techniqueId
        //      - "relationship" by target_ref (for mitigations/detections)
        //      - "course-of-action" by ID
        const patternsMap = new Map();
        const relationshipsMap = new Map();  // e.g. relationshipsMap[patternId] => array of relationships
        const courseOfActionMap = new Map();

        for (const obj of allAttack) {
            if (obj.type === "attack-pattern" && Array.isArray(obj.external_references)) {
            // Find the external reference for "mitre-attack" to get the techniqueId
            const mitreRef = obj.external_references.find(r => r.source_name === "mitre-attack");
            if (mitreRef && mitreRef.external_id) {
                const techniqueId = mitreRef.external_id; // e.g. "T1001"
                patternsMap.set(techniqueId, obj);
            }
            } 
            else if (obj.type === "relationship") {
            // e.g. obj.target_ref might be "attack-pattern--abc123"
            if (!relationshipsMap.has(obj.target_ref)) {
                relationshipsMap.set(obj.target_ref, []);
            }
            relationshipsMap.get(obj.target_ref).push(obj);
            }
            else if (obj.type === "course-of-action") {
            // Store CoA in a map keyed by obj.id
            courseOfActionMap.set(obj.id, obj);
            }
        }

        // 3) Partition staticVariables by record_type
        const staticVarsCalc = {};
        const monitoringKeywords = [];
        for (const sv of staticVarsAll) {
            if (sv.record_type === "calc" && sv.attack_object_id) {
            // e.g. staticVarsCalc["T1001"] = that record
            staticVarsCalc[sv.attack_object_id] = sv;
            } else if (sv.record_type === "keyword") {
            // e.g. for coverage eval
            monitoringKeywords.push(sv);
            }
        }

        return {
            allCapabilities,
            capabilityByTechnique,
            patternsMap,
            relationshipsMap,
            courseOfActionMap,
            staticVarsAll,
            staticVarsCalc,
            monitoringKeywords
        };
        }


        /**
         * createAllTechniques
         *
         * 1) Builds in-memory caches (patterns, relationships, capabilities, etc.).
         * 2) Gathers all unique technique IDs.
         * 3) Constructs technique records in parallel.
         * 4) bulkPut() them into db.techniques.
         *
         * @param {Dexie} db
         */
        async function createAllTechniques(db) {
            updateProgress("Starting createAllTechniques...");
            
            // 1) Build caches
            const {
                capabilityByTechnique,
                patternsMap,
                relationshipsMap,
                courseOfActionMap,
                staticVarsCalc,
                monitoringKeywords
            } = await buildInMemoryCaches(db);

            // 2) Gather all unique technique IDs from the capabilities
            const uniqueTechniqueIds = gatherUniqueTechniqueIds(capabilityByTechnique);
            console.log(`Found ${uniqueTechniqueIds.length} technique IDs.`);

            // 3) Build records in parallel using Promise.all
            const buildPromises = uniqueTechniqueIds.map(techId =>
                buildTechniqueRecord(
                techId,
                patternsMap,
                relationshipsMap,
                courseOfActionMap,
                capabilityByTechnique,
                staticVarsCalc,
                monitoringKeywords
                )
            );
            const techniqueRecords = await Promise.all(buildPromises);

            // Filter out any null or undefined records
            const validRecords = techniqueRecords.filter(r => r);

            // 4) Insert them into the "techniques" store
            if (validRecords.length) {
                await db.techniques.bulkPut(validRecords);
                console.log(`Created ${validRecords.length} techniques in the techniques store.`);
            } else {
                console.log("No techniques found to create.");
            }
        }


        /**
         * gatherUniqueTechniqueIds
         *
         * Extracts all unique technique IDs (like "T1001", "T1002") from the
         * capabilityByTechnique map built in memory.
         *
         * @param {Object} capabilityByTechnique - from buildInMemoryCaches
         * @returns {Array<string>}
         */
        function gatherUniqueTechniqueIds(capabilityByTechnique) {
            // The keys of capabilityByTechnique are all technique IDs
            return Object.keys(capabilityByTechnique);
        }

        /**
         * buildTechniqueRecord
         *
         * Builds the final technique object for a single techniqueId, using
         * in-memory caches to gather the pattern object, mitigations, capabilities,
         * monitoring coverage, etc.
         *
         * @param {string} techniqueId            - e.g. "T1001"
         * @param {Map} patternsMap               - Map(techniqueId => attack-pattern object)
         * @param {Map} relationshipsMap          - Map(patternId => array of relationship objects)
         * @param {Map} courseOfActionMap         - Map(coaId => course-of-action object)
         * @param {Object} capabilityByTechnique  - { "T1001": [cap1, cap2], ... }
         * @param {Object} staticVarsCalc         - { "T1001": {calc_tid_before, calc_tid_after, calc_prev_score}, ...}
         * @param {Array} monitoringKeywords      - array of { key, value } records for coverage
         * @returns {Object|null} The final technique record, or null if no valid pattern found
         */
        async function buildTechniqueRecord(
            techniqueId,
            patternsMap,
            relationshipsMap,
            courseOfActionMap,
            capabilityByTechnique,
            staticVarsCalc,
            monitoringKeywords
            ) {
            // 1) Find the STIX pattern object for this technique
            const patternObj = patternsMap.get(techniqueId);
            if (!patternObj) {
                console.warn(`No attack-pattern found for ${techniqueId}`);
                return null;
            }

            const patternId = patternObj.id; // e.g. "attack-pattern--abc123"
            const technique_name = patternObj.name || techniqueId;
            const dataSources = patternObj.x_mitre_data_sources || [];
            const technique_url = getMitreUrlFromPattern(patternObj, techniqueId);

            // 2) Gather mitigations and detection count from the relationshipsMap
            const { mitigations, detectionCount } = gatherMitigationsAndDetections(
                patternId,
                relationshipsMap,
                courseOfActionMap
            );

            // 3) Gather relevant capabilities for each record_type
            const { 
                nistControls, cisSafeguards, awsCapabilities, 
                gcpCapabilities, azureCapabilities, m365Capabilities 
            } = gatherCapabilityIds(capabilityByTechnique[techniqueId] || []);

            // 4) Evaluate coverage
            const monitoringCoverageEval = buildMonitoringCoverageEval(monitoringKeywords, dataSources);

            // 5) Build prevEntry [calc_tid_before, calc_tid_after, calc_prev_score, detectionCount]
            const prevEntry = buildPrevEntry(staticVarsCalc[techniqueId], detectionCount);

            // 6) Calculate initial-score
            //    We assume computeChokepointFromValues/computeActionabilityScore might need
            //    in-memory "static config" if they used Dexie. For brevity, we show local stubs here.
            const [calc_tid_before, calc_tid_after, calc_prev_score] = prevEntry;
            const chokepointScore = computeChokepointFromValues(calc_tid_before, calc_tid_after);
            const actionabilityScore = computeActionabilityScore(
                nistControls.length,
                cisSafeguards.length,
                detectionCount
            );
            const prevalenceScore = parseFloat(calc_prev_score) || 0;
            const initialScore = parseFloat(
                (chokepointScore + actionabilityScore + prevalenceScore).toFixed(4)
            );

            // 7) Return final technique record
            return {
                technique_id: techniqueId,
                technique_url,
                technique_name,
                prevEntry,
                data_sources: dataSources,
                nist_controls: nistControls,
                cis_safeguards: cisSafeguards,
                aws_capabilities: awsCapabilities,
                gcp_capabilities: gcpCapabilities,
                azure_capabilities: azureCapabilities,
                m365_capabilities: m365Capabilities,
                mitigations,
                monitoring_coverage_eval: monitoringCoverageEval,
                initial_score: initialScore
            };
        }


        /************************************************************
         * Helper: Check if STIX object has external_references
         * with source_name="mitre-attack" and external_id=techniqueId
         ************************************************************/
        function hasExternalReference(obj, sourceName, techniqueId) {
        if (!obj.external_references || !Array.isArray(obj.external_references)) return false;
        return obj.external_references.some(ref =>
            ref.source_name === sourceName && ref.external_id === techniqueId
        );
        }

        /************************************************************
         * Helper: Extract the official MITRE Attack URL from the
         * patternObj’s external_references, specifically where
         * source_name="mitre-attack" and external_id=techniqueId.
         ************************************************************/
        function getMitreUrlFromPattern(patternObj, techniqueId) {
        if (!patternObj.external_references) return "";
        const ref = patternObj.external_references.find(r =>
            r.source_name === "mitre-attack" && r.external_id === techniqueId
        );
        return ref && ref.url ? ref.url : "";
        }

        /**
         * gatherMitigationsAndDetections
         *
         * Reads the relationships for a single patternId from in-memory relationshipsMap,
         * returning an array of mitigations plus a detectionCount.
         *
         * @param {string} patternId          - e.g. "attack-pattern--abc123"
         * @param {Map} relationshipsMap      - Map(patternId => array of relationship objs)
         * @param {Map} courseOfActionMap     - Map(coaId => course-of-action obj)
         * @returns {Object} { mitigations: Array, detectionCount: number }
         */
        function gatherMitigationsAndDetections(patternId, relationshipsMap, courseOfActionMap) {
        const rels = relationshipsMap.get(patternId) || [];
        const mitigations = [];
        let detectionCount = 0;

        for (const rel of rels) {
            if (rel.relationship_type === "mitigates") {
            // Then rel.source_ref should be a course-of-action ID
            const coa = courseOfActionMap.get(rel.source_ref);
            if (coa && Array.isArray(coa.external_references)) {
                const mitreRef = coa.external_references.find(r => r.source_name === "mitre-attack");
                const mitigation_id = mitreRef?.external_id || "";
                const mitigation_name = coa.name || "";
                mitigations.push({
                mitigation_id,
                mitigation_name
                });
            }
            } else if (rel.relationship_type === "detects") {
            // If there's a "detects" relationship, increment detectionCount
            detectionCount++;
            }
        }

        return { mitigations, detectionCount };
        }


        /**
         * gatherCapabilityIds
         *
         * For the given array of capability objects (all tied to a single techniqueId),
         * classify them by their record_type (nist_controls, cis_safeguards, etc.).
         *
         * @param {Array<object>} capsForTechnique - from capabilityByTechnique[techniqueId]
         * @returns {Object} e.g. {
         *   nistControls: [...],
         *   cisSafeguards: [...],
         *   awsCapabilities: [...],
         *   gcpCapabilities: [...],
         *   azureCapabilities: [...],
         *   m365Capabilities: [...]
         * }
         */
        function gatherCapabilityIds(capsForTechnique) {
        const nistControls = [];
        const cisSafeguards = [];
        const awsCapabilities = [];
        const gcpCapabilities = [];
        const azureCapabilities = [];
        const m365Capabilities = [];

        for (const cap of capsForTechnique) {
            if (cap.record_type === "nist_controls") {
            nistControls.push(cap.capability_id);
            } else if (cap.record_type === "cis_safeguards") {
            cisSafeguards.push(cap.capability_id);
            } else if (cap.record_type === "aws_capabilities") {
            awsCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "gcp_capabilities") {
            gcpCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "azure_capabilities") {
            azureCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "m365_capabilities") {
            m365Capabilities.push(cap.capability_id);
            }
        }

        return {
            nistControls,
            cisSafeguards,
            awsCapabilities,
            gcpCapabilities,
            azureCapabilities,
            m365Capabilities
        };
        }


        /**
         * buildMonitoringCoverageEval
         *
         * For each (key, value) in monitoringKeywords (where record_type="keyword"),
         * if the technique's dataSources includes the key (case-insensitive),
         * we add the value (like "process", "network", etc.) to coverage set.
         *
         * @param {Array} monitoringKeywords - array of { key, value, record_type="keyword" }
         * @param {Array} dataSources        - from patternObj.x_mitre_data_sources
         * @returns {Array<string>} e.g. ["process", "file"]
         */
        function buildMonitoringCoverageEval(monitoringKeywords, dataSources) {
        if (!dataSources || !dataSources.length) return [];

        const coverage = new Set();
        const lowerSources = dataSources.map(ds => ds.toLowerCase());

        for (const kw of monitoringKeywords) {
            const theKey = (kw.key || "").toLowerCase();
            const theVal = kw.value || "";
            if (!theKey || !theVal) continue;

            // If any dataSource contains theKey substring
            if (lowerSources.some(ds => ds.includes(theKey))) {
            coverage.add(theVal);
            }
        }
        return Array.from(coverage);
        }


        /**
         * buildPrevEntry
         *
         * Returns [calc_tid_before, calc_tid_after, calc_prev_score, detectionCount].
         * If the user has "calc" info from staticVarsCalc, we parse them.
         *
         * @param {object} calcEntry     - e.g. { calc_tid_before, calc_tid_after, calc_prev_score }
         * @param {number} detectionCount
         * @returns {[number, number, number, number]} [before, after, prevScore, detectionCount]
         */
        function buildPrevEntry(calcEntry, detectionCount) {
        const before = parseFloat(calcEntry?.calc_tid_before) || 0;
        const after  = parseFloat(calcEntry?.calc_tid_after)  || 0;
        const prevScore = parseFloat(calcEntry?.calc_prev_score) || 0;

        return [before, after, prevScore, detectionCount];
        }


        /**
         * computeChokepointFromValues
         *
         * Example of a simplified function that uses constants (or a global config).
         * If you want to keep them dynamic, load them once and store in a config object.
         *
         * @param {number} tidBefore
         * @param {number} tidAfter
         * @returns {number} - a float in [0..1]
         */
        function computeChokepointFromValues(tidBefore, tidAfter) {
        // Example constants (replace with your real values).
        const beforeLower = 0;
        const beforeUpper = 1;
        const afterLower  = 0;
        const afterUpper  = 1;
        const wBefore1    = 1;
        const ratio       = 1;

        // 1. clamp helper
        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        // 2. scale and clamp
        const beforeClamped = clamp((tidBefore - beforeLower) / (beforeUpper - beforeLower), 0, 1);
        const afterClamped  = clamp((tidAfter  - afterLower ) / (afterUpper  - afterLower ), 0, 1);

        // 3. compute partial weight for "after"
        const wAfter1 = (wBefore1 / ratio) * (afterUpper - afterLower) / (beforeUpper - beforeLower);

        const weightBefore = wBefore1 / (wAfter1 + wBefore1);
        const weightAfter  = wAfter1  / (wAfter1 + wBefore1);

        // 4. combine
        return (weightBefore * beforeClamped) + (weightAfter * afterClamped);
        }


        /**
         * computeActionabilityScore
         *
         * Example function that uses local or globally cached constants instead
         * of repeatedly querying Dexie in a loop.
         *
         * @param {number} nistCount
         * @param {number} cisCount
         * @param {number} detectionCount
         * @returns {number} float in [0..1]
         */
        function computeActionabilityScore(nistCount, cisCount, detectionCount) {
        // Example placeholders:
        const mitigationsLowerCutoff = 0;
        const mitigationsUpperCutoff = 5;
        const detectionsLowerCutoff  = 0;
        const detectionsUpperCutoff  = 5;

        const wMiti1 = 1;
        const ratio  = 1;

        // 1. clamp
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // 2. mitigationsUtility
        const rawMiti = (nistCount + cisCount) - mitigationsLowerCutoff;
        const mitigationsUtility = clamp(rawMiti / (mitigationsUpperCutoff - mitigationsLowerCutoff), 0, 1);

        // 3. detectionsUtility
        const rawDetect = detectionCount - detectionsLowerCutoff;
        const detectionsUtility = clamp(rawDetect / (detectionsUpperCutoff - detectionsLowerCutoff), 0, 1);

        // 4. partial weight for detections
        const actionabilityWeightDetect1 = (wMiti1 / ratio) *
            (detectionsUpperCutoff - detectionsLowerCutoff) /
            (mitigationsUpperCutoff - mitigationsLowerCutoff);

        // 5. relative weights
        const actionabilityWeightMiti   = wMiti1 / (actionabilityWeightDetect1 + wMiti1);
        const actionabilityWeightDetect = actionabilityWeightDetect1 / (actionabilityWeightDetect1 + wMiti1);

        // 6. final score
        return (actionabilityWeightMiti * mitigationsUtility)
            + (actionabilityWeightDetect * detectionsUtility);
        }


        /************************************************************
         * USAGE (example)
         * ----------------------------------------------------------
         * const db = initShuffleDb();
         * await createAllTechniques(db);
         ************************************************************/


        //
        // Contextual Asset Type Construction
        //
        /*
        * IMPORTANT - Needs to be updated to use Dexie.js and new shuffledb schema
         * Builds a contextualized asset-type-instance object for each unique assetType found in your
         * MAPEX “assetTypeMappings” (devicesMappings, networksMappings, etc.) and enriches
         * them with the relevant technique data (prevEntry, data-sources, etc.).
         * 
         * Finally, writes them to the "contextualizedAssetTypes" store in IndexedDB,
         * keyed by a field "assetTypeId" (e.g. "Linux Server OS").
         */
        async function buildContextualAssetTypes() {
            try {
                const db = await initIndexedDB();

                // 1. Gather all assetTypeMappings from your MAPEX store(s).
                //    For example, if you've stored them in "devicesMappings", "networksMappings", etc.,
                //    you can fetch them all or you can unify them into a single store. 
                //    Here is a conceptual example of retrieving them:
                const storeNames = [
                "devicesMappings",
                "networksMappings",
                "applicationsMappings",
                "dataMappings",
                "identitiesMappings"
                ];

                // We'll gather them into a single array in memory
                let allAssetMappings = [];
                for (const storeName of storeNames) {
                // If these object stores exist, fetch everything
                if (db.objectStoreNames.contains(storeName)) {
                    const storeData = await getAllFromStore(db, storeName);
                    allAssetMappings = allAssetMappings.concat(storeData);
                }
                }

                // 2. Group assetTypeMappings by capability_id (e.g. "Linux Server OS").
                //    We'll create a dictionary: { "Linux Server OS": [ {capability_id..., attack_object_id..., ...}, ... ] }
                const groupedByAssetType = {};
                for (const entry of allAssetMappings) {
                const assetTypeName = entry.capability_id;    // e.g. "Linux Server OS"
                const assetCategory = entry.capability_group; // e.g. "devices"

                if (!groupedByAssetType[assetTypeName]) {
                    groupedByAssetType[assetTypeName] = {
                    assetCategory,
                    entries: [] // all technique mappings referencing this asset type
                    };
                }
                groupedByAssetType[assetTypeName].entries.push(entry);
                }

                // 3. For each unique asset type, build the final object shape:
                //    {
                //       assetTypeId: "Linux Server OS",
                //       "asset-category": "devices",
                //       "asset-type": "Linux Server OS",
                //       "model-values": {},  // We'll populate in Step 2 (Add Asset Type) 
                //       "techniques": { "T1001": {...}, "T1002": {...} }
                //    }
                const contextualAssetTypes = {};

                for (const [assetTypeName, info] of Object.entries(groupedByAssetType)) {
                const assetCategory = info.assetCategory;
                // Build the skeleton object
                const assetTypeObj = {
                    assetTypeId: assetTypeName,  // our unique keyPath
                    "asset-category": assetCategory,
                    "asset-type": assetTypeName,
                    "model-values": {}, 
                    "techniques": {}
                };

                // For each technique mapping referencing this asset type
                for (const mapping of info.entries) {
                    const techniqueId   = mapping.attack_object_id;   // e.g. "T1001"
                    const techniqueName = mapping.attack_object_name; // e.g. "Data Obfuscation"

                    // Build the partial technique object
                    // We'll call a helper "buildContextualTechniqueObject(techniqueId, techniqueName)" 
                    // that merges in STIX data (data-sources, mitigations, prevEntry, etc.).
                    // Or you can do it inline. For clarity, let's just call a helper:
                    const techniqueObj = await buildContextualTechniqueObject(techniqueId, techniqueName);

                    // Add it to the assetTypeObj
                    assetTypeObj.techniques[techniqueId] = techniqueObj;
                }

                contextualAssetTypes[assetTypeName] = assetTypeObj;
                }

                // 4. Write these new objects to the "contextualizedAssetTypes" store in a single transaction
                const txWrite = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = txWrite.objectStore("contextualizedAssetTypes");

                for (const [assetTypeName, assetTypeObj] of Object.entries(contextualAssetTypes)) {
                store.put(assetTypeObj);
                }

                await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
                });

                console.log("✅ Built contextual asset types and stored in 'contextualizedAssetTypes'.");
                return contextualAssetTypes;

            } catch (error) {
                console.error("Error in buildContextualAssetTypes:", error);
                return {};
            }
        };

        

        /**
         * Updates (or creates) an "asset-type-instance" record in the modelInstances store
         * when the user selects environment, coverage, and (optionally) record count.
         *
         * @param {string} assetCategory   e.g. "Data" or "Devices"
         * @param {string} assetTypeName   e.g. "Linux Server OS"
         * @param {string} environment     e.g. "AWS", "GCP", "Azure", "M365"
         * @param {Object} coverageObj     e.g. { "network-monitoring": "High", "process-monitoring": "Medium", ... }
         * @param {number} [recordCount]   only defined if assetCategory === "data"
         */
        async function updateModelValuesForAssetType(
        assetCategory,
        assetTypeName,
        environment,
        coverageObj,
        recordCount
        ) {
        try {
            // 1. Get or initialize your Dexie db
            const db = await initShuffleDb(); // or use a global `db` if you've already opened it

            // 2. Build the record in the shape your new schema expects
            //    We’ll store it as record_type="asset-type-instance"
            const newRecord = {
            record_type: "asset-type-instance",
            "asset-category": assetCategory,
            "asset-type": assetTypeName,
            environment: environment,
            "monitoring-coverage": coverageObj || {},
            };

            console.log("updateModelValuesForAssetType: ", newRecord)

            // Add recordCount if provided
            if (recordCount != null) {
            newRecord["record-count"] = recordCount;
            }
            console.log("updateModelValuesForAssetType: ", newRecord)
            // 3. Insert the record. Using add() will always make a new entry,
            //    while put() can "upsert" if you have a matching primary key.
            //    Because modelInstances has an auto-increment “++id”,
            //    we can just do add() for new entries:
            const instanceId = await db.modelInstances.add(newRecord);
            console.log("Created new modelInstance with ID:", instanceId);

            // 4. Now that the instance is created, build its technique objects
            await buildAssetTechniques(db, instanceId);

            // 5. Refresh any UI table that displays modelInstances
            await refreshAssetTypeInstancesTable(db);

        } catch (error) {
            console.error("Error in updateModelValuesForAssetType:", error);
        }
        }

        /**
         * buildAssetTechniques(db, instanceId)
         * 
         * 1) Retrieves the asset instance from db.modelInstances by its primary key (instanceId).
         * 2) Finds the relevant techniques for that asset-type via db.capabilities, grouped by mapping_type:
         *    - "abused-by"
         *    - "targeted-by"
         * 3) For each technique, fetches its expanded data from db.techniques (or uses your own function).
         * 4) Computes the final attack-score using the coverage from the asset instance.
         * 5) Attaches them to the record (abusedByTechniques, targetedByTechniques).
         * 6) Updates the record in db.modelInstances.
         */
        async function buildAssetTechniques(db, instanceId) {
            // 1) Retrieve the instance
            const instanceRecord = await db.modelInstances.get(instanceId);
            if (!instanceRecord) {
                console.error("No record found for instanceId:", instanceId);
                return;
            }

            // 2) We'll want to fetch the relevant capabilities for that asset-type
            const assetTypeName = instanceRecord["asset-type"];
            const coverageObj   = instanceRecord["monitoring-coverage"] || {};
            
            // Because we only want items that have `capability_id = assetTypeName` and record_type="asset_types"
            // Then we’ll group them by mapping_type. For example:
            const allCaps = await db.capabilities
                .where("record_type").equals("asset_types")
                .and(c => c.capability_id === assetTypeName)
                .toArray();

            // Group them into abused vs targeted
            const abusedCaps   = allCaps.filter(c => c.mapping_type === "abused-by");
            const targetedCaps = allCaps.filter(c => c.mapping_type === "targeted-by");

            // Build final object for each group
            const abusedByTechniques   = {};
            const targetedByTechniques = {};

            // 3) For each technique in abusedCaps, build the technique object
            for (const cap of abusedCaps) {
                const techniqueId = cap.attack_object_id; // e.g. "T1001"
                
                // 3.1) We can either fetch an existing record from db.techniques,
                //      or call your “buildTechniqueRecord” code directly. If you have a
                //      prepopulated 'techniques' store, do something like:
                const techniqueRecord = await db.techniques
                .where("technique_id")
                .equals(techniqueId)
                .first();

                if (!techniqueRecord) {
                console.warn("No technique record found in db.techniques for", techniqueId);
                continue;
                }

                // 3.2) Convert that record into the needed shape
                const newObj = {
                "technique_name": techniqueRecord.technique_name,
                "prevEntry": techniqueRecord.prevEntry || [0,0,0,0],
                "data-sources": techniqueRecord.data_sources || [],
                "nist-controls": techniqueRecord.nist_controls || [],
                "cis-safeguards": techniqueRecord.cis_safeguards || [],
                "aws-capabilities": techniqueRecord.aws_capabilities || [],
                "gcp-capabilities": techniqueRecord.gcp_capabilities || [],
                "azure-capabilities": techniqueRecord.azure_capabilities || [],
                "m365-capabilities": techniqueRecord.m365_capabilities || [],
                "mitigations": techniqueRecord.mitigations || [],
                "monitoring-coverage-eval": techniqueRecord.monitoring_coverage_eval || []
                // We'll add "attack-score" below
                };

                // 4) Compute the final attack-score for this technique
                //    techniqueRecord.initial_score is from your “buildTechniqueRecord”
                const initialScore = parseFloat(techniqueRecord.initial_score) || 0;
                const weightSum    = computeCoverageWeight(coverageObj, techniqueRecord.monitoring_coverage_eval);
                const attackScore  = parseFloat((initialScore * (1 + weightSum)).toFixed(4));

                newObj["attack-score"] = attackScore;

                // 5) Attach to abusedByTechniques (keyed by techniqueId)
                abusedByTechniques[techniqueId] = newObj;
            }

            // Similarly for "targeted-by"
            for (const cap of targetedCaps) {
                const techniqueId = cap.attack_object_id;
                // Same code as above
                const techniqueRecord = await db.techniques
                .where("technique_id")
                .equals(techniqueId)
                .first();

                if (!techniqueRecord) {
                console.warn("No technique record found in db.techniques for", techniqueId);
                continue;
                }

                const newObj = {
                "technique_name": techniqueRecord.technique_name,
                "prevEntry": techniqueRecord.prevEntry || [0,0,0,0],
                "data-sources": techniqueRecord.data_sources || [],
                "nist-controls": techniqueRecord.nist_controls || [],
                "cis-safeguards": techniqueRecord.cis_safeguards || [],
                "aws-capabilities": techniqueRecord.aws_capabilities || [],
                "gcp-capabilities": techniqueRecord.gcp_capabilities || [],
                "azure-capabilities": techniqueRecord.azure_capabilities || [],
                "m365-capabilities": techniqueRecord.m365_capabilities || [],
                "mitigations": techniqueRecord.mitigations || [],
                "monitoring-coverage-eval": techniqueRecord.monitoring_coverage_eval || []
                // We'll add "attack-score" below
                };

                const initialScore = parseFloat(techniqueRecord.initial_score) || 0;
                const weightSum    = computeCoverageWeight(coverageObj, techniqueRecord.monitoring_coverage_eval);
                const attackScore  = parseFloat((initialScore * (1 + weightSum))).toFixed(4);
                newObj["attack-score"] = attackScore;

                targetedByTechniques[techniqueId] = newObj;
            }

            // 6) Update the record with these new technique objects
            instanceRecord.abusedByTechniques   = abusedByTechniques;
            instanceRecord.targetedByTechniques = targetedByTechniques;

            await db.modelInstances.update(instanceId, {
                abusedByTechniques,
                targetedByTechniques
            });

            console.log("Updated instance with abusedByTechniques and targetedByTechniques for instanceId:", instanceId);
        }

        /**
         * computeCoverageWeight(coverageObj, coverageEval)
         *
         * coverageObj might look like:
         *   {
         *     "network-monitoring": "High",
         *     "process-monitoring": "Medium",
         *     "file-monitoring": "Low",
         *     "cloud-monitoring": "None",
         *     "hardware-monitoring": "None"
         *   }
         *
         * coverageEval might be an array of short coverage categories, e.g.: ["process", "network", "file"]
         *
         * hardcoding coverage factors for now.
         *
         * For each coverage domain in coverageEval, see if the coverageObj for that domain is nonzero,
         * and sum up the corresponding fraction. Return that sum as weightSum.
         */
        function computeCoverageWeight(coverageObj, coverageEval) {
            // mapping from "High"/"Medium"/"Low"/"None" to numeric fraction
            const coverageToFactor = {
                "High":   0.002,
                "Medium": 0.066,
                "Low":    0.132,
                "None":   0.198
            };

            let total = 0;

            // The technique might have "process", "network", "file", ...
            coverageEval.forEach(shortDomain => {
                // Map from these short domain words to the coverageObj key
                // e.g. "process" => "process-monitoring"
                // e.g. "network" => "network-monitoring"
                // This is up to you to define consistently
                const coverageKey = shortDomain + "-monitoring";

                // See what coverage level the user selected
                const userCoverage = coverageObj[coverageKey] || "None";

                // Add the numeric fraction
                const fraction = coverageToFactor[userCoverage] || 0;
                total += fraction;
            });

            return total;
        }


        /**
         * Top-level function to iterate through the files array, fetch each JSON,
         * parse, and import into the specified Dexie store. It also logs progress
         * messages to the "loading-logs" element.
         *
         * @param {Dexie} db        - The Dexie database instance.
         * @param {Array} filesArr  - The array of file metadata objects.
         *    e.g. { file, format, store, record_type, import_from }
         */
         async function importAllJsonFiles(db, filesArr) {
            for (const fileDef of filesArr) {
                await importSingleJsonFile(db, fileDef);
            }
        }

        // Function to update progress visually
        function updateProgress(logMessage) {
            // For example, if you have 6 main tasks:
            const totalSteps = 6;
            let currentStep = 0;
            currentStep++;
            const progressPercent = (currentStep / totalSteps) * 100;
            document.getElementById("loading-progress-bar").style.width = progressPercent + "%";

            // Append the log
            const logsDiv = document.getElementById("loading-logs");
            const newLogLine = document.createElement("div");
            newLogLine.textContent = `(${currentStep}/${totalSteps}) ${logMessage}`;
            logsDiv.prepend(newLogLine);
        }

        async function runInitializationSequence(db) {
            // Show the progress bar
            document.getElementById("progress-container").style.display = "block";



            // // Function to update progress visually
            // function updateProgress(logMessage) {
            //     currentStep++;
            //     const progressPercent = (currentStep / totalSteps) * 100;
            //     document.getElementById("loading-progress-bar").style.width = progressPercent + "%";

            //     // Append the log
            //     const logsDiv = document.getElementById("loading-logs");
            //     const newLogLine = document.createElement("div");
            //     newLogLine.textContent = `(${currentStep}/${totalSteps}) ${logMessage}`;
            //     logsDiv.appendChild(newLogLine);
            // }

            // 1) Initialize Dexie
            await initShuffleDb(db);
            updateProgress("shuffledb initialized.");

            // 2) Import staticVariables
            await importAllJsonFiles(db, filesArr);
            updateProgress("imported json files.");

            // 3) Import capabilities
            // await importRecords("capabilities");
            // updateProgress("capabilities imported.");

            // 4) Import attack store
            // await importRecords("attack");
            // updateProgress("attack data imported.");

            // 5) Create “techniques” store records
            await createAllTechniques(db);
            updateProgress("techniques store records created.");

            // populate environment dropdown
            populateEnvironmentSelection();
            updateProgress("Environment selections populated.");

            // populate record count dropdown
            populateRecordCountSelection();
            updateProgress("Record count selections populated.");

            //populate monitoring coverage radio sets
            populateMonitoringCoverageSelections();
            updateProgress("Monitoring coverage selections populated.");

            // All done: reveal the Next button
            document.getElementById("next-step").classList.remove("hidden");
            // Optional: hide the progress bar, or leave it fully at 100%
        }

        async function generateRadialTree() {
            const container = document.getElementById("radial-tree-container");
            if (!container) {
                console.error("❌ radial-tree-container not found in DOM.");
                return;
            }

            // Clear previous
            container.innerHTML = "";

            // Build the data object from Dexie
            const data = await buildRadialTreeData();

            // Dimensions
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2;

            // Create base SVG
            const svg = d3
                .select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            // Build radial "cluster" layout
            const tree = d3.cluster().size([360, radius - 100]);

            const root = d3.hierarchy(data, d => d.children);
            tree(root);

            // Draw links
            svg
                .selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1.5)
                .attr(
                "d",
                d3
                    .linkRadial()
                    .angle(d => (d.x * Math.PI) / 180)
                    .radius(d => d.y)
                );

            // Draw nodes
            const node = svg
                .selectAll(".node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `rotate(${d.x - 90}) translate(${d.y},0)`);

            // Node circles
            node.append("circle")
                .attr("r", 4)
                .attr("fill", "#69b3a2");

            // Labels
            node
                .append("text")
                .attr("dy", ".31em")
                .attr("x", d => (d.x < 180 ? 8 : -8))
                .attr("text-anchor", d => (d.x < 180 ? "start" : "end"))
                .attr("transform", d => (d.x >= 180 ? "rotate(180)" : ""))
                .text(d => d.data.name);
        }



        async function buildRadialTreeData() {
            // 1) Retrieve all asset-type-instance records from Dexie
            const db = await initShuffleDb();
            const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray();

            // 2) Get the currently selected visualization type (e.g. "detections", "mitigations", "nist_controls", etc.)
            const selectedVisualizationType = document.querySelector(
                'input[name="visualization-type"]:checked'
            )?.value || "detections";

            // 3) Accumulate a hierarchical structure using a nested map:
            //    Environment → Asset Category → Asset Type → Techniques
            const envMap = {};

            for (const instance of allInstances) {
                const environment = instance.environment || "Unknown Environment";
                const category = instance["asset-category"] || "Unknown Category";
                const assetType = instance["asset-type"] || "Unnamed Asset";

                // Ensure environment node exists
                if (!envMap[environment]) {
                envMap[environment] = {
                    name: environment,
                    children: {},
                };
                }

                // Ensure category node exists
                if (!envMap[environment].children[category]) {
                envMap[environment].children[category] = {
                    name: category,
                    children: {},
                };
                }

                // 4) Convert abusedByTechniques and targetedByTechniques (which are objects) into arrays
                const abusedObj = instance.abusedByTechniques || {};
                const targetedObj = instance.targetedByTechniques || {};
                const abusedArr = Object.entries(abusedObj);
                const targetedArr = Object.entries(targetedObj);

                // If you wanted to limit top 5 by "attack-score":
                abusedArr.sort((a, b) => parseFloat(b[1]["attack-score"]||0) - parseFloat(a[1]["attack-score"]||0));
                targetedArr.sort((a, b) => parseFloat(b[1]["attack-score"]||0) - parseFloat(a[1]["attack-score"]||0));
                const top5Abused   = abusedArr.slice(0, 5);
                const top5Targeted = targetedArr.slice(0, 5);
                const allTechs = [...top5Abused, ...top5Targeted];
                
                // If you do not want to limit to top 5:
                // const allTechs = [...abusedArr, ...targetedArr];

                // 5) For each technique, build its node.
                //    When the selected visualization type is "mitigations",
                //    we extract the mitigation_id from each mitigation object.
                const techniqueChildren = allTechs.map(([techId, techDetails]) => {
                let mappedArray = [];
                if (selectedVisualizationType === "mitigations") {
                    // If mitigations is stored as an object, extract its values and then the mitigation_id from each.
                    const mitObj = techDetails.mitigations || {};
                    mappedArray = Object.values(mitObj)
                    .map((m) => m.mitigation_id)
                    .filter(Boolean);
                } else {
                    // For other visualization types, assume the property holds an array.
                    mappedArray = techDetails[selectedVisualizationType] || [];
                }

                // Build child nodes from the mapped array.
                const mappingChildren = mappedArray.map((id) => ({ name: id }));

                return {
                    name: `${techId} - ${techDetails.technique_name || ""}`,
                    children: mappingChildren,
                    data: { ...techDetails }
                };
                });

                // Insert or update the assetType node
                envMap[environment].children[category].children[assetType] = {
                name: assetType,
                children: techniqueChildren
                };
            }

            // 6) Convert the nested envMap into an array-based hierarchical object for D3
            const root = { name: "Model", children: [] };
            root.children = Object.values(envMap).map((envObj) => {
                envObj.children = Object.values(envObj.children).map((catObj) => {
                catObj.children = Object.values(catObj.children);
                return catObj;
                });
                return envObj;
            });

            return root;
        }
    </script>
         
  
</body>

</html>
