<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Breach Cost Estimator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.12.0/ajv7.bundle.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <style>
        /* Dark mode by default */
        body.dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .dark .bg-white { background-color: #2d3748 !important; }
        .dark .text-black { color: #e2e8f0 !important; }
        .dark .bg-gray-100 { background-color: #1a202c !important; }
        .dark .border-gray-300 { border-color: #4a5568 !important; }
    
        /* Progress Bar */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .progress-bar li {
            list-style: none;
            width: 100%;
            text-align: center;
            position: relative;
            font-weight: bold;
            color: gray;
        }
        .progress-bar li:before {
            content: attr(data-step);
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: gray;
            color: white;
        }
        .progress-bar li.active {
            color: #3490dc;
        }
        .progress-bar li.active:before {
            background-color: #3490dc;
        }
    
        /* Hide all form steps by default */
        .form-step {
            display: none;
        }
    
        /* Only display the form-step that has the 'active' class */
        .form-step.active {
            display: block;
        }
    
        /* Loading Indicator */
        #loading-icon {
            display: none;
            font-size: 14px;
            color: #3490dc;
            animation: spin 1s linear infinite;
        }
    
        /* Loading Animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        /* Styling for asset selection */
        #asset-category-container label {
            display: block;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
        }
        #asset-category-container input[type="radio"] {
            display: none;
        }
        #asset-category-container input[type="radio"]:checked + label {
            background-color: #3490dc;
            color: white;
            border-color: #3490dc;
        }
    
        /* Styling for form fields */
        select, input[type="text"], input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #ddd;
            padding: 8px;
            width: 100%;
            border-radius: 5px;
        }
    
        /* Button styles */
        button {
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
        }
        .btn-primary {
            background-color: #3490dc;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #38a169;
            color: white;
        }
        .btn-danger {
            background-color: #e3342f;
            color: white;
        }
        .btn-primary:hover { background-color: #2779bd; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success:hover { background-color: #2f855a; }
        .btn-danger:hover { background-color: #cc1f1a; }
    
        /* JSON Output */
        #json-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f7fafc;
            color: black;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        /* Drawer Default Styling */
        .model-drawer {
            position: fixed;
            top: 0;
            right: -350px; /* Initially Hidden */
            width: 350px;
            height: 100%;
            background-color: #2d3748;
            color: white;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            transition: right 0.3s ease-in-out;
            padding: 20px;
        }

        /* When Opened */
        .model-drawer.open {
            right: 0;
        }

        /* Drawer Tab */
        .drawer-tab {
            position: absolute;
            left: -50px;
            top: 50%;
            width: 50px;
            height: 100px;
            background-color: #3490dc;
            color: white;
            border: none;
            border-radius: 5px 0 0 5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        /* Move Tab Inside Drawer When Expanded */
        .model-drawer.open .drawer-tab {
            left: 10px;
            background-color: #1e3a8a;
        }

        /* JSON Styling */
        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
        }
        #progress-container {
            display: none;
        }
    </style>
    
</head>
<body class="dark flex justify-center items-center min-h-screen">
    <!-- Progress Bar -->
    <div id="progress-container" class="w-full bg-gray-300 rounded mt-4 hidden">
        <div id="progress-bar" class="h-4 bg-blue-500 rounded w-0"></div>
    </div>
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed bottom-5 right-5 space-y-2 z-50"></div>
    <!-- Main Form Container -->
    <div class="bg-white shadow-md rounded-lg p-6 w-full max-w-2xl">
        <div class="flex justify-between items-center">
            <h2 class="text-xl font-bold">Data Breach Cost Estimator</h2>
            <button id="darkModeToggle" class="px-3 py-1 text-sm bg-gray-700 text-white rounded">
                <span id="darkModeIcon" class="material-symbols-outlined">dark_mode</span>
            </button>            
        </div>

        <!-- Progress Bar -->
        <ol class="progress-bar flex">
            <li data-step="1" class="active">Organization</li>
            <li data-step="2">Asset Types</li>
            <li data-step="3">MITRE ATT&CK Inventory</li>
        </ol>

        <form id="multiStepForm">
            <!-- Step 1: Organization Details -->
            <div class="form-step active">
                <h3 class="text-lg font-semibold mb-2">Organization Details</h3>
                <p class="text-sm text-gray-600 mb-2">Define your organization's security practices.</p>

                <div id="organization-details">
                    <label class="block mt-2">
                        <input type="checkbox" id="ai_automation" class="mr-2">
                        AI & Automation for Information Security
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_security_staff" class="mr-2">
                        Cybersecurity Training for Security Staff
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_all_employees" class="mr-2">
                        Cybersecurity Training for All Employees
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="incident_response_testing" class="mr-2">
                        Conduct Incident Response Tests
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="law_enforcement_ransomware" class="mr-2">
                        Engage Law Enforcement for Ransomware
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="data_encryption" class="mr-2">
                        Encrypt Stored Data (Beyond Disk Encryption)
                    </label>
                </div>

                <button type="button" class="next-step bg-blue-500 text-white px-4 py-2 rounded mt-4">Next</button>
            </div>

            <!-- Step 2: Asset Types -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Define Asset Types</h3>
                <p class="text-sm text-gray-600 mb-2">Select an asset category to continue.</p>

                <!-- Asset Category Selection -->
                <div id="asset-category-container">
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="devices" class="mr-2"> Devices
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="networks" class="mr-2"> Networks
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="applications" class="mr-2"> Applications & Workloads
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="data" class="mr-2"> Data
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="identities" class="mr-2"> Identities
                    </label>
                </div>

                <!-- Asset Type Selection -->
                <label class="block mt-2">Select Asset Type:
                    <select id="asset-type-dropdown" class="border p-2 w-full" disabled>
                        <option value="">Select an asset category first</option>
                    </select>
                    <span id="loading-icon" class="ml-2" style="display: none;">Loading...</span>
                </label>

                <!-- Environment Selection -->
                <div id="environment-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Environment:
                        <select id="environment-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Record Count Selection (Only for Data) -->
                <div id="record-count-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Estimated Record Count:
                        <select id="record-count-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Monitoring Coverage Selection -->
                <div id="monitoring-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Monitoring Coverage:</label>
                    <div id="network-monitoring" data-label="Network Monitoring"></div>
                    <div id="process-monitoring" data-label="Process Monitoring"></div>
                    <div id="file-monitoring" data-label="File Monitoring"></div>
                    <div id="cloud-monitoring" data-label="Cloud Monitoring"></div>
                    <div id="hardware-monitoring" data-label="Hardware Monitoring"></div>
                </div>

                <!-- Submit Asset Type -->
                <button type="button" id="submit-asset-type" class="bg-green-500 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    Add Asset Type
                </button>

                <!-- Button to Add Another Asset Type -->
                <button type="button" id="add-more-assets" class="bg-gray-500 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    Add Another Asset Type
                </button>

                <!-- Display Model Definition in JSON -->
                <button type="button" id="view-model-definition" class="bg-gray-700 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    View Model JSON
                </button>

                <button type="button" class="prev-step bg-gray-500 text-white px-4 py-2 rounded mt-4">Back</button>
                <button type="button" class="next-step bg-blue-500 text-white px-4 py-2 rounded mt-4">Next</button>
            </div>
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">MITRE ATT&CK Techniques Inventory</h3>
                <p class="text-sm text-gray-600 mb-4">Review the MITRE ATT&CK techniques relevant to each asset type.</p>
            
                <!-- Summary Table -->
                <table id="model-summary-table" class="w-full border-collapse border border-gray-300 text-sm">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                            <th class="border border-gray-300 px-4 py-2">Environment</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                            <th class="border border-gray-300 px-4 py-2">Count of MITRE ATT&CK Techniques</th>
                        </tr>
                    </thead>
                    <tbody id="model-summary-body"></tbody>
                </table>
            
                <!-- Techniques Table Container -->
                <div id="techniques-container" class="hidden mt-6">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-semibold">Techniques for <span id="selected-asset-type"></span></h4>
                        <button id="toggle-techniques-btn" type="button" bg-gray-600 text-white px-3 py-1 rounded">
                            Hide Techniques
                        </button>
                    </div>

                    <table id="techniques-table" class="w-full border-collapse border border-gray-300 text-sm">
                        <thead>
                            <tr class="bg-gray-700 text-white">
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique ID</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique Name</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Score</th>
                            </tr>
                        </thead>
                        <tbody id="techniques-body"></tbody>
                    </table>
                </div>

            
                <button type="button" class="prev-step bg-gray-500 text-white px-4 py-2 rounded mt-4">Back</button>
            </div>
            
        </form>

        <!-- JSON Output -->
        <pre id="json-output" class="bg-gray-100 text-black p-4 rounded mt-4" style="display: none;"></pre>
    </div>
    <!-- Collapsible Drawer -->
    <div id="model-drawer" class="model-drawer">
        <button id="drawer-tab" class="drawer-tab">Model JSON</button>
        <pre id="json-output" class="json-content"></pre>
    </div>
    <script>
        // Global cache for JSON data
        const jsonCache = {};
        
        // List of JSON files to fetch
        const jsonFiles = {
            "enterpriseAttack": "enterprise-attack.json",
            "weightKeywords": "weight-keywords.json",
            "staticVariables": "static-variables.json",
            "attackPrevTid": "attack-prev-tid.json",
            "cisToAttack": "cis_safeguard_to_techniques.json",
            "devicesMapping": "enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json",
            "networksMapping": "enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json",
            "applicationsMapping": "enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json",
            "dataMapping": "enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json",
            "identitiesMapping": "enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json",
            "nistMapping": "nist_800_53-rev5_attack-14.1-enterprise_json.json"
        };

        // Function to fetch JSON files once on page load
        async function fetchJSONFiles() {
            try {
                const fetchPromises = Object.entries(jsonFiles).map(async ([key, url]) => {
                    const response = await fetch(url, { mode: "cors" });
                    if (!response.ok) {
                        throw new Error(`Failed to fetch ${url}: ${response.status}`);
                    }
                    jsonCache[key] = await response.json();
                });

                await Promise.all(fetchPromises);
                console.log("✅ All JSON files loaded successfully:", jsonCache);
            } catch (error) {
                console.error("❌ Error loading JSON files:", error);
            }
        }

        // Function to get cached JSON data
        function getJSONData(key) {
            if (!jsonCache[key]) {
                console.warn(`⚠️ Warning: JSON data for '${key}' not available.`);
                return null;
            }
            return jsonCache[key];
        }

        async function fetchJSON(key) {
            return getJSONData(key);
        }

        function showToast(message, type = "success", duration = 3000) {
            const toastContainer = document.getElementById("toast-container");

            // Create toast element
            const toast = document.createElement("div");
            toast.classList.add(
                "px-4", "py-2", "rounded", "shadow-lg", "text-white", "transition-opacity", "duration-500", "opacity-100"
            );

            // Set background color based on type
            if (type === "success") {
                toast.classList.add("bg-green-500");
            } else if (type === "error") {
                toast.classList.add("bg-red-500");
            } else if (type === "warning") {
                toast.classList.add("bg-yellow-500", "text-black");
            } else {
                toast.classList.add("bg-gray-700");
            }

            // Set toast message
            toast.textContent = message;

            // Append to container
            toastContainer.appendChild(toast);

            // Fade out and remove toast
            setTimeout(() => {
                toast.classList.add("opacity-0");
                setTimeout(() => {
                    toast.remove();
                }, 500);
            }, duration);
        }
        // Store Model Definition in Memory
        const modelDefinition = {
            organization_attributes: {},
            asset_types: []
        };
    
        // Function to Toggle Drawer Visibility
        function toggleDrawer() {
            const drawer = document.getElementById("model-drawer");
            drawer.classList.toggle("open");
        }
    
        // Function to Populate Dropdowns and Radio Buttons with Predefined Values
        function populateStaticValues() {
            // console.log("Populating static values...");
            const environments = ["AWS", "GCP", "Azure", "M365"];
            const monitoringLevels = ["High", "Medium", "Low", "None"];
            const recordCounts = ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"];
    
            populateDropdown("#environment-dropdown", environments);
            populateDropdown("#record-count-dropdown", recordCounts);
            populateRadioButtons("#network-monitoring", monitoringLevels, "network_monitoring");
            populateRadioButtons("#process-monitoring", monitoringLevels, "process_monitoring");
            populateRadioButtons("#file-monitoring", monitoringLevels, "file_monitoring");
            populateRadioButtons("#cloud-monitoring", monitoringLevels, "cloud_monitoring");
            populateRadioButtons("#hardware-monitoring", monitoringLevels, "hardware_monitoring");
        }
    
        // Helper function to populate a dropdown with options
        function populateDropdown(selector, options) {
            const dropdown = document.querySelector(selector);
            dropdown.innerHTML = "";
            options.forEach(option => {
                const opt = document.createElement("option");
                opt.value = option;
                opt.textContent = option;
                dropdown.appendChild(opt);
            });
        }
    
        // Helper function to populate radio buttons
        function populateRadioButtons(containerSelector, options, name) {
            const container = document.querySelector(containerSelector);
            container.innerHTML = ""; // Clear previous content

            // Create a row div to group the label and radio buttons
            const rowDiv = document.createElement("div");
            rowDiv.classList.add("flex", "items-center", "space-x-4", "py-2"); // Flexbox for horizontal alignment

            // Create a label for the category
            const categoryLabel = document.createElement("span");
            categoryLabel.textContent = container.getAttribute("data-label") + ":";
            categoryLabel.classList.add("w-48", "font-semibold", "text-right"); // Ensure alignment

            rowDiv.appendChild(categoryLabel);

            // Create the radio button group
            const radioGroupDiv = document.createElement("div");
            radioGroupDiv.classList.add("flex", "space-x-6"); // Ensure even spacing

            options.forEach(option => {
                const radioWrapper = document.createElement("label");
                radioWrapper.classList.add("inline-flex", "items-center", "space-x-2");

                const radio = document.createElement("input");
                radio.type = "radio";
                radio.name = name;
                radio.value = option;
                radio.classList.add("form-radio", "text-blue-500");

                // Text label for radio button
                const radioText = document.createElement("span");
                radioText.textContent = option;

                radioWrapper.appendChild(radio);
                radioWrapper.appendChild(radioText);
                radioGroupDiv.appendChild(radioWrapper);
            });

            rowDiv.appendChild(radioGroupDiv);
            container.appendChild(rowDiv);
        }
    
        // Function to Update and Display Model Definition JSON
        function updateModelDisplay() {
            const jsonOutput = document.getElementById("json-output");
            jsonOutput.textContent = JSON.stringify(modelDefinition, null, 4);
        }
    
        document.getElementById("view-model-definition").addEventListener("click", () => {
            const jsonOutput = document.getElementById("json-output");

            // Toggle visibility
            if (jsonOutput.style.display === "none" || jsonOutput.style.display === "") {
                jsonOutput.style.display = "block";  // Show JSON
            } else {
                jsonOutput.style.display = "none";   // Hide JSON
            }
        });

        // Function to Add Asset Type to Model Definition
        function addAssetType() {
            // Retrieve selected values from form fields
            const assetCategory = document.querySelector("input[name='asset-category']:checked")?.value;
            const assetType = document.getElementById("asset-type-dropdown").value;
            const environment = document.getElementById("environment-dropdown").value;
            const recordCount = document.getElementById("record-count-dropdown")?.value;
            
            // Monitoring coverage checkboxes
            const networkMonitoring = document.querySelector("input[name='network_monitoring']:checked")?.value;
            const processMonitoring = document.querySelector("input[name='process_monitoring']:checked")?.value;
            const fileMonitoring = document.querySelector("input[name='file_monitoring']:checked")?.value;
            const cloudMonitoring = document.querySelector("input[name='cloud_monitoring']:checked")?.value;
            const hardwareMonitoring = document.querySelector("input[name='hardware_monitoring']:checked")?.value;

            // ✅ Validate required fields before proceeding
            if (!assetCategory || !assetType || !environment) {
                showToast("Please complete all required fields.", "error");
                return;
            }

            // ✅ Create a new asset type instance
            const assetInstance = {
                asset_category: assetCategory,
                asset_type: assetType,
                environment: environment,
                record_count: assetCategory === "data" ? recordCount : undefined,
                monitoring_coverage: {
                    network: networkMonitoring || "None",
                    process: processMonitoring || "None",
                    file: fileMonitoring || "None",
                    cloud: cloudMonitoring || "None",
                    hardware: hardwareMonitoring || "None"
                },
                attack_scores: [] // Initialize an empty array for attack scores
            };

            // ✅ Add the asset to the model definition
            modelDefinition.asset_types.push(assetInstance);

            // ✅ Update the model display
            updateModelDisplay();
            
            // ✅ Show success message
            showToast("Asset type added successfully!", "success");

            // ✅ Ensure the "View JSON Model" button is visible
            document.getElementById("view-model-definition").style.display = "inline-block";

            // ✅ Ensure the "Add More Assets" button is visible
            document.getElementById("add-more-assets").style.display = "inline-block";

            // ✅ Refresh the model summary table (fixes techniques not updating)
            generateModelSummaryTable();
        }

    
        // Function to Handle Asset Category Selection
        function handleAssetCategorySelection() {
            document.querySelectorAll("input[name='asset-category']").forEach(radio => {
                radio.addEventListener("change", function() {
                    fetchAndPopulateAssetTypes(this.value);
                    document.getElementById("environment-selection").style.display = "block";
                    document.getElementById("monitoring-selection").style.display = "block";
                    document.getElementById("submit-asset-type").style.display = "block";
    
                    if (this.value === "data") {
                        document.getElementById("record-count-selection").style.display = "block";
                    } else {
                        document.getElementById("record-count-selection").style.display = "none";
                    }
                });
            });
        }
    
        // Function to Fetch and Populate Asset Types
        function fetchAndPopulateAssetTypes(category) {
            const assetTypeDropdown = document.getElementById("asset-type-dropdown");
            const loadingIcon = document.getElementById("loading-icon");
            const categoryUrls = {
                'devices': './enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json',
                'networks': './enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json',
                'applications': './enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json',
                'data': './enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json',
                'identities': './enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json'
            };
    
            const url = categoryUrls[category];
            if (!url) return;
    
            assetTypeDropdown.disabled = true;
            assetTypeDropdown.innerHTML = `<option value="">Loading...</option>`;
            loadingIcon.style.display = "inline-block";
    
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    const uniqueCapabilityIds = [...new Set(data.mapping_objects.map(obj => obj.capability_id))];
                    assetTypeDropdown.innerHTML = `<option value="">Select an asset type</option>`;
                    uniqueCapabilityIds.forEach(id => {
                        const option = document.createElement("option");
                        option.value = id;
                        option.textContent = id;
                        assetTypeDropdown.appendChild(option);
                    });
                    assetTypeDropdown.disabled = false;
                    loadingIcon.style.display = "none";
                })
                .catch(() => {
                    assetTypeDropdown.innerHTML = `<option value="">Error loading asset types</option>`;
                    loadingIcon.style.display = "none";
                });
        }
    
        // Function to Handle Navigation Between Steps
        let currentStep = 0;
        async function handleNavigation() {
            showStep(currentStep);

            document.querySelectorAll(".next-step").forEach(button => {
                button.addEventListener("click", async () => {
                    if (currentStep < 2) {
                        if (currentStep === 0) {
                            buildOrganizationAttributes();
                        }
                        if (currentStep === 1) {
                            // ✅ Only recalculate if scores do not exist
                            const scoresExist = modelDefinition.asset_types.some(asset => asset.attack_scores?.length > 0);
                            if (!scoresExist) {
                                await calculateAllTechniqueScores();
                            }
                            updateModelDisplay();
                            generateModelSummaryTable();
                        }
                        currentStep++;
                        showStep(currentStep);
                        hideDynamicElements();
                    }
                });
            });

            document.querySelectorAll(".prev-step").forEach(button => {
                button.addEventListener("click", () => {
                    if (currentStep > 0) {
                        currentStep--;
                        showStep(currentStep);
                        hideDynamicElements();
                        updateModelDisplay(); // ✅ Ensure JSON output is updated
                    }
                });
            });
        }

        // Fetch techniques for each asset type; Run score calculations in parallel using Promise.all(); store results in modelDefinition.asset_types[].attack_scores
        async function calculateAllTechniqueScores() {
            console.log("🚀 Calculating ATT&CK scores for all selected asset types...");

            // Show progress bar
            const progressContainer = document.getElementById("progress-container");
            const progressBar = document.getElementById("progress-bar");
            progressContainer.style.display = "block";

            // Calculate total number of techniques
            let totalTechniques = modelDefinition.asset_types.reduce((sum, asset) => 
                sum + (asset.attack_scores ? asset.attack_scores.length : 0), 0);
            let completed = 0;

            // Pre-fetch all JSON files in parallel
            const assetCategoryFiles = [...new Set(modelDefinition.asset_types.map(asset => getCategoryFilePath(asset.asset_category)))];
            const jsonData = await Promise.all(assetCategoryFiles.map(async (filePath) => {
                const response = await fetch(filePath);
                return { filePath, data: await response.json() };
            }));

            // Convert JSON data into a lookup Map for fast access
            const jsonDataMap = new Map(jsonData.map(({ filePath, data }) => [filePath, data.mapping_objects]));

            // Process each asset type in parallel
            const assetPromises = modelDefinition.asset_types.map(async (asset) => {
                if (!asset.attack_scores) {
                    asset.attack_scores = []; // Ensure attack_scores is initialized
                }

                // Lookup asset category data
                const categoryFilePath = getCategoryFilePath(asset.asset_category);
                const mappingObjects = jsonDataMap.get(categoryFilePath) || [];

                // Create a Set for quick lookup of existing scores
                const existingScoreSet = new Set(asset.attack_scores.map(t => t.attack_object_id));

                // Extract techniques related to this asset type using a Map lookup
                const techniques = mappingObjects
                    .filter(obj => obj.capability_id === asset.asset_type)
                    .map(obj => ({
                        attack_object_id: obj.attack_object_id,
                        attack_object_name: obj.attack_object_name
                    }));

                console.log(`Techniques for ${asset.asset_type}:`, techniques);

                // Calculate scores in parallel while skipping existing ones
                const newScores = await Promise.all(techniques.map(async (technique) => {
                    if (existingScoreSet.has(technique.attack_object_id)) {
                        return asset.attack_scores.find(t => t.attack_object_id === technique.attack_object_id);
                    }

                    const score = await calculateFinalScore(technique.attack_object_id, asset);
                    completed++;

                    // ✅ Only update the progress bar every 10 calculations
                    if (completed % 10 === 0 || completed === totalTechniques) {
                        progressBar.style.width = `${(completed / totalTechniques) * 100}%`;
                    }

                    return {
                        ...technique,
                        score: score.toFixed(4)
                    };
                }));

                // Merge new scores into existing scores
                asset.attack_scores = [...asset.attack_scores, ...newScores];
            });

            // Wait for all assets to complete score computation
            await Promise.all(assetPromises);

            // Hide progress bar after completion
            progressContainer.style.display = "none";

            console.log("✅ ATT&CK scores computed for all asset types.");
        }




        // Function to Hide the Techniques Table and JSON Output
        function hideDynamicElements() {
            document.getElementById("techniques-container").classList.add("hidden");
            document.getElementById("json-output").style.display = "none";
        }
    
        // Function to Show the Current Step
        function showStep(step) {
            const formSteps = document.querySelectorAll(".form-step");
            const progressItems = document.querySelectorAll(".progress-bar li");
    
            formSteps.forEach((el, i) => {
                el.classList.toggle("active", i === step);
            });
            progressItems.forEach((el, i) => {
                el.classList.toggle("active", i === step);
            });
        }
    
        // Function to Build Organization Attributes from Checkboxes
        function buildOrganizationAttributes() {
            document.querySelectorAll("#organization-details input[type='checkbox']").forEach(input => {
                modelDefinition.organization_attributes[input.id] = input.checked;  // ✅ Ensure proper assignment
            });

            // console.log("Saved Organization Attributes:", modelDefinition.organization_attributes);
        }

        function generateModelSummaryTable() {
            const tableBody = document.getElementById("model-summary-body");
            tableBody.innerHTML = "";

            modelDefinition.asset_types.forEach(asset => {
                const techniques = asset.attack_scores || [];

                const avgScore = techniques.length
                    ? (techniques.reduce((sum, t) => sum + parseFloat(t.score), 0) / techniques.length).toFixed(4)
                    : "N/A";

                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${asset.environment}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_category}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_type}</td>
                    <td class="border border-gray-300 px-4 py-2 text-blue-500 cursor-pointer">
                        ${techniques.length} techniques (Avg Score: ${avgScore})
                    </td>
                `;

                // ✅ Pass asset type name instead of JSON
                row.querySelector("td:last-child").addEventListener("click", () => {
                    displayTechniquesTable(asset.asset_type);
                });

                tableBody.appendChild(row);
            });
        }


        async function displayTechniquesTable(assetTypeName) {
            const tableBody = document.getElementById("techniques-body");
            tableBody.innerHTML = "";

            document.getElementById("selected-asset-type").textContent = assetTypeName;
            document.getElementById("techniques-container").classList.remove("hidden");

            // Find the asset type object
            const selectedAssetType = modelDefinition.asset_types.find(asset => asset.asset_type === assetTypeName);
            if (!selectedAssetType) {
                console.error(`Error: Asset type '${assetTypeName}' not found in model definition.`);
                return;
            }

            // Use precomputed attack scores
            const techniques = selectedAssetType.attack_scores || [];

            techniques.forEach(technique => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_id}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_name}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.score}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        function getCategoryFilePath(category) {
            const files = {
                'devices': './enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json',
                'networks': './enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json',
                'applications': './enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json',
                'data': './enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json',
                'identities': './enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json'
            };
            return files[category] || "";
        }

        // Function to Toggle the Visibility of the Techniques Table
        function toggleTechniquesTable() {
            const techniquesContainer = document.getElementById("techniques-container");
            const toggleButton = document.getElementById("toggle-techniques-btn");

            if (techniquesContainer.classList.contains("hidden")) {
                techniquesContainer.classList.remove("hidden");
                toggleButton.textContent = "Hide Techniques";
            } else {
                techniquesContainer.classList.add("hidden");
                toggleButton.textContent = "Show Techniques";
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const icon = document.getElementById("darkModeIcon");
    
            body.classList.toggle("dark");
            icon.textContent = body.classList.contains("dark") ? "light_mode" : "dark_mode";
        }
    
        // Initialize the Script After DOM Loads
        document.addEventListener("DOMContentLoaded", () => {
            fetchJSONFiles();
            const drawerTab = document.getElementById("drawer-tab");
                if (drawerTab) {
                    // console.log("Drawer tab detected, attaching event listener.");
                    drawerTab.addEventListener("click", toggleDrawer);
                } else {
                    console.log("Error: Drawer tab element not found.");
                }
            
            const toggleButton = document.getElementById("toggle-techniques-btn");
            if (toggleButton) {
                toggleButton.addEventListener("click", toggleTechniquesTable);
            }

            const darkModeToggle = document.getElementById("darkModeToggle");
            if (darkModeToggle) {
                darkModeToggle.addEventListener("click", toggleDarkMode);
            }

            document.getElementById("submit-asset-type").addEventListener("click", addAssetType);
            handleNavigation();
            handleAssetCategorySelection();
            populateStaticValues();
            loadStixData();
        });

        // Object to store loaded STIX data
        const stixData = {
            objects: [],
            attackPatterns: new Map(),
            relationships: new Map(),
            dataComponents: new Map(),
            dataSources: new Map()
        };

        // URLs for fetching STIX data
        const stixUrls = {
            "enterprise-attack": "enterprise-attack.json"
        };

        // Function to load STIX data from JSON files
        async function loadStixData() {
            try {
                const responses = await Promise.all(
                    Object.entries(stixUrls).map(async ([key, url]) => {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                        return { key, data: await response.json() };
                    })
                );

                // Process and store STIX data
                responses.forEach(({ key, data }) => {
                    const objects = data.objects || [];
                    stixData.objects = objects; // Store raw data

                    // Preprocess into Maps for faster lookups
                    stixData.attackPatterns = new Map();
                    stixData.relationships = new Map();
                    stixData.dataComponents = new Map();
                    stixData.dataSources = new Map();

                    for (const obj of objects) {
                        switch (obj.type) {
                            case 'attack-pattern':
                                if (obj.external_references) {
                                    const externalId = obj.external_references.find(ref => ref.external_id);
                                    if (externalId) stixData.attackPatterns.set(externalId.external_id, obj);
                                }
                                break;
                            case 'relationship':
                                if (!stixData.relationships.has(obj.target_ref)) {
                                    stixData.relationships.set(obj.target_ref, []);
                                }
                                stixData.relationships.get(obj.target_ref).push(obj);
                                break;
                            case 'x-mitre-data-component':
                                stixData.dataComponents.set(obj.id, obj);
                                break;
                            case 'x-mitre-data-source':
                                stixData.dataSources.set(obj.id, obj);
                                break;
                        }
                    }
                });

                console.log("✅ STIX data successfully loaded and indexed.");
            } catch (error) {
                console.error("❌ Failed to load STIX data:", error);
            }
        }

        // Function to find data sources for a given MITRE ATT&CK technique ID
        function findDataSources(techniqueId) {
            let dataSources = [];

            // Find the attack pattern object
            const attackPattern = stixData.attackPatterns.get(techniqueId);
            if (!attackPattern) return [];

            // Find relationships where this attack pattern is the target
            const detectingRelationships = stixData.relationships.get(attackPattern.id) || [];

            for (const rel of detectingRelationships) {
                if (rel.relationship_type === 'detects') {
                    // Find the data component
                    const dataComponent = stixData.dataComponents.get(rel.source_ref);
                    if (!dataComponent || !dataComponent.x_mitre_data_source_ref) continue;

                    // Find the data source
                    const dataSource = stixData.dataSources.get(dataComponent.x_mitre_data_source_ref);
                    if (dataSource && dataSource.external_references && dataSource.external_references.length > 0) {
                        dataSources.push(`${dataComponent.name} (${dataSource.external_references[0].external_id})`);
                    }
                }
            }

            return dataSources;
        }


        // Function to calculate weight_sum based on keywords in data sources and monitoring coverage maturity selected by user
        async function calculateMonitoringCoverageWeightSum(techniqueId, assetMonitoringCoverage) {
            if (!assetMonitoringCoverage || typeof assetMonitoringCoverage !== 'object') {
                console.error(`Error: Invalid assetMonitoringCoverage for Technique ID: ${techniqueId}`);
                return 0;
            }

            try {
                // Load cached JSON data instead of fetching
                const weightKeywords = getJSONData("weightKeywords") || {};
                const staticVariables = getJSONData("staticVariables") || {};

                // Get data sources detecting this technique
                const dataSources = await findDataSources(techniqueId);
                if (!Array.isArray(dataSources) || dataSources.length === 0) {
                    console.warn(`No valid data sources found for Technique ID: ${techniqueId}`);
                    return 0;
                }

                // Convert weight-keywords to a Map for fast lookup
                const keywordMap = new Map(
                    Object.entries(weightKeywords).map(([key, value]) => [key.toLowerCase(), value])
                );

                // Convert dataSources to lowercase once before iteration
                const lowercasedDataSources = dataSources.map(source => source.toLowerCase());

                // Initialize weight categories
                let categoryWeights = {
                    process: 0,
                    network: 0,
                    file: 0,
                    cloud: 0,
                    hardware: 0
                };

                // Precompute matched categories per source to minimize redundant checks
                const matchedCategories = new Set();

                for (const source of lowercasedDataSources) {
                    for (const [keyword, category] of keywordMap.entries()) {
                        if (source.includes(keyword)) { // ✅ Substring Matching Fix
                            matchedCategories.add(category);
                        }
                    }
                }

                // Process matched categories
                for (const category of matchedCategories) {
                    if (!(category in assetMonitoringCoverage)) {
                        console.warn(`Category '${category}' is not found in assetMonitoringCoverage.`);
                        continue; // Skip invalid categories
                    }

                    // Determine weight based on user-selected monitoring coverage
                    const monitoringLevel = assetMonitoringCoverage[category]; // "None", "Low", "Medium", "High"

                    const weight = {
                        "None": staticVariables.weight_score_none || 0,
                        "Low": staticVariables.weight_score_low || 0,
                        "Medium": staticVariables.weight_score_medium || 0,
                        "High": staticVariables.weight_score_high || 0
                    }[monitoringLevel] || 0;

                    // Assign highest weight found for this category
                    categoryWeights[category] = Math.max(categoryWeights[category], weight);
                }

                // Compute final weight sum
                return Object.values(categoryWeights).reduce((sum, weight) => sum + weight, 0);
            } catch (error) {
                console.error(`Error in calculateMonitoringCoverageWeightSum for Technique ID ${techniqueId}:`, error);
                return 0;
            }
        }

        async function calculateFinalScore(techniqueId, assetObject) {
            if (!assetObject || !assetObject.monitoring_coverage) {
                console.error(`Error: Asset monitoring coverage is undefined for technique ID ${techniqueId}`);
                return 0; // Prevent further execution
            }

            try {
                // Load cached JSON data using correct keys from jsonFiles
                const attackPrev = getJSONData("attackPrevTid") || [];
                const nistMappings = getJSONData("nistMapping") || { mapping_objects: [] };
                const cisMappings = getJSONData("cisToAttack") || [];
                const enterpriseAttack = getJSONData("enterpriseAttack") || { objects: [] };
                const staticVariables = getJSONData("staticVariables") || {};
                const weightKeywords = getJSONData("weightKeywords") || {};

                // Compute weight sum based on monitoring coverage
                const weightSum = await calculateMonitoringCoverageWeightSum(techniqueId, assetObject.monitoring_coverage);

                // Extract prevalence score
                const prevEntry = attackPrev.find(t => t.attack_object_id === techniqueId);
                const prevalenceScore = prevEntry ? parseFloat(prevEntry.calc_prev_score) : 0;
                const tidBefore = prevEntry ? parseFloat(prevEntry.calc_tid_before) : 0;
                const tidAfter = prevEntry ? parseFloat(prevEntry.calc_tid_after) : 0;

                // Count security controls mapped to this technique
                const nistCount = (nistMappings.mapping_objects || []).filter(obj => obj.attack_object_id === techniqueId).length;
                const cisCount = (cisMappings || []).filter(obj => obj.attack_techniques.some(t => t.technique_id === techniqueId)).length;

                // Count detections from enterprise-attack.json
                let detectionCount = 0;
                const attackPattern = enterpriseAttack.objects.find(obj =>
                    obj.type === 'attack-pattern' &&
                    obj.external_references &&
                    obj.external_references.some(ref => ref.external_id === techniqueId)
                );

                if (attackPattern) {
                    detectionCount = enterpriseAttack.objects.filter(obj =>
                        obj.type === 'relationship' &&
                        obj.target_ref === attackPattern.id &&
                        obj.relationship_type === 'detects'
                    ).length;
                }

                // Ensure static variable defaults exist to prevent NaN issues
                const mitigationsLowerCutoff = staticVariables.actionability_mitigations_lower_cutoff || 0;
                const mitigationsUpperCutoff = staticVariables.actionability_mitigations_upper_cutoff || 1;
                const detectionsLowerCutoff = staticVariables.actionability_detections_lower_cutoff || 0;
                const detectionsUpperCutoff = staticVariables.actionability_detections_upper_cutoff || 1;

                // Compute actionability score
                const mitigationsUtility = Math.min(Math.max(
                    (nistCount + cisCount - mitigationsLowerCutoff) / (mitigationsUpperCutoff - mitigationsLowerCutoff),
                    0), 1);

                const detectionsUtility = Math.min(Math.max(
                    (detectionCount - detectionsLowerCutoff) / (detectionsUpperCutoff - detectionsLowerCutoff),
                    0), 1);

                const actionabilityWeightDetect1 = (staticVariables.actionability_w_miti1 || 1) /
                    (staticVariables.actionability_mitigations_to_detections_ratio || 1) *
                    (detectionsUpperCutoff - detectionsLowerCutoff) /
                    (mitigationsUpperCutoff - mitigationsLowerCutoff);

                const actionabilityWeightMiti = (staticVariables.actionability_w_miti1 || 1) /
                    (actionabilityWeightDetect1 + (staticVariables.actionability_w_miti1 || 1));

                const actionabilityWeightDetect = actionabilityWeightDetect1 /
                    (actionabilityWeightDetect1 + (staticVariables.actionability_w_miti1 || 1));

                const actionabilityScore = actionabilityWeightMiti * mitigationsUtility + actionabilityWeightDetect * detectionsUtility;

                // Compute chokepoint score
                const chokepointBeforeLower = staticVariables.chokepoint_before_lower_cutoff || 0;
                const chokepointBeforeUpper = staticVariables.chokepoint_before_upper_cutoff || 1;
                const chokepointAfterLower = staticVariables.chokepoint_after_lower_cutoff || 0;
                const chokepointAfterUpper = staticVariables.chokepoint_after_upper_cutoff || 1;

                const chokepointWeightAfter1 = (staticVariables.chokepoint_w_before1 || 1) /
                    (staticVariables.chokepoint_before_to_after_ratio || 1) *
                    (chokepointAfterUpper - chokepointAfterLower) /
                    (chokepointBeforeUpper - chokepointBeforeLower);

                const chokepointWeightBefore = (staticVariables.chokepoint_w_before1 || 1) /
                    (chokepointWeightAfter1 + (staticVariables.chokepoint_w_before1 || 1));

                const chokepointWeightAfter = chokepointWeightAfter1 /
                    (chokepointWeightAfter1 + (staticVariables.chokepoint_w_before1 || 1));

                const beforeUtility = Math.min(Math.max(
                    (tidBefore - chokepointBeforeLower) / (chokepointBeforeUpper - chokepointBeforeLower),
                    0), 1);

                const afterUtility = Math.min(Math.max(
                    (tidAfter - chokepointAfterLower) / (chokepointAfterUpper - chokepointAfterLower),
                    0), 1);

                const chokepointScore = chokepointWeightBefore * beforeUtility + chokepointWeightAfter * afterUtility;

                // Compute final score
                const initialScore = prevalenceScore + chokepointScore + actionabilityScore;
                const finalScore = initialScore * (1 + weightSum);

                return finalScore;
            } catch (error) {
                console.error(`Error in calculateFinalScore for technique ${techniqueId}:`, error);
                return 0; // Return a default score in case of an error
            }
        }

        


        // async function displayTechniquesTable(techniquesJSON, assetType) {
        //     const techniques = JSON.parse(techniquesJSON);
        //     const tableBody = document.getElementById("techniques-body");
        //     tableBody.innerHTML = "";

        //     document.getElementById("selected-asset-type").textContent = assetType;
        //     document.getElementById("techniques-container").classList.remove("hidden");

        //     for (const technique of techniques) {
        //         const row = document.createElement("tr");
        //         row.innerHTML = `
        //             <td class="border border-gray-300 px-4 py-2">${technique.attack_object_id}</td>
        //             <td class="border border-gray-300 px-4 py-2">${technique.attack_object_name}</td>
        //             <td class="border border-gray-300 px-4 py-2" id="score-${technique.attack_object_id}">Calculating...</td>
        //         `;
        //         tableBody.appendChild(row);

        //         // Calculate and populate score
        //         const score = await calculateFinalScore(technique.attack_object_id);
        //         document.getElementById(`score-${technique.attack_object_id}`).textContent = score.toFixed(4);
        //     }
        // }
    </script>
  
</body>

</html>
