<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>(attackShuffle).Lite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.js" integrity="sha512-+k1pnlgt4F1H8L7t3z95o3/KO+o78INEcXTbnoJQ/F2VqDVhWoaiVml/OEHv9HsVgxUaVW+IbiZPUJQfF/YxZw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js" integrity="sha512-OIkF2zyWS+sUanhT2i75RexNDQ2EKHayyeOxBx4Z4ct0D+dlPzZPhHTi7xZ5eU7aznNLMX7pCZyZVSi25+EGMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/4.0.10/dexie.min.js" integrity="sha512-jF+6XYwL495BDSom6h9X0w5EvtDrXfevVM17XSnhXHxP/iwallbjIo4TPbGltrj/gkCN4qde+S/HjiF8J5ATKQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>

    <style>
        /* Dark mode by default */
        body.dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .dark .bg-white { background-color: #2d3748 !important; }
        .dark .text-black { color: #e2e8f0 !important; }
        .dark .bg-gray-100 { background-color: #1a202c !important; }
        .dark .border-gray-300 { border-color: #4a5568 !important; }
    
        /* Progress Bar */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .progress-bar li {
            list-style: none;
            width: 100%;
            text-align: center;
            position: relative;
            font-weight: bold;
            color: gray;
        }
        .progress-bar li:before {
            content: attr(data-step);
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: gray;
            color: white;
        }
        .progress-bar li.active {
            color: #3490dc;
        }
        .progress-bar li.active:before {
            background-color: #3490dc;
        }
    
        /* Hide all form steps by default */
        .form-step {
            display: none;
        }
    
        /* Only display the form-step that has the 'active' class */
        .form-step.active {
            display: block;
        }
    
        /* Styling for asset selection */
        #asset-category-container label {
            display: block;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
        }
        #asset-category-container input[type="radio"] {
            display: none;
        }
        #asset-category-container input[type="radio"]:checked + label {
            background-color: #3490dc;
            color: white;
            border-color: #3490dc;
        }
    
        /* Styling for form fields */
        select, input[type="text"], input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #ddd;
            padding: 8px;
            width: 100%;
            border-radius: 5px;
        }
    
        /* Button styles */
        button {
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
        }
        .btn-primary {
            background-color: #3490dc;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #38a169;
            color: white;
        }
        .btn-danger {
            background-color: #e3342f;
            color: white;
        }
        .btn-primary:hover { background-color: #2779bd; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success:hover { background-color: #2f855a; }
        .btn-danger:hover { background-color: #cc1f1a; }
    
        /* JSON Output */
        #json-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f7fafc;
            color: black;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        /* JSON Styling */
        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
        }
        #progress-container {
            display: none;
        }

        #radial-tree-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            position: relative;
        }

        /* Styles for CDM View Step */
        /* Category headers row at the top */
        .assetCategoryHeaders {
        display: flex;
        margin-bottom: 8px;  /* some spacing before the matrix containers */
        }
        .category-header {
        flex: 1;            /* so that all five categories share space equally */
        text-align: center;
        background-color: #668bb3;
        color: #f4f4f4;
        padding: 5px 0;
        border-radius: 2px;
        margin: 0 2px;      /* small horizontal gap */
        font-weight: bold;
        }

        /* Each matrix-container holds multiple section-containers (or just one) */
        .matrix-container {
        margin-bottom: 20px; /* some spacing after each matrix */
        }

        /* A row of data for either environment or an overall row for controls, etc. */
        .section-container {
        display: flex;
        align-items: stretch;
        margin-bottom: 5px;
        border: 1px solid #394a6d;
        border-radius: 2px;
        background: #394a6d;
        }

        /* The narrow "header" on the left for each row, showing environment or a single label */
        .section-header-container {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #668bb3;
        color: #f4f4f4;
        padding: 5px;
        writing-mode: vertical-lr;  /* vertical text, top to bottom */
        transform: rotate(180deg);  /* flip so text is upright */
        flex: 0 0 25px;             /* fixed width for vertical header */
        border-radius: 2px 0 0 2px;
        text-align: center;
        font-size: 0.85em;
        }

        /* The 5 columns inside each row for the 5 categories */
        .section-category-container {
        flex: 1;
        background: #394a6d;
        padding: 5px;
        margin: 0 2px;   /* small horizontal gap between columns */
        border-radius: 2px;
        }


    </style>
    
</head>
<body class="dark flex justify-center items-center min-h-screen">
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed bottom-5 right-5 space-y-2 z-50"></div>
    <!-- Main Form Container -->
    <div class="bg-white shadow-md rounded-lg p-6 w-full max-w-2xl">
            <!-- Progress Bar -->
            <div id="progress-container" class="w-full bg-gray-300 rounded mt-4 hidden">
                <div id="loading-progress-bar" class="h-4 bg-blue-500 rounded w-0 hidden"></div>
            </div>
        <div class="flex justify-between items-center">
            <h2 class="text-xl font-bold">(attackShuffle).Lite</h2>
            <button id="darkModeToggle" class="px-3 py-1 text-sm bg-gray-700 text-white rounded">
                <span id="darkModeIcon" class="material-symbols-outlined">dark_mode</span>
            </button>            
        </div>

        <!-- Progress Bar -->
        <ol class="progress-bar flex">
            <li data-step="1" class="active">Initialize</li>
            <li data-step="2">Asset Types</li>
            <li data-step="3">MITRE ATT&CK Inventory</li>
            <li data-step="4">ATT&CK Technique Visualization</li>
            <li data-step="5">CDM View</li>
            <li data-step="6">Organization Details</li>
            <li data-step="7">Attack Analysis</li>
        </ol>  

        <div id="form-navigation" class="flex justify-between mt-4">
            <button type="button" id="prev-step" class="hidden bg-gray-500 text-white px-4 py-2 rounded">Back</button>
            <button type="button" id="next-step" class="bg-blue-500 text-white px-4 py-2 rounded hidden">Next</button>
        </div>

        <form id="multiStepForm">
            <!-- Step 1: Initializing -->
            <div class="form-step active">
                <h3 class="text-lg font-semibold mb-2">Initializing</h3>
                <div id="loading-logs" class="text-sm text-gray-400 h-32 overflow-auto border p-2 rounded mt-2">
                <!-- As data loads, you append or stream logs here. -->
                </div>
                <div class="mt-2 text-right">
                <!-- On completion, show the Next button. Hide it by default. -->
                </div>
            </div>
            
            <!-- Step 2: Asset Types -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Define Asset Types</h3>
                <p class="text-sm text-gray-600 mb-2">Select an asset category to continue.</p>

                <!-- Asset Category Selection -->
                <div id="asset-category-container">
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Devices" class="mr-2"> Devices
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Networks" class="mr-2"> Networks
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Applications & Workloads" class="mr-2"> Applications & Workloads
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Data" class="mr-2"> Data
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="Identities" class="mr-2"> Identities
                    </label>
                </div>

                <!-- Asset Type Selection -->
                <label class="block mt-2">Select Asset Type:
                    <select id="asset-type-dropdown" class="border p-2 w-full" disabled>
                        <option value="">Select an asset category first</option>
                    </select>
                </label>

                <!-- Environment Selection -->
                <div id="environment-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Environment:
                        <select id="environment-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Record Count Selection (Only for Data) -->
                <div id="record-count-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Estimated Record Count:
                        <select id="record-count-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Monitoring Coverage Selection -->
                <div id="monitoring-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Monitoring Coverage:</label>
                    <div id="network-monitoring" data-label="Network Monitoring"></div>
                    <div id="process-monitoring" data-label="Process Monitoring"></div>
                    <div id="file-monitoring" data-label="File Monitoring"></div>
                    <div id="cloud-monitoring" data-label="Cloud Monitoring"></div>
                    <div id="hardware-monitoring" data-label="Hardware Monitoring"></div>
                </div>
                
                <!-- Submit Asset Type -->
                <button type="button" id="submit-asset-type" class="bg-green-500 text-white px-4 py-2 rounded mt-4" style="display: block;">
                    Add Asset Type
                </button>
                <!-- Display Model Definition in JSON -->
                <button type="button" id="view-model-definition" class="bg-gray-700 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    View Model JSON
                </button>

                <!-- Table listing the existing modelInstances asset-type records -->
                <div class="mt-6">
                    <h4 class="text-md font-semibold">Current Asset Instances</h4>
                    <table id="asset-type-instances-table" class="w-full border-collapse border border-gray-300 text-sm mt-2">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                        <th class="border border-gray-300 px-4 py-2">Environment</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                        <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                        <th class="border border-gray-300 px-4 py-2">Monitoring Coverage</th>
                        <th class="border border-gray-300 px-4 py-2">Record Count</th>
                        <!-- You can add more columns if needed -->
                        </tr>
                    </thead>
                    <tbody id="asset-type-instances-body"></tbody>
                    </table>
                </div>
            </div>

            <!-- Step 3: Technique Scoring -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">MITRE ATT&CK Techniques Inventory</h3>
                <p class="text-sm text-gray-600 mb-4">Review the MITRE ATT&CK techniques relevant to each asset type.</p>
            
                <!-- Summary Table -->
                <table id="model-summary-table" class="w-full border-collapse border border-gray-300 text-sm">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                            <th class="border border-gray-300 px-4 py-2">Environment</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                            <th class="border border-gray-300 px-4 py-2">Count of MITRE ATT&CK Techniques</th>
                        </tr>
                    </thead>
                    <tbody id="model-summary-body"></tbody>
                </table>
            
                <!-- Techniques Table Container -->
                <div id="techniques-container" class="hidden mt-6">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-semibold">Techniques for <span id="selected-asset-type"></span></h4>
                        <button id="toggle-techniques-btn" type="button" bg-gray-600 text-white px-3 py-1 rounded">
                            Hide Techniques
                        </button>
                    </div>

                    <table id="techniques-table" class="w-full border-collapse border border-gray-300 text-sm">
                        <thead>
                            <tr class="bg-gray-700 text-white">
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique ID</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique Name</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Score</th>
                            </tr>
                        </thead>
                        <tbody id="techniques-body"></tbody>
                    </table>
                </div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>

            </div>

            <!-- Step 4: Radial Tree Visualization -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">ATT&CK Technique Visualization</h3>
                <p class="text-sm text-gray-600 mb-4">Select a category to visualize:</p>

                <!-- Radio Button Selection for Correlation Type -->
                <div id="visualization-selection" class="mb-4">
                    <!-- commenting out detections for now until we add detections to technique obj -->
                    <!-- <label><input type="radio" name="visualization-type" value="detections" checked> ATT&CK Detections</label> -->
                    <label><input type="radio" name="visualization-type" value="mitigations"> ATT&CK Mitigations</label>
                    <label><input type="radio" name="visualization-type" value="nist-controls" checked> NIST Controls</label>
                    <label><input type="radio" name="visualization-type" value="cis-safeguards"> CIS Safeguards</label>
                    <label><input type="radio" name="visualization-type" value="aws-capabilities"> AWS Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="gcp-capabilities"> GCP Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="azure-capabilities"> Azure Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="m365-capabilities"> M365 Capabilities</label>
                </div>

                <!-- Radial Tree Visualization Container -->
                <div id="radial-tree-container" class="w-full h-96 border border-gray-300 rounded bg-white"></div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>
            </div>

            <!-- Step 5: CDM View -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">CDM View</h3>
                <p class="text-sm text-gray-600 mb-4">Visualize categories, techniques, and selected controls/capabilities.</p>
            
                <!-- (1) Controls/Capabilities Checkboxes -->
                <div id="cdm-capability-filters" class="mb-4">
                <label><input type="checkbox" name="cdmFilters" value="mitigations"> ATT&CK Mitigations</label>
                <label><input type="checkbox" name="cdmFilters" value="nist-controls"> NIST 800-53r5</label>
                <label><input type="checkbox" name="cdmFilters" value="cis-safeguards"> CIS Controls</label>
                <label><input type="checkbox" name="cdmFilters" value="aws-capabilities"> AWS Capabilities</label>
                <label><input type="checkbox" name="cdmFilters" value="gcp-capabilities"> GCP Capabilities</label>
                <label><input type="checkbox" name="cdmFilters" value="azure-capabilities"> Azure Capabilities</label>
                <label><input type="checkbox" name="cdmFilters" value="m365-capabilities"> M365 Capabilities</label>
                </div>
            
                <!-- (2) CDM Matrix Container -->
                <div id="cdm-matrix-container" class="overflow-auto">
                <!-- The dynamic matrix layout (like ATT&CK Shuffle) goes here -->
                </div>
            </div>
   

            <!-- Step 6: Organization Details -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Organization Details</h3>
                <p class="text-sm text-gray-600 mb-2">Define your organization's security practices.</p>

                <div id="organization-details">
                    <label class="block mt-2">
                        <input type="checkbox" id="ai_automation" class="mr-2">
                        AI & Automation for Information Security
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_security_staff" class="mr-2">
                        Cybersecurity Training for Security Staff
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_all_employees" class="mr-2">
                        Cybersecurity Training for All Employees
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="incident_response_testing" class="mr-2">
                        Conduct Incident Response Tests
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="law_enforcement_ransomware" class="mr-2">
                        Engage Law Enforcement for Ransomware
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="data_encryption" class="mr-2">
                        Encrypt Stored Data (Beyond Disk Encryption)
                    </label>
                </div>
            </div>

            <!-- Step 7: Attack Analysis -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Attack Analysis</h3>
                <p class="text-sm text-gray-600 mb-4">Run simulations and generate a Sankey diagram.</p>
            
                <!-- [A] Input for # of iterations -->
                <label class="block mt-2">
                Number of iterations:
                <input type="number" id="attackAnalysisIterations" value="1000" min="1" class="border p-2 w-full" />
                </label>
            
                <!-- [B] Single-Select Radio Buttons for Controls/Capabilities -->
                <div id="analysis-control-selection" class="mt-4">
                <p class="text-sm font-semibold mb-2">Select one Controls/Capabilities set for Attack Analysis:</p>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="mitigations">
                    <span class="ml-1">ATT&CK Mitigations</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="nist-controls">
                    <span class="ml-1">NIST 800-53r5 Controls</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="cis-safeguards">
                    <span class="ml-1">CIS Safeguards</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="aws-capabilities">
                    <span class="ml-1">AWS Capabilities</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="azure-capabilities">
                    <span class="ml-1">Azure Capabilities</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="gcp-capabilities">
                    <span class="ml-1">GCP Capabilities</span>
                </label>
                <label class="inline-flex items-center mr-4">
                    <input type="radio" name="analysis-control-option" value="m365-capabilities">
                    <span class="ml-1">M365 Capabilities</span>
                </label>
                </div>
            
                <!-- [C] Button to start the analysis -->
                <button type="button" id="run-attack-analysis" class="bg-green-500 text-white px-4 py-2 rounded mt-4">
                Run Attack Analysis
                </button>
            
                <!-- (C) A container for the final tables or any textual output (optional) -->
                <div id="attackAnalysisResults" class="mt-4"></div>
            
                <!-- (D) Container for the Sankey diagram -->
                <div id="sankey-diagram-container" class="mt-4" style="width: 800px; height: 600px;"></div>

                <!-- This container holds the Risk Flow Table -->
                <div id="riskFlowTableContainer" class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Risk Flow Details</h4>
                    <table id="riskFlowTable" class="table-auto w-full border-collapse border border-gray-300">
                    <thead class="bg-gray-200">
                        <tr>
                        <th class="border px-4 py-2">Segment</th>
                        <th class="border px-4 py-2">Value</th>
                        </tr>
                    </thead>
                    <tbody id="riskFlowTableBody">
                        <!-- Rows will be inserted by JS -->
                    </tbody>
                    </table>
                </div>                
            </div>
  
        </form>

        <!-- JSON Output -->
        <pre id="json-output" class="bg-gray-100 text-black p-4 rounded mt-4" style="display: none;"></pre>
    </div>
    <script>

        // Target JSON structure for modelInstances asset-type-instances:
        // {
        //     "asset-category": "devices", // user input, radio button selection enum is the unique array of values from capabilities.capability_group where capabilities.type = "asset-type"
        //     "asset-type": "Linux Server OS", // user input, drop-down selection enum is the unique array of values from capabilities.capability_id where capabilities.type = "asset-type"
        //     "environment": "AWS", // from user input, enum ["AWS", "GCP", "Azure", "M365"]
        //     "record-count": "500-2k", // "record-count" is only present if "asset-category" is "data", from user drop-down selection; enum ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"]
        //     "monitoring-coverage": { // from user input, enum ["None", "Low", "Medium", "High"]
        //         "network-monitoring": "High",
        //         "process-monitoring": "Medium",
        //         "file-monitoring": "Low",
        //         "cloud-monitoring": "None",
        //         "hardware-monitoring": "None"
        //     },
            // "abusedByTechniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "abused-by"
            //     "T1001": { // from capabilities.[].attack_object_id where capabilities.[].capability_id = asset-type for this record, capabilities.[].record_type = "asset-type" and capabilities.[].mapping_type = "abused-by"
            //         "technique_name": "Data Obfuscation", // from attack store
            //         "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
            //         "data-sources": [], // from the attack store
            //         "nist-controls": [], // from capabilities where record_type is "nist-controls"
            //         "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
            //         "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
            //         "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
            //         "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
            //         "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
            //         "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
            //         "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
            //         "attack-score": 0.5 // float to the tenthousandths; attack-score = initial-score * (1 + weightSum)
            //     }
            // },
        //     "targetedByTechniques": { // contextualized technique objects for each unique technique mapped to the asset type where mapping_type = "targeted-by"
            //     "T1002": { // one technique record per attack_object_id found in the mapex files
            //         "technique_name": "Data Compressed",
            //         "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
            //         "data-sources": [], // from the attack store
            //         "nist-controls": [], // from capabilities where record_type is "nist-controls"
            //         "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
            //         "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
            //         "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
            //         "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
            //         "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
            //         "mitigations": {}, // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
            //         "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
            //         "attack-score": 0.5265 // float to the tenthousandths; attack-score = initial-score * (1 + weightSum)
            //     }
            // }
        // }
        // // from STIX, external_references.[].external_id where "type": "attack-pattern"
        // target json structure for techniques records: 
        // {
        //     "technique_id": "T1001", // one technique record per attack_object_id 
        //     "technique_name": "Data Compressed", // from "attack" store where type="attack-pattern" and external_references.[].external_id=technique_id, get name
        //     "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score, calc_detections], // from staticVariables and attack stores
        //     "data-sources": [], // from the attack store
        //     "nist-controls": [], // from capabilities where record_type is "nist-controls"
        //     "cis-safeguards": [], // from capabilities where record_type is "cis-safeguards"
        //     "aws-capabilities": [], // from capabilities where record_type is "aws-capabilities"
        //     "gcp-capabilities": [], // from capabilities where record_type is "gcp-capabilities"
        //     "azure-capabilities": [], // from capabilities where record_type is "azure-capabilities"
        //     "m365-capabilities": [], // from capabilities where record_type is "m265-capabilities"
        //     "mitigations": [], // from attack store, for the object where type = "attack-pattern" and external_references.[].external_id = technique_id of this object, get id; for each object where type="relationship" and target_ref = id, get source_ref; for each object where type="course-of-action" and id = source_ref, get external_references.[].external_id
        //     "monitoring-coverage-eval": [ "process", "network", "file", "cloud", "hardware" ], // each monitoring coverage category is present if keys from weight-keywords.json where that category is the value are present in "data-sources" mapped to that technique
        //     "initial-score": 0.5 // initialScore = prevalenceScore + chokepointScore + actionabilityScore
        // }
        //
        //
        function initShuffleDb() {
            const db = new Dexie("shuffledb");
            db.version(1).stores({
                modelInstances: "++id, record_type, assetCategory, assetType, environment, monitoringCoverage, recordCount, abusedByTechniques, targetedByTechniques", // tracks all info about asset type instances selected by the user
                techniques: "++id, technique_id, technique_name, monitoring_coverage_eval, data_sources, nist_controls, cis_safeguards, aws_capabilities, gcp_capabilities, azure_capabilities, m365_capabilities, mitigations", // imported from assetType files
                capabilities: "++id, record_type, capability_group, capability_id, capability_description, mapping_type, attack_object_id, attack_object_name", // imported from MAPEX files and CIS_safeguard_to_technique.json file
                staticVariables: "++id, record_type", // imported from static-variables.json and weight-keywords.json, if from static-variables.json, record_type = "static", if from weight-keywords.json, record_type = "keyword", if from attack-prev-tid.json, record_type = "calc"
                attack: "&id, type, record_type" // imported from enterprise-attack.json "objects" array
            });
            db.open().catch((err) => {
                console.error("Failed to open db:", err);
            }); 
            return db;
        }    
        
        const filesArr = [
            { file: "static-variables.json", format: "json", store: "staticVariables", record_type: "static", import_from: "." },
            { file: "weight-keywords.json", format: "json", store: "staticVariables", record_type: "keyword", import_from: "." },
            { file: "attack-prev-tid.json", format: "json", store: "staticVariables", record_type: "calc", import_from: "." },
            { file: "enterprise-attack.json", format: "stix", store: "attack", record_type: "attack_objects", import_from: "objects" },
            { file: "cis_safeguard_to_techniques.json", format: "json", store: "capabilities", record_type: "cis_safeguards", import_from: "." },
            { file: "enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects"},
            { file: "enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json", format: "mapex", store: "capabilities", record_type: "asset_types", import_from: "mapping_objects" },
            { file: "nist_800_53-rev5_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "nist_controls", import_from: "mapping_objects" },
            { file: "m365-12.11.2023_attack-14.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "m365_capabilities", import_from: "mapping_objects" },
            { file: "gcp-06.28.2022_attack-10.0-enterprise.json", format: "mapex", store: "capabilities", record_type: "gcp_capabilities", import_from: "mapping_objects" },
            { file: "azure-06.29.2021_attack-8.2-enterprise.json", format: "mapex", store: "capabilities", record_type: "azure_capabilities", import_from: "mapping_objects" },
            { file: "aws-12.12.2024_attack-16.1-enterprise.json", format: "mapex", store: "capabilities", record_type: "aws_capabilities", import_from: "mapping_objects" }
        ];

        /**
         * Fetches a single JSON file, extracts the relevant data, sets the record_type,
         * and bulk puts them into the specified store. Logs start and finish messages.
         *
         * @param {Dexie} db      - The Dexie database instance.
         * @param {Object} fileDef  - An object describing how to import the file.
         *    @property {string} file         - The file name to fetch (e.g. "static-variables.json")
         *    @property {string} format       - The file format (e.g. "json", "stix", "mapex")
         *    @property {string} store        - The Dexie store name (e.g. "staticVariables")
         *    @property {string} record_type  - The record_type to inject into each object
         *    @property {string} import_from  - The property name in the JSON (".", "objects", "mapping_objects")
         */
        async function importSingleJsonFile(db, fileDef) {
        try {
            // Log start
            console.log(`Starting import: ${fileDef.file}`);
            addLogMessage(`Starting import: ${fileDef.file}`);

            // 1) Fetch the JSON
            const response = await fetch(fileDef.file);
            if (!response.ok) {
            throw new Error(`Failed to fetch ${fileDef.file}: ${response.statusText}`);
            }
            let data = await response.json();

            // 2) Based on import_from, extract the array of objects we want to import
            let recordsToImport = [];
            if (fileDef.import_from === ".") {
            // Could be an array or object at the root
            if (Array.isArray(data)) {
                recordsToImport = data;
            } else if (typeof data === "object") {
                // If the data is an object, you might push it as a single record,
                // or handle however your format requires. Example:
                recordsToImport = [data];
            }
            } else {
            // e.g. "objects", "mapping_objects"
            if (!data[fileDef.import_from]) {
                console.warn(`Property "${fileDef.import_from}" not found in ${fileDef.file}`);
                recordsToImport = [];
            } else {
                // if data[fileDef.import_from] is an array, use it directly
                // if it’s an object, put that in an array, etc.
                const subData = data[fileDef.import_from];
                recordsToImport = Array.isArray(subData) ? subData : [subData];
            }
            }

            // 3) If format is "mapex" or "stix", you might do additional parsing
            //    For example, STIX might store an array in "objects".
            //    But in this example, we rely purely on import_from to find the array
            //    so you can simply rely on the logic above.

            // 4) For each object, inject the record_type from fileDef.
            recordsToImport.forEach(obj => {
            obj.record_type = fileDef.record_type;
            });

            // 5) Bulk put into the specified store.
            //    Dexie’s .bulkPut() will handle either an empty array or large arrays.
            if (recordsToImport.length > 0) {
            await db[fileDef.store].bulkPut(recordsToImport);
            }

            // Log finish, show how many objects were imported
            console.log(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);
            addLogMessage(`Finished import: ${fileDef.file} => ${recordsToImport.length} records added.`);

        } catch (err) {
            console.error(`Error importing ${fileDef.file}:`, err);
            addLogMessage(`Error importing ${fileDef.file}: ${err.message}`);
        }
        }

        /**
         * Utility function to append messages to the #loading-logs element on the page.
         *
         * @param {string} message - The log message to display.
         */
        function addLogMessage(message) {
        const logsEl = document.getElementById("loading-logs");
        if (!logsEl) {
            console.warn("No element with id='loading-logs' found.");
            return;
        }
        const newLine = document.createElement("div");
        newLine.textContent = message;
        logsEl.prepend(newLine);
        }


        // Run the function when the page loads
        document.addEventListener("DOMContentLoaded", async () => {
            const db = initShuffleDb();
            await runInitializationSequence(db)
            showStep(0);

            // set dark mode
            // const savedMode = await getObjectById(db, "settings", "darkMode");
            // if (savedMode) {
            // document.body.classList.toggle("dark", savedMode.value === "dark");
            // }

            // // populate environment dropdown
            // populateEnvironmentSelection();

            // // populate record count dropdown
            // populateRecordCountSelection();

            // //populate monitoring coverage radio sets
            // populateMonitoringCoverageSelections();

            // set event listeners
            // Listen for user selecting an asset category radio button
            document.querySelectorAll("#asset-category-container input[type='radio']")
            .forEach(radio => {
                radio.addEventListener("change", async (e) => {
                    const selectedCategory = e.target.value; // e.g. "devices", "data"
                    // If you have db loaded, call:
                    await populateAssetTypeDropdown(db, selectedCategory);

                    // Optionally show/hide record count selection if category="data"
                    const recordCountDiv = document.getElementById("record-count-selection");
                    if (selectedCategory === "data") {
                    recordCountDiv.style.display = "block";
                    } else {
                    recordCountDiv.style.display = "none";
                    }

                    // You can also show environment-selection and monitoring-selection by default
                    document.getElementById("environment-selection").style.display = "block";
                    document.getElementById("monitoring-selection").style.display = "block";
                });
            });
            // listen for user to select a different visualization-type for radial tree diagram
            document.querySelectorAll('input[name="visualization-type"]').forEach(radio => {
                radio.addEventListener("change", () => {
                    generateRadialTree();
                });
            });

            document.querySelectorAll('#cdm-capability-filters input[type="checkbox"]')
                .forEach(cb => {
                    cb.addEventListener('change', () => renderCdmView(db));
                });
            document.getElementById("run-attack-analysis").addEventListener("click", async () => {
                await runAttackAnalysis();
            });
        });
    
        /**
         * getObjectById
         * 
         * Retrieves a single record from the specified Dexie store by its primary key.
         * In the example call, we do: getObjectById("settings", "darkMode"),
         * which looks up the record in the "settings" store with key="darkMode".
         *
         * @param {string} storeName - The name of the IndexedDB store, e.g. "settings".
         * @param {string} objectId  - The primary key to retrieve, e.g. "darkMode".
         * @returns {Promise<Object|null>} The matching record, or null if not found.
         */
        async function getObjectById(db, storeName, objectId) {
        try {
            // If you have a global 'db' already initialized, use that.
            // Otherwise, call initShuffleDb() here or pass the db as a parameter.
            return await db[storeName].get(objectId);
        } catch (error) {
            console.error(`Error in getObjectById(${storeName}, ${objectId}):`, error);
            return null;
        }
        }


        /*******************************************************
         * 1. Populate Asset Type Dropdown
         * 
         * - Queries Dexie capabilities store for records:
         *    record_type="asset-types" and capability_group = selectedCategory
         * - Fills the <select id="asset-type-dropdown"> with options.
         * - If none found, leaves a placeholder option.
         *******************************************************/
        async function populateAssetTypeDropdown(db, selectedCategory) {
        const assetTypeDropdown = document.getElementById("asset-type-dropdown");
        if (!assetTypeDropdown) return;

        // Clear existing options
        assetTypeDropdown.innerHTML = "";

        // If no category is selected, disable and show placeholder
        if (!selectedCategory) {
            assetTypeDropdown.disabled = true;
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select an asset category first";
            assetTypeDropdown.appendChild(placeholder);
            return;
        }

        // Query Dexie for asset-type records
        const entries = await db.capabilities
            .where("record_type").equals("asset_types")
            .and(c => c.capability_group === selectedCategory)
            .toArray();

        // If we found none, show a “No Asset Types Available” option
        if (!entries.length) {
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = `No asset types found for ${selectedCategory}`;
            assetTypeDropdown.appendChild(placeholder);
            assetTypeDropdown.disabled = true;
            return;
        }

        // Otherwise populate
        assetTypeDropdown.disabled = false;
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select an asset type";
        assetTypeDropdown.appendChild(placeholder);

        // Each entry’s capability_id is the name
        // Some categories might have duplicates, so we can deduplicate in a Set
        const seen = new Set();
        entries.forEach(entry => {
            if (entry.capability_id && !seen.has(entry.capability_id)) {
            seen.add(entry.capability_id);
            const opt = document.createElement("option");
            opt.value = entry.capability_id;
            opt.textContent = entry.capability_id;
            assetTypeDropdown.appendChild(opt);
            }
        });
        }

        /*******************************************************
         * 2. Populate Environment Dropdown
         * 
         * Populates <select id="environment-dropdown"> with:
         *   "AWS", "Azure", "GCP", "M365"
         *******************************************************/
        function populateEnvironmentSelection() {
        const envDropdown = document.getElementById("environment-dropdown");
        if (!envDropdown) return;

        envDropdown.innerHTML = "";
        const environments = ["AWS", "Azure", "GCP", "M365"];
        environments.forEach(env => {
            const opt = document.createElement("option");
            opt.value = env;
            opt.textContent = env;
            envDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 3. Populate Record Count Selection
         * 
         * Populates <select id="record-count-dropdown"> with:
         *   "<500", "500-2k", "2k-10k", "10k-100k", ">100k"
         * 
         * Only displayed if the selected asset category = "data"
         *******************************************************/
        function populateRecordCountSelection() {
        const recordCountDropdown = document.getElementById("record-count-dropdown");
        if (!recordCountDropdown) return;

        recordCountDropdown.innerHTML = "";
        const recordCounts = ["<500", "500-2k", "2k-10k", "10k-100k", ">100k"];
        recordCounts.forEach(count => {
            const opt = document.createElement("option");
            opt.value = count;
            opt.textContent = count;
            recordCountDropdown.appendChild(opt);
        });
        }

        /*******************************************************
         * 4. Populate Monitoring Coverage Selections
         * 
         * For each of:
         *   #network-monitoring
         *   #process-monitoring
         *   #file-monitoring
         *   #cloud-monitoring
         *   #hardware-monitoring
         * Provide a set of radio buttons (or a <select>) for:
         *   "High", "Medium", "Low", "None"
         *******************************************************/
        function populateMonitoringCoverageSelections() {
        const coverageLevels = ["High", "Medium", "Low", "None"];

        // Helper to build radio group or dropdown inside a container
        function buildCoverageRadios(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ""; // clear existing

            const labelText = container.dataset.label || containerId;
            const labelEl = document.createElement("div");
            labelEl.classList.add("font-semibold", "mb-1");
            labelEl.textContent = labelText;
            container.appendChild(labelEl);

            coverageLevels.forEach(level => {
            const wrapper = document.createElement("label");
            wrapper.classList.add("inline-flex", "items-center", "mr-3");

            const input = document.createElement("input");
            input.type = "radio";
            input.name = containerId; // so all are in one group
            input.value = level;
            input.classList.add("mr-1");

            wrapper.appendChild(input);
            wrapper.appendChild(document.createTextNode(level));
            container.appendChild(wrapper);
            });
        }

        // Build coverage for each ID
        buildCoverageRadios("network-monitoring");
        buildCoverageRadios("process-monitoring");
        buildCoverageRadios("file-monitoring");
        buildCoverageRadios("cloud-monitoring");
        buildCoverageRadios("hardware-monitoring");
        }

        // re‑render the AssetTypeInstancesTable in Step 2 each time you insert a new asset‑type‑instance record into modelInstances store
        async function refreshAssetTypeInstancesTable(db) {
            const tableBody = document.getElementById("asset-type-instances-body");
            tableBody.innerHTML = "";

            // Get all asset-type-instance records from Dexie
            const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray(); 
                // Or adapt if you’re labeling them differently
            console.log("refreshAssetTypeInstancesTable allInstances:", allInstances)
            allInstances.forEach(instance => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                <td class="border border-gray-300 px-4 py-2">${instance.environment || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-category"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">${instance["asset-type"] || ""}</td>
                <td class="border border-gray-300 px-4 py-2">
                    ${JSON.stringify(instance["monitoring-coverage"] || {})}
                </td>
                <td class="border border-gray-300 px-4 py-2">${instance["record-count"] || ""}</td>
                `;
                tableBody.appendChild(tr);
            });
        }

    


        // Function to Handle Navigation Between Steps
        let currentStep = 0;
        const steps = document.querySelectorAll(".form-step");
        const nextButton = document.getElementById("next-step");
        const prevButton = document.getElementById("prev-step");
        const progressItems = document.querySelectorAll(".progress-bar li");

        // Function to update steps
        function showStep(step) {
            // Hide all steps and remove active class
            steps.forEach((el, index) => {
                el.classList.toggle("active", index === step);
                el.style.display = index === step ? "block" : "none";
            });

            // Update progress bar
            progressItems.forEach((el, index) => {
                el.classList.toggle("active", index === step);
            });

            // Hide back button on first step
            prevButton.classList.toggle("hidden", step === 0);

            // Change "Next" button to "Finish" on the last step
            nextButton.innerText = step === steps.length - 1 ? "Finish" : "Next";
        }

        // Function to Hide the Techniques Table and JSON Output
        function hideDynamicElements() {
            document.getElementById("techniques-container").classList.add("hidden");
            document.getElementById("json-output").style.display = "none";
        }

        // Next Button Click Event
        nextButton.addEventListener("click", async () => {
            const db = await initShuffleDb();
            const modelDefinition = {
                organization_attributes: {}
            };
            if (currentStep < steps.length - 1) {
                
                if (currentStep === 0) {
                    
                }
                if (currentStep === 1) {
                    // ✅ Only recalculate if scores do not exist
                    // const scoresExist = modelDefinition.asset_types.some(asset => asset.attack_scores?.length > 0);
                    // if (!scoresExist) {
                    //     await calculateAllTechniqueScores();
                    // }
                    //updateModelDisplay();
                    generateModelSummaryTable(db);
                }
                if (currentStep === 2) {
                    // ✅ Wait for JSON files to be fully loaded before updating model
                    // if (!jsonCache.nistMapping || !jsonCache.enterpriseAttack) {
                    //     console.error("❌ Error: Required JSON files not loaded.");
                    //     showToast("Error: Required JSON files not loaded.", "error");
                    //     return;
                    // }
                    generateRadialTree();
                }
                if (currentStep === 4) {
                    await renderCdmView(db);
                }
                if (currentStep === 5) {
                    buildOrganizationAttributes(modelDefinition);
                }
                if (currentStep === 6) {
                    
                }

                currentStep++;
                showStep(currentStep);
                hideDynamicElements();
            } else {
                alert("Form Submitted!"); // Replace this with actual form submission logic
            }
        });

        // Back Button Click Event
        prevButton.addEventListener("click", () => {
            if (currentStep > 0) {
                currentStep--;
                showStep(currentStep);
                hideDynamicElements();
                updateModelDisplay(); 
            }
        });
   
        // Dark Mode Toggle
        async function toggleDarkMode() {
            const body = document.body;
            body.classList.toggle("dark");
            const mode = body.classList.contains("dark") ? "dark" : "light";
            await storeObject("settings", { key: "darkMode", value: mode });
        }

        // function to build json representation of model with selected asset-type-instance records and users' responses to organizational attributes
        async function buildModelJson() {

        }
    
        // JSON Export & Download
        async function exportModelAsJSON() {
            const techniques = await getAllObjects("techniques");
            const blob = new Blob([JSON.stringify(techniques, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "model-data.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    
        document.getElementById("download-json").addEventListener("click", exportModelAsJSON);

        // Function to Build Organization Attributes from Checkboxes
        function buildOrganizationAttributes(modelDefinition) {
            document.querySelectorAll("#organization-details input[type='checkbox']").forEach(input => {
                modelDefinition.organization_attributes[input.id] = input.checked;  // ✅ Ensure proper assignment
            });

            // console.log("Saved Organization Attributes:", modelDefinition.organization_attributes);
        }

        // Function to Update and Display Model Definition JSON
        function updateModelDisplay() {
            const jsonOutput = document.getElementById("json-output");
            jsonOutput.textContent = JSON.stringify(modelDefinition, null, 4);
        }
    
        document.getElementById("view-model-definition").addEventListener("click", () => {
            const jsonOutput = document.getElementById("json-output");

            // Toggle visibility
            if (jsonOutput.style.display === "none" || jsonOutput.style.display === "") {
                jsonOutput.style.display = "block";  // Show JSON
            } else {
                jsonOutput.style.display = "none";   // Hide JSON
            }
        });

        // Function to generate a table showing the asset-type-instance records and the average ATT&CK score for each
        async function generateModelSummaryTable(db) {
            const tableBody = document.getElementById("model-summary-body");
            tableBody.innerHTML = "";

            // 1) Query Dexie for all asset-type-instance records
            const allAssetInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray();

            // 2) Loop through each asset and compute summary
            for (const asset of allAssetInstances) {
                // Assume the attack scores are stored in a property "attack_scores"
                // Adjust if you store them differently (e.g. "abused-by-techniques")
                const abusedArr = asset.abusedByTechniques
                    ? Object.values(asset.abusedByTechniques)
                    : [];

                    // Similarly for targetedByTechniques
                    const targetedArr = asset.targetedByTechniques
                    ? Object.values(asset.targetedByTechniques)
                    : [];
                const techniques = [...abusedArr, ...targetedArr] || [];
                // console.log("techniques array: ", techniques)

                const avgScore = techniques.length
                    ? (
                        techniques.reduce((sum, t) => sum + parseFloat(t["attack-score"] || 0), 0) / techniques.length
                    ).toFixed(4)
                    : "N/A";

                // 3) Create row
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${asset.environment || ""}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset["asset-category"] || ""}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset["asset-type"] || ""}</td>
                    <td class="border border-gray-300 px-4 py-2 text-blue-500 cursor-pointer">
                        ${techniques.length} techniques (Avg Score: ${avgScore})
                    </td>
                `;

                // 4) Pass asset type name (or ID) into your detail function
                row.querySelector("td:last-child").addEventListener("click", () => {
                    displayTechniquesTable(asset["asset-type"]);
                });

                tableBody.appendChild(row);
            }
        }



        // function to create a table showing the ATT&CK techniques for a given asset type and the ATT&CK score for each technique
        async function displayTechniquesTable(assetTypeName) {
            const db = await initShuffleDb();
            const tableBody = document.getElementById("techniques-body");
            tableBody.innerHTML = "";

            document.getElementById("selected-asset-type").textContent = assetTypeName;
            document.getElementById("techniques-container").classList.remove("hidden");

            // 1) Fetch this asset-instance from Dexie
            const assetRecord = await db.modelInstances
                .where("record_type").equals("asset-type-instance")
                .and(x => x["asset-type"] === assetTypeName)
                .first(); // or .toArray() if you expect multiple

            if (!assetRecord) {
                console.error(`No asset instance found for asset-type '${assetTypeName}' in Dexie.`);
                return;
            }

            // 2) Extract technique data
            const abusedByTechniques = assetRecord.abusedByTechniques 
                ? Object.entries(assetRecord.abusedByTechniques)
                : [];
            const targetedByTechniques = assetRecord.targetedByTechniques
            ? Object.entries(assetRecord.targetedByTechniques)
            : [];            
            const techniques = [...abusedByTechniques, ...targetedByTechniques]

            // // Getting the technique key (e.g., "T1002")
            // const techniqueId = Object.keys(techniques)[0]; // "T1002"

            // // Getting the values inside the object
            // const techniqueDetails = techniques[techniqueId];

            // // Extracting specific values
            // const techniqueName = techniqueDetails["technique_name"]; // "Data Compressed"
            // const attackScore = techniqueDetails["attack-score"]; // 0.5265

            // 3) Build table rows
            // for (const [techniqueId, details] of Object.entries(techniques)) {
                for (const [techniqueId, details] of techniques) {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${techniqueId}</td>
                    <td class="border border-gray-300 px-4 py-2">${details["technique_name"]}</td>
                    <td class="border border-gray-300 px-4 py-2">${details["attack-score"]}</td>
                `;
                tableBody.appendChild(row);
            };
        }


        function getCoverageValue(id) {
            // This grabs the checked radio button in the container with `id`
            const checkedRadio = document.querySelector(`#${id} input[type="radio"]:checked`);
            // If none is checked, default to "" or "None"
            return checkedRadio ? checkedRadio.value : "None";
        }

        document.getElementById("submit-asset-type").addEventListener("click", async () => {
            const assetTypeName = document.getElementById("asset-type-dropdown").value;
            const environment   = document.getElementById("environment-dropdown").value;
            const selectedCategory = document.querySelector('input[name="asset-category"]:checked').value;
            const selectedNetworkCoverage   = getCoverageValue("network-monitoring");
            const selectedProcessCoverage   = getCoverageValue("process-monitoring");
            const selectedFileCoverage      = getCoverageValue("file-monitoring");
            const selectedCloudCoverage     = getCoverageValue("cloud-monitoring");
            const selectedHardwareCoverage  = getCoverageValue("hardware-monitoring");

            //console.log("getCoverageValue:", assetTypeName, environment, selectedCategory, selectedProcessCoverage, selectedFileCoverage, selectedNetworkCoverage, selectedHardwareCoverage)
            
            // gather monitoring coverage inputs, e.g.:
            const coverage = {
                "network-monitoring": selectedNetworkCoverage,
                "process-monitoring": selectedProcessCoverage,
                "file-monitoring": selectedFileCoverage,
                "cloud-monitoring": selectedCloudCoverage,
                "hardware-monitoring": selectedHardwareCoverage
            };
            let recordCount;
            if (selectedCategory === "Data") {
                recordCount = parseInt(document.getElementById("record-count-dropdown").value, 100);
            }

            await updateModelValuesForAssetType(selectedCategory, assetTypeName, environment, coverage, recordCount);
            // Possibly show a success message or move to the next step.
        });

        /**
         * buildInMemoryCaches
         *
         * Fetches and stores large collections of STIX objects, relationships,
         * capabilities, and staticVariables in memory. This approach drastically
         * reduces repeated DB queries and allows parallel data retrieval.
         *
         * @param {Dexie} db - The Dexie database instance
         * @returns {Object}  An object containing caches:
         *   {
         *     allCapabilities,  // Array of all records in db.capabilities
         *     capabilityByTechnique, // Map<string, Array<object>> keyed by attack_object_id
         *     patternsMap,      // Map<string, object> keyed by techniqueId => STIX pattern object
         *     relationshipsMap, // Map<string, Array<object>> keyed by "target_ref" => array of "relationship" objects
         *     courseOfActionMap,// Map<string, object> keyed by "course-of-action" ID => STIX CoA object
         *     staticVarsAll     // Array of all staticVariables
         *     staticVarsCalc    // Map<string, object> keyed by techniqueId => the "calc" object
         *     monitoringKeywords // Array of keyword entries from staticVariables
         *   }
         */
        async function buildInMemoryCaches(db) {
        // We’ll do multiple fetches in parallel using Promise.all
        const [
            allCapabilities,
            allAttack,
            staticVarsAll
        ] = await Promise.all([
            db.capabilities.toArray(),
            db.attack.toArray(),
            db.staticVariables.toArray()
        ]);

        // 1) Build a quick lookup of capabilities by techniqueId
        //    e.g. capabilityByTechnique["T1001"] -> array of capabilities that have attack_object_id="T1001"
        const capabilityByTechnique = {};
        for (const cap of allCapabilities) {
            if (!cap.attack_object_id) continue;
            if (!capabilityByTechnique[cap.attack_object_id]) {
            capabilityByTechnique[cap.attack_object_id] = [];
            }
            capabilityByTechnique[cap.attack_object_id].push(cap);
        }

        // 2) Separate out STIX objects from the "attack" store
        //    We'll want to map:
        //      - "attack-pattern" by techniqueId
        //      - "relationship" by target_ref (for mitigations/detections)
        //      - "course-of-action" by ID
        const patternsMap = new Map();
        const relationshipsMap = new Map();  // e.g. relationshipsMap[patternId] => array of relationships
        const courseOfActionMap = new Map();

        for (const obj of allAttack) {
            if (obj.type === "attack-pattern" && Array.isArray(obj.external_references)) {
            // Find the external reference for "mitre-attack" to get the techniqueId
            const mitreRef = obj.external_references.find(r => r.source_name === "mitre-attack");
            if (mitreRef && mitreRef.external_id) {
                const techniqueId = mitreRef.external_id; // e.g. "T1001"
                patternsMap.set(techniqueId, obj);
            }
            } 
            else if (obj.type === "relationship") {
            // e.g. obj.target_ref might be "attack-pattern--abc123"
            if (!relationshipsMap.has(obj.target_ref)) {
                relationshipsMap.set(obj.target_ref, []);
            }
            relationshipsMap.get(obj.target_ref).push(obj);
            }
            else if (obj.type === "course-of-action") {
            // Store CoA in a map keyed by obj.id
            courseOfActionMap.set(obj.id, obj);
            }
        }

        // 3) Partition staticVariables by record_type
        const staticVarsCalc = {};
        const monitoringKeywords = [];
        for (const sv of staticVarsAll) {
            if (sv.record_type === "calc" && sv.attack_object_id) {
            // e.g. staticVarsCalc["T1001"] = that record
            staticVarsCalc[sv.attack_object_id] = sv;
            } else if (sv.record_type === "keyword") {
            // e.g. for coverage eval
            monitoringKeywords.push(sv);
            }
        }

        return {
            allCapabilities,
            capabilityByTechnique,
            patternsMap,
            relationshipsMap,
            courseOfActionMap,
            staticVarsAll,
            staticVarsCalc,
            monitoringKeywords
        };
        }


        /**
         * createAllTechniques
         *
         * 1) Builds in-memory caches (patterns, relationships, capabilities, etc.).
         * 2) Gathers all unique technique IDs.
         * 3) Constructs technique records in parallel.
         * 4) bulkPut() them into db.techniques.
         *
         * @param {Dexie} db
         */
        async function createAllTechniques(db) {
            updateProgress("Starting createAllTechniques...");
            
            // 1) Build caches
            const {
                capabilityByTechnique,
                patternsMap,
                relationshipsMap,
                courseOfActionMap,
                staticVarsCalc,
                monitoringKeywords
            } = await buildInMemoryCaches(db);

            // 2) Gather all unique technique IDs from the capabilities
            const uniqueTechniqueIds = gatherUniqueTechniqueIds(capabilityByTechnique);
            console.log(`Found ${uniqueTechniqueIds.length} technique IDs.`);

            // 3) Build records in parallel using Promise.all
            const buildPromises = uniqueTechniqueIds.map(techId =>
                buildTechniqueRecord(
                techId,
                patternsMap,
                relationshipsMap,
                courseOfActionMap,
                capabilityByTechnique,
                staticVarsCalc,
                monitoringKeywords
                )
            );
            const techniqueRecords = await Promise.all(buildPromises);

            // Filter out any null or undefined records
            const validRecords = techniqueRecords.filter(r => r);

            // 4) Insert them into the "techniques" store
            if (validRecords.length) {
                await db.techniques.bulkPut(validRecords);
                console.log(`Created ${validRecords.length} techniques in the techniques store.`);
            } else {
                console.log("No techniques found to create.");
            }
        }


        /**
         * gatherUniqueTechniqueIds
         *
         * Extracts all unique technique IDs (like "T1001", "T1002") from the
         * capabilityByTechnique map built in memory.
         *
         * @param {Object} capabilityByTechnique - from buildInMemoryCaches
         * @returns {Array<string>}
         */
        function gatherUniqueTechniqueIds(capabilityByTechnique) {
            // The keys of capabilityByTechnique are all technique IDs
            return Object.keys(capabilityByTechnique);
        }

        /**
         * buildTechniqueRecord
         *
         * Builds the final technique object for a single techniqueId, using
         * in-memory caches to gather the pattern object, mitigations, capabilities,
         * monitoring coverage, etc.
         *
         * @param {string} techniqueId            - e.g. "T1001"
         * @param {Map} patternsMap               - Map(techniqueId => attack-pattern object)
         * @param {Map} relationshipsMap          - Map(patternId => array of relationship objects)
         * @param {Map} courseOfActionMap         - Map(coaId => course-of-action object)
         * @param {Object} capabilityByTechnique  - { "T1001": [cap1, cap2], ... }
         * @param {Object} staticVarsCalc         - { "T1001": {calc_tid_before, calc_tid_after, calc_prev_score}, ...}
         * @param {Array} monitoringKeywords      - array of { key, value } records for coverage
         * @returns {Object|null} The final technique record, or null if no valid pattern found
         */
        async function buildTechniqueRecord(
            techniqueId,
            patternsMap,
            relationshipsMap,
            courseOfActionMap,
            capabilityByTechnique,
            staticVarsCalc,
            monitoringKeywords
            ) {
            // 1) Find the STIX pattern object for this technique
            const patternObj = patternsMap.get(techniqueId);
            if (!patternObj) {
                console.warn(`No attack-pattern found for ${techniqueId}`);
                return null;
            }

            const patternId = patternObj.id; // e.g. "attack-pattern--abc123"
            const technique_name = patternObj.name || techniqueId;
            const dataSources = patternObj.x_mitre_data_sources || [];
            const technique_url = getMitreUrlFromPattern(patternObj, techniqueId);

            // 2) Gather mitigations and detection count from the relationshipsMap
            const { mitigations, detectionCount } = gatherMitigationsAndDetections(
                patternId,
                relationshipsMap,
                courseOfActionMap
            );

            // 3) Gather relevant capabilities for each record_type
            const { 
                nistControls, cisSafeguards, awsCapabilities, 
                gcpCapabilities, azureCapabilities, m365Capabilities 
            } = gatherCapabilityIds(capabilityByTechnique[techniqueId] || []);

            // 4) Evaluate coverage
            const monitoringCoverageEval = buildMonitoringCoverageEval(monitoringKeywords, dataSources);

            // 5) Build prevEntry [calc_tid_before, calc_tid_after, calc_prev_score, detectionCount]
            const prevEntry = buildPrevEntry(staticVarsCalc[techniqueId], detectionCount);

            // 6) Calculate initial-score
            //    We assume computeChokepointFromValues/computeActionabilityScore might need
            //    in-memory "static config" if they used Dexie. For brevity, we show local stubs here.
            const [calc_tid_before, calc_tid_after, calc_prev_score] = prevEntry;
            const chokepointScore = computeChokepointFromValues(calc_tid_before, calc_tid_after);
            const actionabilityScore = computeActionabilityScore(
                nistControls.length,
                cisSafeguards.length,
                detectionCount
            );
            const prevalenceScore = parseFloat(calc_prev_score) || 0;
            const initialScore = parseFloat(
                (chokepointScore + actionabilityScore + prevalenceScore).toFixed(4)
            );

            // 7) Return final technique record
            return {
                technique_id: techniqueId,
                technique_url,
                technique_name,
                prevEntry,
                data_sources: dataSources,
                nist_controls: nistControls,
                cis_safeguards: cisSafeguards,
                aws_capabilities: awsCapabilities,
                gcp_capabilities: gcpCapabilities,
                azure_capabilities: azureCapabilities,
                m365_capabilities: m365Capabilities,
                mitigations,
                monitoring_coverage_eval: monitoringCoverageEval,
                initial_score: initialScore
            };
        }


        /************************************************************
         * Helper: Check if STIX object has external_references
         * with source_name="mitre-attack" and external_id=techniqueId
         ************************************************************/
        function hasExternalReference(obj, sourceName, techniqueId) {
        if (!obj.external_references || !Array.isArray(obj.external_references)) return false;
        return obj.external_references.some(ref =>
            ref.source_name === sourceName && ref.external_id === techniqueId
        );
        }

        /************************************************************
         * Helper: Extract the official MITRE Attack URL from the
         * patternObj’s external_references, specifically where
         * source_name="mitre-attack" and external_id=techniqueId.
         ************************************************************/
        function getMitreUrlFromPattern(patternObj, techniqueId) {
        if (!patternObj.external_references) return "";
        const ref = patternObj.external_references.find(r =>
            r.source_name === "mitre-attack" && r.external_id === techniqueId
        );
        return ref && ref.url ? ref.url : "";
        }

        /**
         * gatherMitigationsAndDetections
         *
         * Reads the relationships for a single patternId from in-memory relationshipsMap,
         * returning an array of mitigations plus a detectionCount.
         *
         * @param {string} patternId          - e.g. "attack-pattern--abc123"
         * @param {Map} relationshipsMap      - Map(patternId => array of relationship objs)
         * @param {Map} courseOfActionMap     - Map(coaId => course-of-action obj)
         * @returns {Object} { mitigations: Array, detectionCount: number }
         */
        function gatherMitigationsAndDetections(patternId, relationshipsMap, courseOfActionMap) {
        const rels = relationshipsMap.get(patternId) || [];
        const mitigations = [];
        let detectionCount = 0;

        for (const rel of rels) {
            if (rel.relationship_type === "mitigates") {
            // Then rel.source_ref should be a course-of-action ID
            const coa = courseOfActionMap.get(rel.source_ref);
            if (coa && Array.isArray(coa.external_references)) {
                const mitreRef = coa.external_references.find(r => r.source_name === "mitre-attack");
                const mitigation_id = mitreRef?.external_id || "";
                const mitigation_name = coa.name || "";
                mitigations.push({
                mitigation_id,
                mitigation_name
                });
            }
            } else if (rel.relationship_type === "detects") {
            // If there's a "detects" relationship, increment detectionCount
            detectionCount++;
            }
        }

        return { mitigations, detectionCount };
        }


        /**
         * gatherCapabilityIds
         *
         * For the given array of capability objects (all tied to a single techniqueId),
         * classify them by their record_type (nist_controls, cis_safeguards, etc.).
         *
         * @param {Array<object>} capsForTechnique - from capabilityByTechnique[techniqueId]
         * @returns {Object} e.g. {
         *   nistControls: [...],
         *   cisSafeguards: [...],
         *   awsCapabilities: [...],
         *   gcpCapabilities: [...],
         *   azureCapabilities: [...],
         *   m365Capabilities: [...]
         * }
         */
        function gatherCapabilityIds(capsForTechnique) {
        const nistControls = [];
        const cisSafeguards = [];
        const awsCapabilities = [];
        const gcpCapabilities = [];
        const azureCapabilities = [];
        const m365Capabilities = [];

        for (const cap of capsForTechnique) {
            if (cap.record_type === "nist_controls") {
            nistControls.push(cap.capability_id);
            } else if (cap.record_type === "cis_safeguards") {
            cisSafeguards.push(cap.capability_id);
            } else if (cap.record_type === "aws_capabilities") {
            awsCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "gcp_capabilities") {
            gcpCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "azure_capabilities") {
            azureCapabilities.push(cap.capability_id);
            } else if (cap.record_type === "m365_capabilities") {
            m365Capabilities.push(cap.capability_id);
            }
        }

        return {
            nistControls,
            cisSafeguards,
            awsCapabilities,
            gcpCapabilities,
            azureCapabilities,
            m365Capabilities
        };
        }


        /**
         * buildMonitoringCoverageEval
         *
         * For each (key, value) in monitoringKeywords (where record_type="keyword"),
         * if the technique's dataSources includes the key (case-insensitive),
         * we add the value (like "process", "network", etc.) to coverage set.
         *
         * @param {Array} monitoringKeywords - array of { key, value, record_type="keyword" }
         * @param {Array} dataSources        - from patternObj.x_mitre_data_sources
         * @returns {Array<string>} e.g. ["process", "file"]
         */
        function buildMonitoringCoverageEval(monitoringKeywords, dataSources) {
        if (!dataSources || !dataSources.length) return [];

        const coverage = new Set();
        const lowerSources = dataSources.map(ds => ds.toLowerCase());

        for (const kw of monitoringKeywords) {
            const theKey = (kw.key || "").toLowerCase();
            const theVal = kw.value || "";
            if (!theKey || !theVal) continue;

            // If any dataSource contains theKey substring
            if (lowerSources.some(ds => ds.includes(theKey))) {
            coverage.add(theVal);
            }
        }
        return Array.from(coverage);
        }


        /**
         * buildPrevEntry
         *
         * Returns [calc_tid_before, calc_tid_after, calc_prev_score, detectionCount].
         * If the user has "calc" info from staticVarsCalc, we parse them.
         *
         * @param {object} calcEntry     - e.g. { calc_tid_before, calc_tid_after, calc_prev_score }
         * @param {number} detectionCount
         * @returns {[number, number, number, number]} [before, after, prevScore, detectionCount]
         */
        function buildPrevEntry(calcEntry, detectionCount) {
        const before = parseFloat(calcEntry?.calc_tid_before) || 0;
        const after  = parseFloat(calcEntry?.calc_tid_after)  || 0;
        const prevScore = parseFloat(calcEntry?.calc_prev_score) || 0;

        return [before, after, prevScore, detectionCount];
        }


        /**
         * computeChokepointFromValues
         *
         * Example of a simplified function that uses constants (or a global config).
         * If you want to keep them dynamic, load them once and store in a config object.
         *
         * @param {number} tidBefore
         * @param {number} tidAfter
         * @returns {number} - a float in [0..1]
         */
        function computeChokepointFromValues(tidBefore, tidAfter) {
        // Example constants (replace with your real values).
        const beforeLower = 0;
        const beforeUpper = 1;
        const afterLower  = 0;
        const afterUpper  = 1;
        const wBefore1    = 1;
        const ratio       = 1;

        // 1. clamp helper
        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        // 2. scale and clamp
        const beforeClamped = clamp((tidBefore - beforeLower) / (beforeUpper - beforeLower), 0, 1);
        const afterClamped  = clamp((tidAfter  - afterLower ) / (afterUpper  - afterLower ), 0, 1);

        // 3. compute partial weight for "after"
        const wAfter1 = (wBefore1 / ratio) * (afterUpper - afterLower) / (beforeUpper - beforeLower);

        const weightBefore = wBefore1 / (wAfter1 + wBefore1);
        const weightAfter  = wAfter1  / (wAfter1 + wBefore1);

        // 4. combine
        return (weightBefore * beforeClamped) + (weightAfter * afterClamped);
        }


        /**
         * computeActionabilityScore
         *
         * Example function that uses local or globally cached constants instead
         * of repeatedly querying Dexie in a loop.
         *
         * @param {number} nistCount
         * @param {number} cisCount
         * @param {number} detectionCount
         * @returns {number} float in [0..1]
         */
        function computeActionabilityScore(nistCount, cisCount, detectionCount) {
        // Example placeholders:
        const mitigationsLowerCutoff = 0;
        const mitigationsUpperCutoff = 5;
        const detectionsLowerCutoff  = 0;
        const detectionsUpperCutoff  = 5;

        const wMiti1 = 1;
        const ratio  = 1;

        // 1. clamp
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // 2. mitigationsUtility
        const rawMiti = (nistCount + cisCount) - mitigationsLowerCutoff;
        const mitigationsUtility = clamp(rawMiti / (mitigationsUpperCutoff - mitigationsLowerCutoff), 0, 1);

        // 3. detectionsUtility
        const rawDetect = detectionCount - detectionsLowerCutoff;
        const detectionsUtility = clamp(rawDetect / (detectionsUpperCutoff - detectionsLowerCutoff), 0, 1);

        // 4. partial weight for detections
        const actionabilityWeightDetect1 = (wMiti1 / ratio) *
            (detectionsUpperCutoff - detectionsLowerCutoff) /
            (mitigationsUpperCutoff - mitigationsLowerCutoff);

        // 5. relative weights
        const actionabilityWeightMiti   = wMiti1 / (actionabilityWeightDetect1 + wMiti1);
        const actionabilityWeightDetect = actionabilityWeightDetect1 / (actionabilityWeightDetect1 + wMiti1);

        // 6. final score
        return (actionabilityWeightMiti * mitigationsUtility)
            + (actionabilityWeightDetect * detectionsUtility);
        }


        /************************************************************
         * USAGE (example)
         * ----------------------------------------------------------
         * const db = initShuffleDb();
         * await createAllTechniques(db);
         ************************************************************/


        //
        // Contextual Asset Type Construction
        //
        /*
        * IMPORTANT - Needs to be updated to use Dexie.js and new shuffledb schema
         * Builds a contextualized asset-type-instance object for each unique assetType found in your
         * MAPEX “assetTypeMappings” (devicesMappings, networksMappings, etc.) and enriches
         * them with the relevant technique data (prevEntry, data-sources, etc.).
         * 
         * Finally, writes them to the "contextualizedAssetTypes" store in IndexedDB,
         * keyed by a field "assetTypeId" (e.g. "Linux Server OS").
         */
        async function buildContextualAssetTypes() {
            try {
                const db = await initIndexedDB();

                // 1. Gather all assetTypeMappings from your MAPEX store(s).
                //    For example, if you've stored them in "devicesMappings", "networksMappings", etc.,
                //    you can fetch them all or you can unify them into a single store. 
                //    Here is a conceptual example of retrieving them:
                const storeNames = [
                "devicesMappings",
                "networksMappings",
                "applicationsMappings",
                "dataMappings",
                "identitiesMappings"
                ];

                // We'll gather them into a single array in memory
                let allAssetMappings = [];
                for (const storeName of storeNames) {
                // If these object stores exist, fetch everything
                if (db.objectStoreNames.contains(storeName)) {
                    const storeData = await getAllFromStore(db, storeName);
                    allAssetMappings = allAssetMappings.concat(storeData);
                }
                }

                // 2. Group assetTypeMappings by capability_id (e.g. "Linux Server OS").
                //    We'll create a dictionary: { "Linux Server OS": [ {capability_id..., attack_object_id..., ...}, ... ] }
                const groupedByAssetType = {};
                for (const entry of allAssetMappings) {
                const assetTypeName = entry.capability_id;    // e.g. "Linux Server OS"
                const assetCategory = entry.capability_group; // e.g. "devices"

                if (!groupedByAssetType[assetTypeName]) {
                    groupedByAssetType[assetTypeName] = {
                    assetCategory,
                    entries: [] // all technique mappings referencing this asset type
                    };
                }
                groupedByAssetType[assetTypeName].entries.push(entry);
                }

                // 3. For each unique asset type, build the final object shape:
                //    {
                //       assetTypeId: "Linux Server OS",
                //       "asset-category": "devices",
                //       "asset-type": "Linux Server OS",
                //       "model-values": {},  // We'll populate in Step 2 (Add Asset Type) 
                //       "techniques": { "T1001": {...}, "T1002": {...} }
                //    }
                const contextualAssetTypes = {};

                for (const [assetTypeName, info] of Object.entries(groupedByAssetType)) {
                const assetCategory = info.assetCategory;
                // Build the skeleton object
                const assetTypeObj = {
                    assetTypeId: assetTypeName,  // our unique keyPath
                    "asset-category": assetCategory,
                    "asset-type": assetTypeName,
                    "model-values": {}, 
                    "techniques": {}
                };

                // For each technique mapping referencing this asset type
                for (const mapping of info.entries) {
                    const techniqueId   = mapping.attack_object_id;   // e.g. "T1001"
                    const techniqueName = mapping.attack_object_name; // e.g. "Data Obfuscation"

                    // Build the partial technique object
                    // We'll call a helper "buildContextualTechniqueObject(techniqueId, techniqueName)" 
                    // that merges in STIX data (data-sources, mitigations, prevEntry, etc.).
                    // Or you can do it inline. For clarity, let's just call a helper:
                    const techniqueObj = await buildContextualTechniqueObject(techniqueId, techniqueName);

                    // Add it to the assetTypeObj
                    assetTypeObj.techniques[techniqueId] = techniqueObj;
                }

                contextualAssetTypes[assetTypeName] = assetTypeObj;
                }

                // 4. Write these new objects to the "contextualizedAssetTypes" store in a single transaction
                const txWrite = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = txWrite.objectStore("contextualizedAssetTypes");

                for (const [assetTypeName, assetTypeObj] of Object.entries(contextualAssetTypes)) {
                store.put(assetTypeObj);
                }

                await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
                });

                console.log("✅ Built contextual asset types and stored in 'contextualizedAssetTypes'.");
                return contextualAssetTypes;

            } catch (error) {
                console.error("Error in buildContextualAssetTypes:", error);
                return {};
            }
        };

        

        /**
         * Updates (or creates) an "asset-type-instance" record in the modelInstances store
         * when the user selects environment, coverage, and (optionally) record count.
         *
         * @param {string} assetCategory   e.g. "Data" or "Devices"
         * @param {string} assetTypeName   e.g. "Linux Server OS"
         * @param {string} environment     e.g. "AWS", "GCP", "Azure", "M365"
         * @param {Object} coverageObj     e.g. { "network-monitoring": "High", "process-monitoring": "Medium", ... }
         * @param {number} [recordCount]   only defined if assetCategory === "data"
         */
        async function updateModelValuesForAssetType(
        assetCategory,
        assetTypeName,
        environment,
        coverageObj,
        recordCount
        ) {
        try {
            // 1. Get or initialize your Dexie db
            const db = await initShuffleDb(); // or use a global `db` if you've already opened it

            // 2. Build the record in the shape your new schema expects
            //    We’ll store it as record_type="asset-type-instance"
            const newRecord = {
            record_type: "asset-type-instance",
            "asset-category": assetCategory,
            "asset-type": assetTypeName,
            environment: environment,
            "monitoring-coverage": coverageObj || {},
            };

            console.log("updateModelValuesForAssetType: ", newRecord)

            // Add recordCount if provided
            if (recordCount != null) {
            newRecord["record-count"] = recordCount;
            }
            console.log("updateModelValuesForAssetType: ", newRecord)
            // 3. Insert the record. Using add() will always make a new entry,
            //    while put() can "upsert" if you have a matching primary key.
            //    Because modelInstances has an auto-increment “++id”,
            //    we can just do add() for new entries:
            const instanceId = await db.modelInstances.add(newRecord);
            console.log("Created new modelInstance with ID:", instanceId);

            // 4. Now that the instance is created, build its technique objects
            await buildAssetTechniques(db, instanceId);

            // 5. Refresh any UI table that displays modelInstances
            await refreshAssetTypeInstancesTable(db);

        } catch (error) {
            console.error("Error in updateModelValuesForAssetType:", error);
        }
        }

        /**
         * buildAssetTechniques(db, instanceId)
         * 
         * 1) Retrieves the asset instance from db.modelInstances by its primary key (instanceId).
         * 2) Finds the relevant techniques for that asset-type via db.capabilities, grouped by mapping_type:
         *    - "abused-by"
         *    - "targeted-by"
         * 3) For each technique, fetches its expanded data from db.techniques (or uses your own function).
         * 4) Computes the final attack-score using the coverage from the asset instance.
         * 5) Attaches them to the record (abusedByTechniques, targetedByTechniques).
         * 6) Updates the record in db.modelInstances.
         */
        async function buildAssetTechniques(db, instanceId) {
            // 1) Retrieve the instance
            const instanceRecord = await db.modelInstances.get(instanceId);
            if (!instanceRecord) {
                console.error("No record found for instanceId:", instanceId);
                return;
            }

            // 2) We'll want to fetch the relevant capabilities for that asset-type
            const assetTypeName = instanceRecord["asset-type"];
            const coverageObj   = instanceRecord["monitoring-coverage"] || {};
            
            // Because we only want items that have `capability_id = assetTypeName` and record_type="asset_types"
            // Then we’ll group them by mapping_type. For example:
            const allCaps = await db.capabilities
                .where("record_type").equals("asset_types")
                .and(c => c.capability_id === assetTypeName)
                .toArray();

            // Group them into abused vs targeted
            const abusedCaps   = allCaps.filter(c => c.mapping_type === "abused-by");
            const targetedCaps = allCaps.filter(c => c.mapping_type === "targeted-by");

            // Build final object for each group
            const abusedByTechniques   = {};
            const targetedByTechniques = {};

            // 3) For each technique in abusedCaps, build the technique object
            for (const cap of abusedCaps) {
                const techniqueId = cap.attack_object_id; // e.g. "T1001"
                
                // 3.1) We can either fetch an existing record from db.techniques,
                //      or call your “buildTechniqueRecord” code directly. If you have a
                //      prepopulated 'techniques' store, do something like:
                const techniqueRecord = await db.techniques
                .where("technique_id")
                .equals(techniqueId)
                .first();

                if (!techniqueRecord) {
                console.warn("No technique record found in db.techniques for", techniqueId);
                continue;
                }

                // 3.2) Convert that record into the needed shape
                const newObj = {
                "technique_name": techniqueRecord.technique_name,
                "prevEntry": techniqueRecord.prevEntry || [0,0,0,0],
                "data-sources": techniqueRecord.data_sources || [],
                "nist-controls": techniqueRecord.nist_controls || [],
                "cis-safeguards": techniqueRecord.cis_safeguards || [],
                "aws-capabilities": techniqueRecord.aws_capabilities || [],
                "gcp-capabilities": techniqueRecord.gcp_capabilities || [],
                "azure-capabilities": techniqueRecord.azure_capabilities || [],
                "m365-capabilities": techniqueRecord.m365_capabilities || [],
                "mitigations": techniqueRecord.mitigations || [],
                "monitoring-coverage-eval": techniqueRecord.monitoring_coverage_eval || []
                // We'll add "attack-score" below
                };

                // 4) Compute the final attack-score for this technique
                //    techniqueRecord.initial_score is from your “buildTechniqueRecord”
                const initialScore = parseFloat(techniqueRecord.initial_score) || 0;
                const weightSum    = computeCoverageWeight(coverageObj, techniqueRecord.monitoring_coverage_eval);
                const attackScore  = parseFloat((initialScore * (1 + weightSum)).toFixed(4));

                newObj["attack-score"] = attackScore;

                // 5) Attach to abusedByTechniques (keyed by techniqueId)
                abusedByTechniques[techniqueId] = newObj;
            }

            // Similarly for "targeted-by"
            for (const cap of targetedCaps) {
                const techniqueId = cap.attack_object_id;
                // Same code as above
                const techniqueRecord = await db.techniques
                .where("technique_id")
                .equals(techniqueId)
                .first();

                if (!techniqueRecord) {
                console.warn("No technique record found in db.techniques for", techniqueId);
                continue;
                }

                const newObj = {
                "technique_name": techniqueRecord.technique_name,
                "prevEntry": techniqueRecord.prevEntry || [0,0,0,0],
                "data-sources": techniqueRecord.data_sources || [],
                "nist-controls": techniqueRecord.nist_controls || [],
                "cis-safeguards": techniqueRecord.cis_safeguards || [],
                "aws-capabilities": techniqueRecord.aws_capabilities || [],
                "gcp-capabilities": techniqueRecord.gcp_capabilities || [],
                "azure-capabilities": techniqueRecord.azure_capabilities || [],
                "m365-capabilities": techniqueRecord.m365_capabilities || [],
                "mitigations": techniqueRecord.mitigations || [],
                "monitoring-coverage-eval": techniqueRecord.monitoring_coverage_eval || []
                // We'll add "attack-score" below
                };

                const initialScore = parseFloat(techniqueRecord.initial_score) || 0;
                const weightSum    = computeCoverageWeight(coverageObj, techniqueRecord.monitoring_coverage_eval);
                const attackScore  = parseFloat((initialScore * (1 + weightSum))).toFixed(4);
                newObj["attack-score"] = attackScore;

                targetedByTechniques[techniqueId] = newObj;
            }

            // 6) Update the record with these new technique objects
            instanceRecord.abusedByTechniques   = abusedByTechniques;
            instanceRecord.targetedByTechniques = targetedByTechniques;

            await db.modelInstances.update(instanceId, {
                abusedByTechniques,
                targetedByTechniques
            });

            console.log("Updated instance with abusedByTechniques and targetedByTechniques for instanceId:", instanceId);
        }

        /**
         * computeCoverageWeight(coverageObj, coverageEval)
         *
         * coverageObj might look like:
         *   {
         *     "network-monitoring": "High",
         *     "process-monitoring": "Medium",
         *     "file-monitoring": "Low",
         *     "cloud-monitoring": "None",
         *     "hardware-monitoring": "None"
         *   }
         *
         * coverageEval might be an array of short coverage categories, e.g.: ["process", "network", "file"]
         *
         * hardcoding coverage factors for now.
         *
         * For each coverage domain in coverageEval, see if the coverageObj for that domain is nonzero,
         * and sum up the corresponding fraction. Return that sum as weightSum.
         */
        function computeCoverageWeight(coverageObj, coverageEval) {
            // mapping from "High"/"Medium"/"Low"/"None" to numeric fraction
            const coverageToFactor = {
                "High":   0.002,
                "Medium": 0.066,
                "Low":    0.132,
                "None":   0.198
            };

            let total = 0;

            // The technique might have "process", "network", "file", ...
            coverageEval.forEach(shortDomain => {
                // Map from these short domain words to the coverageObj key
                // e.g. "process" => "process-monitoring"
                // e.g. "network" => "network-monitoring"
                // This is up to you to define consistently
                const coverageKey = shortDomain + "-monitoring";

                // See what coverage level the user selected
                const userCoverage = coverageObj[coverageKey] || "None";

                // Add the numeric fraction
                const fraction = coverageToFactor[userCoverage] || 0;
                total += fraction;
            });

            return total;
        }


        /**
         * Top-level function to iterate through the files array, fetch each JSON,
         * parse, and import into the specified Dexie store. It also logs progress
         * messages to the "loading-logs" element.
         *
         * @param {Dexie} db        - The Dexie database instance.
         * @param {Array} filesArr  - The array of file metadata objects.
         *    e.g. { file, format, store, record_type, import_from }
         */
         async function importAllJsonFiles(db, filesArr) {
            for (const fileDef of filesArr) {
                await importSingleJsonFile(db, fileDef);
            }
        }

        // Function to update progress visually
        function updateProgress(logMessage) {
            // For example, if you have 6 main tasks:
            const totalSteps = 6;
            let currentStep = 0;
            currentStep++;
            const progressPercent = (currentStep / totalSteps) * 100;
            document.getElementById("loading-progress-bar").style.width = progressPercent + "%";

            // Append the log
            const logsDiv = document.getElementById("loading-logs");
            const newLogLine = document.createElement("div");
            newLogLine.textContent = `(${currentStep}/${totalSteps}) ${logMessage}`;
            logsDiv.prepend(newLogLine);
        }

        async function runInitializationSequence(db) {
            // Show the progress bar
            document.getElementById("progress-container").style.display = "block";



            // // Function to update progress visually
            // function updateProgress(logMessage) {
            //     currentStep++;
            //     const progressPercent = (currentStep / totalSteps) * 100;
            //     document.getElementById("loading-progress-bar").style.width = progressPercent + "%";

            //     // Append the log
            //     const logsDiv = document.getElementById("loading-logs");
            //     const newLogLine = document.createElement("div");
            //     newLogLine.textContent = `(${currentStep}/${totalSteps}) ${logMessage}`;
            //     logsDiv.appendChild(newLogLine);
            // }

            // 1) Initialize Dexie
            await initShuffleDb(db);
            updateProgress("shuffledb initialized.");

            // 2) Import staticVariables
            await importAllJsonFiles(db, filesArr);
            updateProgress("imported json files.");

            // 3) Import capabilities
            // await importRecords("capabilities");
            // updateProgress("capabilities imported.");

            // 4) Import attack store
            // await importRecords("attack");
            // updateProgress("attack data imported.");

            // 5) Create “techniques” store records
            await createAllTechniques(db);
            updateProgress("techniques store records created.");

            // populate environment dropdown
            populateEnvironmentSelection();
            updateProgress("Environment selections populated.");

            // populate record count dropdown
            populateRecordCountSelection();
            updateProgress("Record count selections populated.");

            //populate monitoring coverage radio sets
            populateMonitoringCoverageSelections();
            updateProgress("Monitoring coverage selections populated.");

            // All done: reveal the Next button
            document.getElementById("next-step").classList.remove("hidden");
            // Optional: hide the progress bar, or leave it fully at 100%
        }

        async function generateRadialTree() {
            const container = document.getElementById("radial-tree-container");
            if (!container) {
                console.error("❌ radial-tree-container not found in DOM.");
                return;
            }

            // Clear previous
            container.innerHTML = "";

            // Build the data object from Dexie
            const data = await buildRadialTreeData();

            // Dimensions
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2;

            // Create base SVG
            const svg = d3
                .select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            // Build radial "cluster" layout
            const tree = d3.cluster().size([360, radius - 100]);

            const root = d3.hierarchy(data, d => d.children);
            tree(root);

            // Draw links
            svg
                .selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1.5)
                .attr(
                "d",
                d3
                    .linkRadial()
                    .angle(d => (d.x * Math.PI) / 180)
                    .radius(d => d.y)
                );

            // Draw nodes
            const node = svg
                .selectAll(".node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `rotate(${d.x - 90}) translate(${d.y},0)`);

            // Node circles
            node.append("circle")
                .attr("r", 4)
                .attr("fill", "#69b3a2");

            // Labels
            node
                .append("text")
                .attr("dy", ".31em")
                .attr("x", d => (d.x < 180 ? 8 : -8))
                .attr("text-anchor", d => (d.x < 180 ? "start" : "end"))
                .attr("transform", d => (d.x >= 180 ? "rotate(180)" : ""))
                .text(d => d.data.name);
        }



        async function buildRadialTreeData() {
            // 1) Retrieve all asset-type-instance records from Dexie
            const db = await initShuffleDb();
            const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray();

            // 2) Get the currently selected visualization type (e.g. "detections", "mitigations", "nist_controls", etc.)
            const selectedVisualizationType = document.querySelector(
                'input[name="visualization-type"]:checked'
            )?.value || "detections";

            // 3) Accumulate a hierarchical structure using a nested map:
            //    Environment → Asset Category → Asset Type → Techniques
            const envMap = {};

            for (const instance of allInstances) {
                const environment = instance.environment || "Unknown Environment";
                const category = instance["asset-category"] || "Unknown Category";
                const assetType = instance["asset-type"] || "Unnamed Asset";

                // Ensure environment node exists
                if (!envMap[environment]) {
                envMap[environment] = {
                    name: environment,
                    children: {},
                };
                }

                // Ensure category node exists
                if (!envMap[environment].children[category]) {
                envMap[environment].children[category] = {
                    name: category,
                    children: {},
                };
                }

                // 4) Convert abusedByTechniques and targetedByTechniques (which are objects) into arrays
                const abusedObj = instance.abusedByTechniques || {};
                const targetedObj = instance.targetedByTechniques || {};
                const abusedArr = Object.entries(abusedObj);
                const targetedArr = Object.entries(targetedObj);

                // If you wanted to limit top 5 by "attack-score":
                abusedArr.sort((a, b) => parseFloat(b[1]["attack-score"]||0) - parseFloat(a[1]["attack-score"]||0));
                targetedArr.sort((a, b) => parseFloat(b[1]["attack-score"]||0) - parseFloat(a[1]["attack-score"]||0));
                const top5Abused   = abusedArr.slice(0, 5);
                const top5Targeted = targetedArr.slice(0, 5);
                const allTechs = [...top5Abused, ...top5Targeted];
                
                // If you do not want to limit to top 5:
                // const allTechs = [...abusedArr, ...targetedArr];

                // 5) For each technique, build its node.
                //    When the selected visualization type is "mitigations",
                //    we extract the mitigation_id from each mitigation object.
                const techniqueChildren = allTechs.map(([techId, techDetails]) => {
                let mappedArray = [];
                if (selectedVisualizationType === "mitigations") {
                    // If mitigations is stored as an object, extract its values and then the mitigation_id from each.
                    const mitObj = techDetails.mitigations || {};
                    mappedArray = Object.values(mitObj)
                    .map((m) => m.mitigation_id)
                    .filter(Boolean);
                } else {
                    // For other visualization types, assume the property holds an array.
                    mappedArray = techDetails[selectedVisualizationType] || [];
                }

                // Build child nodes from the mapped array.
                const mappingChildren = mappedArray.map((id) => ({ name: id }));

                return {
                    name: `${techId} - ${techDetails.technique_name || ""}`,
                    children: mappingChildren,
                    data: { ...techDetails }
                };
                });

                // Insert or update the assetType node
                envMap[environment].children[category].children[assetType] = {
                name: assetType,
                children: techniqueChildren
                };
            }

            // 6) Convert the nested envMap into an array-based hierarchical object for D3
            const root = { name: "Model", children: [] };
            root.children = Object.values(envMap).map((envObj) => {
                envObj.children = Object.values(envObj.children).map((catObj) => {
                catObj.children = Object.values(catObj.children);
                return catObj;
                });
                return envObj;
            });

            return root;
        }

        //
        // Cyber Defense Matrix View functions
        //
        async function buildCdmDataByEnvironment(db, selectedControlTypes) {
            const allInstances = await db.modelInstances
                .where("record_type").equals("asset-type-instance")
                .toArray();

            // 1) Unique environments
            const envSet = new Set(allInstances.map(i => i.environment || "Unknown"));
            const environments = Array.from(envSet);

            // 2) For each environment, group by the 5 categories
            const results = []; // We'll build an array of { environment, categoryData: {...} }

            for (const env of environments) {
                // Filter just the asset instances for this environment
                const envInstances = allInstances.filter(i => (i.environment || "Unknown") === env);

                // Build a map from category => [instances]
                const catMap = {
                devices: [],
                networks: [],
                "applications & workloads": [],
                data: [],
                identities: []
                };
                for (const inst of envInstances) {
                const cat = normalizeCategory(inst["asset-category"] || "");
                if (catMap[cat]) {
                    catMap[cat].push(inst);
                }
                }

                // Now for each category, gather:
                // - All asset types
                // - Top 5 controls
                // - Top 5 techniques
                const categoryData = {};
                for (const cat of Object.keys(catMap)) {
                const instancesInCat = catMap[cat];

                // (A) Asset Types row: all distinct assetType from these instances
                const assetTypes = instancesInCat.map(x => x["asset-type"]).filter(Boolean);

                // (B) Build or gather the top 5 controls. For that, we need to get the top 5 across
                //     all techniques in these instances. (Similar logic to your existing code.)
                const topControls = computeTopControlsFromInstances(instancesInCat, selectedControlTypes);

                // (C) Build the top 5 techniques (by score) for these instances
                const topTechniques = computeTop5TechniquesFromInstances(instancesInCat);

                categoryData[cat] = {
                    assetTypes,
                    controls: topControls,      // object keyed by each selected ctrlType -> array
                    techniques: topTechniques   // array of { techniqueId, name, score }
                };
                }

                results.push({
                environment: env,
                categoryData
                });
            }

            return results;
            }

        // declare global var for CDM data
        let globalCdmData = [];

        /**
         * Renders the CDM view into the element with id="cdm-matrix-container".
         * This is typically called when the user reaches Step 5 or whenever
         * any of the capability-filter checkboxes change.
         *
         * @param {Dexie} db - The Dexie database instance.
         */
        async function renderCdmView(db) {
            // 1) Read which capability types the user wants (from checkboxes).
            const selectedControlTypes = getSelectedControlTypes(); 
            // e.g. ["mitigations", "nist-controls", "cis-safeguards", "aws-capabilities", ...]

            // 2) Build data for the matrix (top 5 techniques & relevant controls).
            // const cdmData = await buildCdmData(db, selectedControlTypes);
            const globalCdmData = await buildCdmDataByEnvironment(db, selectedControlTypes);

            // 3) Render the resulting data structure into the page.
            // drawCdmMatrix(cdmData);
            drawCdmMatrixByEnvironment(globalCdmData);
        }

        /**
         * Returns an array of the checked capability types. E.g.:
         * ["mitigations", "nist-controls", "aws-capabilities"].
         */
        function getSelectedControlTypes() {
        const checkboxes = document.querySelectorAll('#cdm-capability-filters input[name="cdmFilters"]:checked');
        return Array.from(checkboxes).map(cb => cb.value);
        }

        /**
         * Builds an in-memory data structure needed to display the CDM matrix:
         * [
         *   {
         *     category: "devices",
         *     topTechniques: [ {techniqueId, techniqueName, attackScore}, ... up to 5 ],
         *     controls: {
         *       "mitigations": [ {idOrName, freq}, ... up to 5 ],
         *       "nist-controls": [ {idOrName, freq}, ... up to 5 ],
         *       // etc. for each selected control type
         *     }
         *   },
         *   ... repeated for networks, applications & workloads, data, identities
         * ]
         *
         * @param {Dexie} db - Dexie instance
         * @param {string[]} selectedControlTypes - array of chosen controls/capabilities
         * @returns {Array} cdmData
         */
        async function buildCdmData(db, selectedControlTypes) {
        // The five categories we want, in this specific order:
        const categories = ["devices", "networks", "applications & workloads", "data", "identities"];

        // 1) Fetch all asset instances from modelInstances
        const allInstances = await db.modelInstances
            .where("record_type").equals("asset-type-instance")
            .toArray();

        // 2) Group them by category
        const categoryMap = {};
        for (const cat of categories) {
            categoryMap[cat] = [];
        }
        for (const instance of allInstances) {
            const cat = (instance["asset-category"] || "").toLowerCase();
            // do a simple match ignoring case, or unify "applications & workloads"
            // if the stored data might differ slightly:
            const canonical = normalizeCategory(cat);
            if (categoryMap[canonical]) {
            categoryMap[canonical].push(instance);
            }
        }

        // 3) For each category, gather top 5 techniques + top controls
        const results = [];
        for (const cat of categories) {
            const instancesInCat = categoryMap[cat] || [];
            if (!instancesInCat.length) {
            // If no instances, push an empty placeholder
            results.push({
                category: cat,
                topTechniques: [],
                controls: {}
            });
            continue;
            }

            // 4) Gather all techniques across the instances in this category
            const allTechs = [];
            for (const inst of instancesInCat) {
            // abusedByTechniques + targetedByTechniques
            const abusedObj   = inst.abusedByTechniques   || {};
            const targetedObj = inst.targetedByTechniques || {};

            // Convert each to [techId, { ...details }] pairs, push all
            for (const [techId, techDetail] of Object.entries(abusedObj)) {
                allTechs.push({
                techniqueId:   techId,
                techniqueName: techDetail["technique_name"],
                score:         parseFloat(techDetail["attack-score"]) || 0,
                detail:        techDetail
                });
            }
            for (const [techId, techDetail] of Object.entries(targetedObj)) {
                allTechs.push({
                techniqueId:   techId,
                techniqueName: techDetail["technique_name"],
                score:         parseFloat(techDetail["attack-score"]) || 0,
                detail:        techDetail
                });
            }
            }

            // 5) Sort by score descending, pick top 5
            allTechs.sort((a,b) => b.score - a.score);
            const topTechs = allTechs.slice(0, 5);

            // 6) From those top 5, compute the top controls in each selected type
            const controlsByType = {};
            for (const ctrlType of selectedControlTypes) {
            // Example: ctrlType = "nist-controls"
            // We'll gather frequency across the topTechs
            const freqMap = {};
            for (const t of topTechs) {
                // e.g. t.detail["nist-controls"] => array of strings
                const arr = t.detail[ctrlType] || [];
                for (const ctrlId of arr) {
                freqMap[ctrlId] = (freqMap[ctrlId] || 0) + 1;
                }

                // If ctrlType == "mitigations" it might be an array of objects or array of {mitigation_id, ...}
                // Depending on your data shape, adapt accordingly:
                if (ctrlType === "mitigations" && Array.isArray(t.detail.mitigations)) {
                // If "mitigations" is an array
                for (const mitObj of t.detail.mitigations) {
                    const mId = mitObj.mitigation_id || "UnknownMitigation";
                    freqMap[mId] = (freqMap[mId] || 0) + 1;
                }
                }
            }

            // Turn freqMap into a sorted array
            let freqArr = Object.entries(freqMap).map(([key, val]) => ({ idOrName: key, freq: val }));
            freqArr.sort((a,b) => b.freq - a.freq);
            // slice top 5
            freqArr = freqArr.slice(0, 5);

            controlsByType[ctrlType] = freqArr;
            }

            // 7) Build the final data object for this category
            results.push({
            category: cat,
            topTechniques: topTechs.map(t => ({
                techniqueId:   t.techniqueId,
                techniqueName: t.techniqueName,
                score:         t.score
            })),
            controls: controlsByType
            });
        }

        return results;
        }

        /**
         * Build the CDM View layout that mimics the shuffle-vue.html structure.
         * @param {Array} cdmData - array of environment blocks returned from buildCdmDataByEnvironment, e.g.:
         *   [
         *     {
         *       environment: "AWS",
         *       categoryData: {
         *         devices: { assetTypes: [...], controls: {...}, techniques: [...] },
         *         networks: {...},
         *         data: {...},
         *         "applications & workloads": {...},
         *         identities: {...}
         *       }
         *     },
         *     { environment: "Azure", categoryData: ... },
         *     ...
         *   ]
         */
        function drawCdmMatrixByEnvironment(cdmData) {
        // 1) Clear previous content
        const container = document.getElementById("cdm-matrix-container");
        container.innerHTML = "";

        // 2) Build the assetCategoryHeaders bar
        const categoryHeadersDiv = document.createElement("div");
        categoryHeadersDiv.className = "assetCategoryHeaders";
        const categoriesInOrder = ["devices", "networks", "data", "applications & workloads", "identities"];
        categoriesInOrder.forEach(cat => {
            const catHeader = document.createElement("div");
            catHeader.className = "category-header";
            catHeader.textContent = cat;
            categoryHeadersDiv.appendChild(catHeader);
        });
        container.appendChild(categoryHeadersDiv);

        // 3) Build the first matrix-container for Asset Types
        const assetTypesMatrix = document.createElement("div");
        assetTypesMatrix.className = "matrix-container assetTypesMatrix";
        container.appendChild(assetTypesMatrix);

        // For each environment, create a "section-container"
        cdmData.forEach(envBlock => {
            // <div class="section-container">
            const sectionDiv = document.createElement("div");
            sectionDiv.className = "section-container";

            // Left vertical label with environment name
            const headerDiv = document.createElement("div");
            headerDiv.className = "section-header-container";
            headerDiv.textContent = envBlock.environment;
            sectionDiv.appendChild(headerDiv);

            // Then 5 "section-category-container" columns, in the same category order
            categoriesInOrder.forEach(cat => {
            const catData = envBlock.categoryData[cat] || {};
            const colDiv = document.createElement("div");
            colDiv.className = "section-category-container";

            // catData.assetTypes is an array of strings
            if (!catData.assetTypes || !catData.assetTypes.length) {
                colDiv.textContent = "(None)";
            } else {
                catData.assetTypes.forEach(aType => {
                const div = document.createElement("div");
                div.textContent = aType;
                div.className = "doc asset_type";
                colDiv.appendChild(div);
                });
            }

            sectionDiv.appendChild(colDiv);
            });

            assetTypesMatrix.appendChild(sectionDiv);
        });

        // 4) Build the second matrix-container for Controls & Capabilities
        const controlsMatrix = document.createElement("div");
        controlsMatrix.className = "matrix-container controlsMatrix";
        container.appendChild(controlsMatrix);

        // We only want a single section-container for all controls
        const controlsSection = document.createElement("div");
        controlsSection.className = "section-container";
        controlsMatrix.appendChild(controlsSection);

        // The left label: "Controls & Capabilities"
        const controlsHeader = document.createElement("div");
        controlsHeader.className = "section-header-container";
        controlsHeader.textContent = "Controls & Capabilities";
        controlsSection.appendChild(controlsHeader);

        // Now 5 columns, one for each category. We need to combine all envs for each category, or pick how you want it displayed.
        // For simplicity, let's assume you want to display "the top controls" across ALL environments, grouped by category.
        // If you prefer environment-by-environment, you'd do more section-containers. 
        categoriesInOrder.forEach(cat => {
            const colDiv = document.createElement("div");
            colDiv.className = "section-category-container";

            // We can iterate over each environment, gather the controls for cat, or do a single "merged" view. 
            // Below is just an example: we gather all controls across all envs, flatten, and display top controls. 
            // Adjust to your actual logic for how to show them.

            let allControls = [];
            cdmData.forEach(env => {
            const catObj = env.categoryData[cat];
            if (catObj && catObj.controls) {
                // catObj.controls = { "nist-controls": [...], "mitigations": [...], ... }
                // You might want to show them differently; here's a naive approach.
                const ctrlKeys = Object.keys(catObj.controls);
                ctrlKeys.forEach(ctrlType => {
                const items = catObj.controls[ctrlType]; // e.g. [ {idOrName, freq}, ... ]
                if (items) {
                    items.forEach(x => {
                    // Add ctrlType or some label if you want
                    allControls.push({ ctrlType, idOrName: x.idOrName, freq: x.freq });
                    });
                }
                });
            }
            });

            if (!allControls.length) {
            colDiv.textContent = "(No controls)";
            } else {
            // Example: just listing them all 
            allControls.forEach(ctrl => {
                const d = document.createElement("div");
                d.textContent = `[${ctrl.ctrlType}] ${ctrl.idOrName} (freq: ${ctrl.freq})`;
                d.className = "doc capability";
                colDiv.appendChild(d);
            });
            }

            controlsSection.appendChild(colDiv);
        });

        // 5) Build the third matrix-container for ATT&CK Techniques
        const techniquesMatrix = document.createElement("div");
        techniquesMatrix.className = "matrix-container techniquesMatrix";
        container.appendChild(techniquesMatrix);

        // Single section-container for techniques
        const techniquesSection = document.createElement("div");
        techniquesSection.className = "section-container";
        techniquesMatrix.appendChild(techniquesSection);

        // Left label
        const techniquesHeader = document.createElement("div");
        techniquesHeader.className = "section-header-container";
        techniquesHeader.textContent = "ATT&CK Techniques";
        techniquesSection.appendChild(techniquesHeader);

        // 5 columns for categories
        categoriesInOrder.forEach(cat => {
            const colDiv = document.createElement("div");
            colDiv.className = "section-category-container";

            // gather top techniques across all envs (or just one environment, up to you)
            let allTechs = [];
            cdmData.forEach(env => {
            const catObj = env.categoryData[cat];
            if (catObj && catObj.techniques) {
                allTechs = allTechs.concat(catObj.techniques);
            }
            });

            if (!allTechs.length) {
            colDiv.textContent = "(No techniques)";
            } else {
            // for each technique, create a doc div
            allTechs.forEach(t => {
                const d = document.createElement("div");
                d.className = "doc technique";
                d.textContent = `${t.techniqueId} (${t.score.toFixed(3)}) - ${t.techniqueName}`;
                colDiv.appendChild(d);
            });
            }

            techniquesSection.appendChild(colDiv);
        });
        }



        /**
         * Renders the CDM data structure into #cdm-matrix-container using a simple
         * table or flex layout. Each category is a column; we show the top 5 techniques
         * in one row, and the chosen controls in a second row.
         *
         * @param {Array} cdmData - As returned by buildCdmData()
         */
        function drawCdmMatrix(cdmData) {
        const container = document.getElementById("cdm-matrix-container");
        if (!container) return;

        // Clear previous
        container.innerHTML = "";

        // We'll do a simple horizontally scrolling table with 2 row sections:
        // Row 1: "Techniques" across all columns
        // Row 2: "Controls & Capabilities" across all columns

        // Build a table
        const table = document.createElement("table");
        table.className = "w-full border-collapse border border-gray-300 text-sm mb-4";

        // (A) Build a thead that labels each category
        //     (One extra empty cell on top-left if you want row labels, or skip it.)
        const thead = document.createElement("thead");
        const headRow = document.createElement("tr");

        // First blank cell for row label
        const blankTh = document.createElement("th");
        blankTh.className = "border border-gray-300 px-4 py-2 bg-gray-700 text-white text-center";
        blankTh.textContent = " ";
        headRow.appendChild(blankTh);

        // Then a cell for each category
        for (const catObj of cdmData) {
            const th = document.createElement("th");
            th.className = "border border-gray-300 px-4 py-2 bg-gray-700 text-white text-center capitalize";
            // e.g. catObj.category might be "devices"
            th.textContent = catObj.category;
            headRow.appendChild(th);
        }
        thead.appendChild(headRow);
        table.appendChild(thead);

        // (B) Techniques row
        const tbody = document.createElement("tbody");

        const techniquesRow = document.createElement("tr");
        // row label
        const techLabelTd = document.createElement("td");
        techLabelTd.className = "border border-gray-300 px-4 py-2 font-bold bg-gray-100";
        techLabelTd.textContent = "Techniques (Top 5)";
        techniquesRow.appendChild(techLabelTd);

        // For each category
        for (const catObj of cdmData) {
            const td = document.createElement("td");
            td.className = "border border-gray-300 px-2 align-top";

            if (!catObj.topTechniques.length) {
            td.textContent = "(No techniques)";
            } else {
            // List each technique
            const ul = document.createElement("ul");
            catObj.topTechniques.forEach(t => {
                const li = document.createElement("li");
                li.className = "mb-1";
                li.textContent = `${t.techniqueId} (${t.score.toFixed(3)}) - ${t.techniqueName}`;
                ul.appendChild(li);
            });
            td.appendChild(ul);
            }
            techniquesRow.appendChild(td);
        }
        tbody.appendChild(techniquesRow);

        // (C) "Controls & Capabilities" row
        // We'll combine everything the user selected into a single row for each category.
        const controlsRow = document.createElement("tr");
        const controlsLabelTd = document.createElement("td");
        controlsLabelTd.className = "border border-gray-300 px-4 py-2 font-bold bg-gray-100";
        controlsLabelTd.textContent = "Controls & Capabilities";
        controlsRow.appendChild(controlsLabelTd);

        // For each category
        for (const catObj of cdmData) {
            const td = document.createElement("td");
            td.className = "border border-gray-300 px-2 align-top";

            // catObj.controls is an object keyed by the selected control type
            // e.g. { "nist-controls": [ {idOrName, freq}, ...], "mitigations": [...] }
            if (!catObj.topTechniques.length) {
            // If no techniques, presumably no controls
            td.textContent = "(No data)";
            } else if (Object.keys(catObj.controls).length === 0) {
            td.textContent = "(No controls selected)";
            } else {
            // We'll build a small sub-section for each control type
            for (const [ctrlType, ctrlArr] of Object.entries(catObj.controls)) {
                // A small label
                const labelDiv = document.createElement("div");
                labelDiv.className = "font-semibold mb-1 mt-2";
                labelDiv.textContent = ctrlType; 
                td.appendChild(labelDiv);

                if (!ctrlArr.length) {
                const noneDiv = document.createElement("div");
                noneDiv.className = "text-xs italic";
                noneDiv.textContent = "No mappings";
                td.appendChild(noneDiv);
                continue;
                }

                // List top 5
                const ul = document.createElement("ul");
                ctrlArr.forEach(c => {
                const li = document.createElement("li");
                li.className = "ml-2 text-sm";
                li.textContent = `${c.idOrName} (freq: ${c.freq})`;
                ul.appendChild(li);
                });
                td.appendChild(ul);
            }
            }

            controlsRow.appendChild(td);
        }
        tbody.appendChild(controlsRow);

        table.appendChild(tbody);
        container.appendChild(table);
        }

        /**
         * For a given list of asset-type-instances (all in the same category),
         * gather the top 5 of each selected control type. 
         * 
         * Returns an object keyed by control type, e.g.:
         * {
         *   "nist-controls": [ { idOrName: "AC-1", freq: 2 }, { ... }, ... up to 5 ],
         *   "mitigations": [ ... ],
         *   ...
         * }
         *
         * This is similar to your existing logic in buildCdmData(...) for controls,
         * but extracted to a standalone function.
         */
        function computeTopControlsFromInstances(instancesInCat, selectedControlTypes) {
            // 1) Gather top 5 techniques from these instances. 
            //    If we want the “most frequently mapped” controls across *all* techniques, 
            //    then we should gather *all* relevant techniques, not just top 5. 
            //    Or if you truly only want controls from the top 5 techniques, 
            //    then you need to also call computeTop5TechniquesFromInstances first. 
            //    For this example, let’s gather *all* techniques from these instances:

            const allTechs = [];
            for (const inst of instancesInCat) {
                const abusedObj   = inst.abusedByTechniques   || {};
                const targetedObj = inst.targetedByTechniques || {};
                
                for (const [techId, techDetail] of Object.entries(abusedObj)) {
                allTechs.push(techDetail);
                }
                for (const [techId, techDetail] of Object.entries(targetedObj)) {
                allTechs.push(techDetail);
                }
            }

            // 2) Build a result object keyed by each control type
            const controlsByType = {};
            for (const ctrlType of selectedControlTypes) {
                // We’ll gather frequency across all techniques (or the top 5, if that’s your requirement)
                const freqMap = {};

                for (const t of allTechs) {
                // e.g. t["nist-controls"] => array of strings
                const arr = t[ctrlType] || [];
                if (Array.isArray(arr)) {
                    for (const ctrlId of arr) {
                    freqMap[ctrlId] = (freqMap[ctrlId] || 0) + 1;
                    }
                }

                // If ctrlType is "mitigations" and it’s an array of mitigation objects
                if (ctrlType === "mitigations" && Array.isArray(t.mitigations)) {
                    for (const mitObj of t.mitigations) {
                    const mId = mitObj.mitigation_id || "UnknownMitigation";
                    freqMap[mId] = (freqMap[mId] || 0) + 1;
                    }
                }
                }

                // Turn freqMap into a sorted array
                let freqArr = Object.entries(freqMap).map(([key, val]) => ({ idOrName: key, freq: val }));
                freqArr.sort((a, b) => b.freq - a.freq);
                // slice top 5
                freqArr = freqArr.slice(0, 5);

                controlsByType[ctrlType] = freqArr;
            }

            return controlsByType;
        }


        /**
         * Helper to standardize category naming if your modelInstances
         * can store "Devices"/"devices"/"DEVICES", etc. Adjust as needed.
         */
        function normalizeCategory(input) {
        const val = (input || "").trim().toLowerCase();
        if (val.includes("device")) return "devices";
        if (val.includes("network")) return "networks";
        if (val.includes("application")) return "applications & workloads";
        if (val.includes("workload")) return "applications & workloads";
        if (val.includes("data")) return "data";
        if (val.includes("identit")) return "identities";
        // fallback
        return val;
        }

        /**
         * Gathers all techniques (abused + targeted) from the given list of asset-type-instances,
         * then returns the top 5 by "attack-score."
         */
        function computeTop5TechniquesFromInstances(instancesInCat) {
        const allTechs = [];

        // 1) Collect techniques
        for (const inst of instancesInCat) {
            const abusedObj   = inst.abusedByTechniques   || {};
            const targetedObj = inst.targetedByTechniques || {};

            for (const [techId, techDetail] of Object.entries(abusedObj)) {
            const score = parseFloat(techDetail["attack-score"]) || 0;
            allTechs.push({
                techniqueId: techId,
                techniqueName: techDetail["technique_name"],
                score
            });
            }
            for (const [techId, techDetail] of Object.entries(targetedObj)) {
            const score = parseFloat(techDetail["attack-score"]) || 0;
            allTechs.push({
                techniqueId: techId,
                techniqueName: techDetail["technique_name"],
                score
            });
            }
        }

        // 2) Sort descending by score, return top 5
        allTechs.sort((a, b) => b.score - a.score);
        return allTechs.slice(0, 5);
        }

        // 
        // Attack Analysis functions
        //
        async function runAttackAnalysis() {
            try {
                const iterationCount = parseInt(
                document.getElementById("attackAnalysisIterations").value,
                10
                ) || 1000;
                const db = await initShuffleDb(); // or use your globally opened Dexie db

                // [A] Check which single controls/capabilities radio is selected
                const selectedRadio = document.querySelector('input[name="analysis-control-option"]:checked');
                if (!selectedRadio) {
                alert("Please select exactly one controls/capabilities set before running Attack Analysis.");
                return;
                }
                const selectedControlType = selectedRadio.value; 
                // e.g. "nist-controls", "cis-safeguards", "aws-capabilities", "mitigations", etc.

                // [B] Gather all asset-type-instance records
                const allInstances = await db.modelInstances
                .where("record_type")
                .equals("asset-type-instance")
                .toArray();
                if (!allInstances.length) {
                console.warn("No asset-type-instance records found. Aborting analysis.");
                return;
                }

                // [C] Build a big array of (assetCategory, techniqueId, techniqueName, attackScore, controlArrays...)
                //    We'll store them in an array so we can group by category easily
                const allTechniqueEntries = []; 
                // shape: { assetCategory, techniqueId, techniqueName, attackScore, controlsArray: [] }

                // Helper to add one technique
                function addTechnique(assetCat, techId, techDetails) {
                const score = parseFloat(techDetails["attack-score"] || 0);
                const name  = techDetails["technique_name"] || techId;
                // gather the relevant array of controls from the single user selection
                // e.g. if (selectedControlType==="nist-controls") => techDetails["nist-controls"]
                let rawControls = techDetails[selectedControlType] || [];
                // For "mitigations" we might have an array of objects instead:
                if (selectedControlType === "mitigations" && Array.isArray(techDetails.mitigations)) {
                    rawControls = techDetails.mitigations.map(m => m.mitigation_id || "UnknownMitigation");
                }

                allTechniqueEntries.push({
                    assetCategory: assetCat,
                    techniqueId:   techId,
                    techniqueName: name,
                    attackScore:   score,
                    controls:      rawControls || []
                });
                }

                // For each asset-type-instance
                for (const inst of allInstances) {
                const assetCat = (inst["asset-category"] || "").toLowerCase();
                // Combine abused + targeted
                const abusedObj = inst.abusedByTechniques || {};
                for (const [tid, tDetails] of Object.entries(abusedObj)) {
                    addTechnique(assetCat, tid, tDetails);
                }
                const targetedObj = inst.targetedByTechniques || {};
                for (const [tid, tDetails] of Object.entries(targetedObj)) {
                    addTechnique(assetCat, tid, tDetails);
                }
                }

                if (!allTechniqueEntries.length) {
                console.warn("No techniques found from any instance. Aborting analysis.");
                return;
                }

                // [D] Group by assetCategory => top 5 by attackScore
                // possible categories: "devices", "networks", "applications & workloads", "data", "identities"
                const categoryToTechs = {};
                for (const entry of allTechniqueEntries) {
                if (!categoryToTechs[entry.assetCategory]) {
                    categoryToTechs[entry.assetCategory] = [];
                }
                categoryToTechs[entry.assetCategory].push(entry);
                }

                // Now for each category, sort by score descending, slice top 5
                const finalTechniques = []; // after picking top 5 each category

                for (const cat of Object.keys(categoryToTechs)) {
                const arr = categoryToTechs[cat];
                arr.sort((a, b) => b.attackScore - a.attackScore);
                const top5 = arr.slice(0, 5);
                finalTechniques.push(...top5);
                }

                // So finalTechniques has up to 25 items max (5 from each category).
                if (!finalTechniques.length) {
                console.warn("No top techniques found after grouping by asset-category. Aborting analysis.");
                return;
                }

                // [E] Summaries / Preprocessing for Monte Carlo
                let totalScore = 0;
                finalTechniques.forEach(t => {
                totalScore += t.attackScore;
                });

                finalTechniques.forEach(t => {
                t.weightedImpact = totalScore > 0 ? (t.attackScore / totalScore) : 0;
                });

                // [F] Monte Carlo simulation
                const residualRiskValues = [];
                const techniqueBreakthroughCount = {};
                const controlRosiTotals = {};

                // initialize counters
                for (const t of finalTechniques) {
                techniqueBreakthroughCount[t.techniqueId] = 0;
                for (const cId of t.controls) {
                    controlRosiTotals[cId] = 0;
                }
                }

                for (let i = 0; i < iterationCount; i++) {
                let inherentRisk = 100;

                for (const t of finalTechniques) {
                    // random in [0..100]
                    const attackEffectiveness = Math.floor(Math.random() * 101);

                    // random maturity for each control in [5..70]
                    const maturityScores = t.controls.map(ctrlId => ({
                    ctrlId,
                    score: Math.floor(Math.random() * 66) + 5
                    }));

                    const overcameAll = maturityScores.every(ms => attackEffectiveness > ms.score);
                    if (overcameAll) {
                    techniqueBreakthroughCount[t.techniqueId]++;
                    inherentRisk -= (t.weightedImpact * 100);
                    } else {
                    // for each control whose maturity >= attackEffectiveness, we allocate rosi
                    const strongCtrls = maturityScores.filter(ms => ms.score >= attackEffectiveness);
                    if (strongCtrls.length) {
                        const rosiScore = (t.weightedImpact * 100) / strongCtrls.length;
                        for (const sc of strongCtrls) {
                        controlRosiTotals[sc.ctrlId] += rosiScore;
                        }
                    }
                    }
                }

                const finalResidual = Math.max(0, inherentRisk);
                residualRiskValues.push(finalResidual);
                }

                // [G] Sort & Show stats
                residualRiskValues.sort((a,b) => a - b);
                const q50 = residualRiskValues[Math.floor(0.5 * iterationCount)];
                const q75 = residualRiskValues[Math.floor(0.75 * iterationCount)];
                const q90 = residualRiskValues[Math.floor(0.90 * iterationCount)];

                // [H] Build Sankey data from finalTechniques (up to 25)
                const sankeyData = buildSankeyJson(finalTechniques, techniqueBreakthroughCount, controlRosiTotals, iterationCount);
                console.log("buildSankeyJson(finalTechniques, techniqueBreakthroughCount, controlRosiTotals, iterationCount)", "finalTechniques: ", finalTechniques, ", techniqueBreakthroughCount: ", techniqueBreakthroughCount, ", controlRosiTotals: ", controlRosiTotals, ", iterationCount: ", iterationCount)

                // Render Sankey
                renderSankeyDiagram(sankeyData);

                // Show numeric results
                document.getElementById("attackAnalysisResults").innerHTML = `
                <p><strong>Using Control/Capability Set:</strong> ${selectedControlType}</p>
                <p>Top 5 techniques from each category => total: ${finalTechniques.length} techniques used in the analysis.</p>
                <p>Residual Risk distribution over ${iterationCount} runs:</p>
                <ul>
                    <li>50%: ${q50.toFixed(2)}</li>
                    <li>75%: ${q75.toFixed(2)}</li>
                    <li>90%: ${q90.toFixed(2)}</li>
                </ul>
                `;

                displayRiskFlowTable(sankeyData);

            } catch (err) {
                console.error("runAttackAnalysis encountered an error:", err);
            }
        }

        /**
         * buildSankeyJson
         *
         * @param {Array} finalTechniques  - Each element:
         *   {
         *     techniqueId:  "T1059",
         *     techniqueName:"Command & Scripting Interpreter",
         *     assetCategory:"applications & workloads",
         *     attackScore:  3,
         *     weightedImpact:0.2,
         *     controls: ["M1018","M1022",...]
         *   }
         * @param {Object} techniqueBreakthroughCount
         *   e.g. { "T1059": 331, "T1036": 366, ... }
         * @param {Object} controlRosiTotals
         *   e.g. { "M1018": 70.7, "M1038": 86.2, ... }
         * @param {number} iterationCount
         *   e.g. 1000
         * @return {Object} { nodes: [...], links: [...] } suitable for D3 Sankey
         */
        function buildSankeyJson(
            finalTechniques,
            techniqueBreakthroughCount,
            controlRosiTotals,
            iterationCount
            ) {
            // fractionBlocked(t) => portion of runs technique t was blocked
            function fractionBlocked(t) {
                const breakthroughs = techniqueBreakthroughCount[t.techniqueId] || 0;
                const blockedCount  = iterationCount - breakthroughs;
                return blockedCount / iterationCount;
            }

            // We’ll keep track of how much “flow” arrives at each technique (for chaining).
            const techniqueFlow = new Array(finalTechniques.length).fill(0);

            // Prepare arrays
            const nodes = [];
            const links = [];

            // 1) Node 0 => "Inherent Risk"
            nodes.push({ node: 0, name: "Inherent Risk" });

            // 2) Technique nodes => 1..N
            finalTechniques.forEach((tech, i) => {
                nodes.push({
                node: i + 1,
                name: `${tech.techniqueId} (${tech.assetCategory})`
                });
            });

            // -- We’ll place control nodes next, but gather them first. --
            // Collect all controls/capabilities with rosi>0 from any technique
            const allControlIds = new Set();
            finalTechniques.forEach(t => {
                t.controls.forEach(ctrlId => {
                const rosiVal = controlRosiTotals[ctrlId] || 0;
                if (rosiVal > 0) {
                    allControlIds.add(ctrlId);
                }
                });
            });
            const controlList = Array.from(allControlIds);

            // The first control node index is after the technique nodes
            const firstControlIndex = finalTechniques.length + 1;

            // We won't add "Residual Risk" until after these controls
            const controlToNode = {};

            // Add a node for each control
            controlList.forEach((ctrlId, idx) => {
                const nodeIndex = firstControlIndex + idx;
                nodes.push({
                node: nodeIndex,
                name: ctrlId
                });
                controlToNode[ctrlId] = nodeIndex;
            });

            // The residual node is after all techniques + all controls
            const residualIndex = firstControlIndex + controlList.length;
            nodes.push({
                node: residualIndex,
                name: "Residual Risk"
            });

            // E) Link from Inherent Risk -> first technique with value=100
            if (finalTechniques.length > 0) {
                links.push({
                source: 0,
                target: 1,
                value: 100
                });
                techniqueFlow[0] = 100;
            }

            // G) Chain each technique i -> technique i+1:
            //    outflow = inboundFlow - fractionBlocked * weightedImpact
            for (let i = 0; i < finalTechniques.length - 1; i++) {
                const tech = finalTechniques[i];
                const inboundFlow = techniqueFlow[i] || 0;
                const frac = fractionBlocked(tech) * ((tech.weightedImpact * 100) || 0);
                const outFlow = inboundFlow - frac;
                const nextNode = i + 2; // technique i+1 => node index (i+1)+1

                links.push({
                source: i + 1,  // current technique node
                target: nextNode,
                value: outFlow < 0 ? 0 : outFlow // clamp to 0 if negative
                });
                techniqueFlow[i + 1] = outFlow < 0 ? 0 : outFlow;
            }

            // H) Link from last technique -> Residual
            if (finalTechniques.length > 0) {
                const lastIdx = finalTechniques.length - 1;
                const lastTech = finalTechniques[lastIdx];
                const inboundFlow = techniqueFlow[lastIdx] || 0;
                const frac = fractionBlocked(lastTech) * ((lastTech.weightedImpact * 100) || 0);
                const outFlow = inboundFlow - frac;

                links.push({
                source: lastIdx + 1,
                target: residualIndex,
                value: outFlow < 0 ? 0 : outFlow
                });
            }

            // F) For each technique, create technique->control links
            //    if rosi>0 for that control. 
            //    linkValue = fractionBlocked(tech)*weightedImpact 
            //                * rosiOfControl / sumOfRosi(tech)
            for (let i = 0; i < finalTechniques.length; i++) {
                const tech = finalTechniques[i];
                const fracTerm = fractionBlocked(tech) * ((tech.weightedImpact * 100) || 0);
                if (fracTerm <= 0) continue;

                // sum rosi across that technique’s controls
                let sumRosi = 0;
                tech.controls.forEach(ctrlId => {
                const cVal = controlRosiTotals[ctrlId] || 0;
                if (cVal > 0) sumRosi += cVal;
                });
                if (sumRosi <= 0) continue;

                // create link for each rosi>0
                tech.controls.forEach(ctrlId => {
                const cVal = controlRosiTotals[ctrlId] || 0;
                if (cVal > 0) {
                    const ctrlNode = controlToNode[ctrlId];
                    if (typeof ctrlNode === "undefined") {
                    // no node for this control => skip
                    return;
                    }
                    const linkVal = fracTerm * (cVal / sumRosi);
                    if (linkVal > 0) {
                    links.push({
                        source: i + 1,      // technique node index
                        target: ctrlNode,   // control node index
                        value: linkVal
                    });
                    }
                }
                });
            }

            return { nodes, links };
        }

        function renderSankeyDiagram(sankeyData) {
            // sankeyData = { nodes: [...], links: [...] }
            console.log("renderSankeyDiagram sankeyData: ", sankeyData)
            // 1) Clear any existing diagram
            const container = d3.select("#sankey-diagram-container");
            container.selectAll("*").remove();

            const width = 800;
            const height = 600;

            // 2) Create SVG
            const svg = container
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // 3) Create sankey generator
            const sankey = d3.sankey()
                .nodeId(d => d.node)
                .nodeWidth(20)
                .nodePadding(10)
                .size([width, height]);

            // 4) Build the graph from your sankeyData
            const graph = sankey({
                nodes: sankeyData.nodes.map(d => Object.assign({}, d)),
                links: sankeyData.links.map(d => Object.assign({}, d))
            });

            // 5) Draw links
            svg.append("g")
                .selectAll("path")
                .data(graph.links)
                .enter()
                .append("path")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", "#aaa")
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("fill", "none")
                .attr("opacity", 0.5);

            // 6) Draw nodes
            const node = svg.append("g")
                .selectAll("g")
                .data(graph.nodes)
                .enter().append("g");

            node.append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => Math.max(1, d.y1 - d.y0))
                .attr("fill", "#69b3a2")
                .attr("stroke", "#000");

            // 7) Add node text
            node.append("text")
                .attr("x", d => d.x0 - 6)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .text(d => d.name)
                .filter(d => d.x0 < width / 2)
                .attr("x", d => d.x1 + 6)
                .attr("text-anchor", "start");
        }

        /**
         * displayRiskFlowTable(sankeyData):
         *
         * Reads the Sankey graph’s nodes/links and builds a table:
         *   - "Inherent Risk" row with the link from node 0 → node 1 (if present).
         *   - Each technique node's inbound sum.
         *   - Each control node's inbound sum.
         *   - The "Residual Risk" node's inbound sum.
         *
         * Assumes:
         *   1) Node 0 = Inherent Risk
         *   2) The last node named "Residual Risk"
         *   3) Technique nodes typically have "T####" in their name with “(category)”
         *   4) Control nodes typically have "M####" or other name without parentheses
         * 
         * Called after renderSankeyDiagram(sankeyData) so the Sankey is built.
         * We insert rows into #riskFlowTableBody.
         */
        function displayRiskFlowTable(sankeyData) {
            // Extract arrays
            const { nodes, links } = sankeyData;
            // If no data, skip
            if (!nodes || !links) return;

            // 1) Calculate inboundFlow for each node by summing link.value for every link
            //    where link.target = that node index.
            const inboundFlow = new Array(nodes.length).fill(0);
            links.forEach(link => {
                inboundFlow[link.target] += link.value;
            });

            // 2) Attempt to find inherent risk from the link with source=0.
            //    If none found, we’ll use 100 as a fallback.
            let inherentRiskValue = 100; 
            const linkFromZero = links.find(l => l.source === 0);
            if (linkFromZero) {
                inherentRiskValue = linkFromZero.value;
            }

            // 3) Attempt to find “Residual Risk” node (by name).
            //    Then we can show its inbound flow as the final row.
            let residualIndex = nodes.findIndex(n => n.name === "Residual Risk");
            const residualFlow = (residualIndex >= 0) ? inboundFlow[residualIndex] : 0;

            // 4) Build row objects in an array for easy insertion.
            //    Start with "Inherent Risk"
            const rowData = [];
            rowData.push({ label: "Inherent Risk", value: inherentRiskValue });

            // Then each technique node that has parentheses in its name (e.g. "T1562 (apps)")
            // We use inboundFlow[i] as the "value passed" to that technique.
            nodes.forEach((node, i) => {
                if (i === 0) return; // skip the 0 node (already used)
                if (node.name === "Residual Risk") return; // handle below
                // If the node name has parentheses, treat as a technique
                if (node.name.includes("(")) {
                rowData.push({
                    label: node.name,
                    value: inboundFlow[i]
                });
                }
            });

            // Then each control node—those that do *not* have "(" in name
            // and are not “Inherent Risk” or “Residual Risk”
            nodes.forEach((node, i) => {
                if (i === 0) return; 
                if (node.name === "Residual Risk") return;
                if (!node.name.includes("(")) {
                // e.g. “M1054”
                rowData.push({
                    label: node.name,
                    value: inboundFlow[i]
                });
                }
            });

            // Finally "Residual Risk"
            rowData.push({ label: "Residual Risk", value: residualFlow });

            // 5) Inject rows into the #riskFlowTableBody in your HTML
            const tbody = document.getElementById("riskFlowTableBody");
            if (!tbody) return;

            // Clear old data
            tbody.innerHTML = "";

            // Build each row
            rowData.forEach(item => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                <td class="border px-4 py-2">${item.label}</td>
                <td class="border px-4 py-2">${item.value.toFixed(2)}</td>
                `;
                tbody.appendChild(tr);
            });
        }
    </script>
         
  
</body>

</html>
