<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Breach Cost Estimator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.12.0/ajv7.bundle.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Dark mode by default */
        body.dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .dark .bg-white { background-color: #2d3748 !important; }
        .dark .text-black { color: #e2e8f0 !important; }
        .dark .bg-gray-100 { background-color: #1a202c !important; }
        .dark .border-gray-300 { border-color: #4a5568 !important; }
    
        /* Progress Bar */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .progress-bar li {
            list-style: none;
            width: 100%;
            text-align: center;
            position: relative;
            font-weight: bold;
            color: gray;
        }
        .progress-bar li:before {
            content: attr(data-step);
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: gray;
            color: white;
        }
        .progress-bar li.active {
            color: #3490dc;
        }
        .progress-bar li.active:before {
            background-color: #3490dc;
        }
    
        /* Hide all form steps by default */
        .form-step {
            display: none;
        }
    
        /* Only display the form-step that has the 'active' class */
        .form-step.active {
            display: block;
        }
    
        /* Loading Indicator */
        #loading-icon {
            display: none;
            font-size: 14px;
            color: #3490dc;
            animation: spin 1s linear infinite;
        }
    
        /* Loading Animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        /* Styling for asset selection */
        #asset-category-container label {
            display: block;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
        }
        #asset-category-container input[type="radio"] {
            display: none;
        }
        #asset-category-container input[type="radio"]:checked + label {
            background-color: #3490dc;
            color: white;
            border-color: #3490dc;
        }
    
        /* Styling for form fields */
        select, input[type="text"], input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #ddd;
            padding: 8px;
            width: 100%;
            border-radius: 5px;
        }
    
        /* Button styles */
        button {
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
        }
        .btn-primary {
            background-color: #3490dc;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #38a169;
            color: white;
        }
        .btn-danger {
            background-color: #e3342f;
            color: white;
        }
        .btn-primary:hover { background-color: #2779bd; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success:hover { background-color: #2f855a; }
        .btn-danger:hover { background-color: #cc1f1a; }
    
        /* JSON Output */
        #json-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f7fafc;
            color: black;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        /* JSON Styling */
        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
        }
        #progress-container {
            display: none;
        }

        #radial-tree-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            position: relative;
        }

    </style>
    
</head>
<body class="dark flex justify-center items-center min-h-screen">
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed bottom-5 right-5 space-y-2 z-50"></div>
    <!-- Main Form Container -->
    <div class="bg-white shadow-md rounded-lg p-6 w-full max-w-2xl">
            <!-- Progress Bar -->
            <div id="progress-container" class="w-full bg-gray-300 rounded mt-4 hidden">
                <div id="progress-bar" class="h-4 bg-blue-500 rounded w-0"></div>
            </div>
        <div class="flex justify-between items-center">
            <h2 class="text-xl font-bold">Data Breach Cost Estimator</h2>
            <button id="darkModeToggle" class="px-3 py-1 text-sm bg-gray-700 text-white rounded">
                <span id="darkModeIcon" class="material-symbols-outlined">dark_mode</span>
            </button>            
        </div>

        <!-- Progress Bar -->
        <ol class="progress-bar flex">
            <li data-step="1" class="active">Organization Details</li>
            <li data-step="2">Asset Types</li>
            <li data-step="3">MITRE ATT&CK Inventory</li>
            <li data-step="4">ATT&CK Technique Visualization</li>
        </ol>

        <div id="form-navigation" class="flex justify-between mt-4">
            <button type="button" id="prev-step" class="hidden bg-gray-500 text-white px-4 py-2 rounded">Back</button>
            <button type="button" id="next-step" class="bg-blue-500 text-white px-4 py-2 rounded">Next</button>
        </div>

        <form id="multiStepForm">
            <!-- Step 1: Organization Details -->
            <div class="form-step active">
                <h3 class="text-lg font-semibold mb-2">Organization Details</h3>
                <p class="text-sm text-gray-600 mb-2">Define your organization's security practices.</p>

                <div id="organization-details">
                    <label class="block mt-2">
                        <input type="checkbox" id="ai_automation" class="mr-2">
                        AI & Automation for Information Security
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_security_staff" class="mr-2">
                        Cybersecurity Training for Security Staff
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="cybersecurity_training_all_employees" class="mr-2">
                        Cybersecurity Training for All Employees
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="incident_response_testing" class="mr-2">
                        Conduct Incident Response Tests
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="law_enforcement_ransomware" class="mr-2">
                        Engage Law Enforcement for Ransomware
                    </label>
                    <label class="block mt-2">
                        <input type="checkbox" id="data_encryption" class="mr-2">
                        Encrypt Stored Data (Beyond Disk Encryption)
                    </label>
                </div>
            </div>

            <!-- Step 2: Asset Types -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">Define Asset Types</h3>
                <p class="text-sm text-gray-600 mb-2">Select an asset category to continue.</p>

                <!-- Asset Category Selection -->
                <div id="asset-category-container">
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="devices" class="mr-2"> Devices
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="networks" class="mr-2"> Networks
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="applications" class="mr-2"> Applications & Workloads
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="data" class="mr-2"> Data
                    </label>
                    <label class="block mt-2">
                        <input type="radio" name="asset-category" value="identities" class="mr-2"> Identities
                    </label>
                </div>

                <!-- Asset Type Selection -->
                <label class="block mt-2">Select Asset Type:
                    <select id="asset-type-dropdown" class="border p-2 w-full" disabled>
                        <option value="">Select an asset category first</option>
                    </select>
                    <span id="loading-icon" class="ml-2" style="display: none;">Loading...</span>
                </label>

                <!-- Environment Selection -->
                <div id="environment-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Environment:
                        <select id="environment-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Record Count Selection (Only for Data) -->
                <div id="record-count-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Estimated Record Count:
                        <select id="record-count-dropdown" class="border p-2 w-full"></select>
                    </label>
                </div>

                <!-- Monitoring Coverage Selection -->
                <div id="monitoring-selection" class="mt-4" style="display: none;">
                    <label class="block mt-2">Monitoring Coverage:</label>
                    <div id="network-monitoring" data-label="Network Monitoring"></div>
                    <div id="process-monitoring" data-label="Process Monitoring"></div>
                    <div id="file-monitoring" data-label="File Monitoring"></div>
                    <div id="cloud-monitoring" data-label="Cloud Monitoring"></div>
                    <div id="hardware-monitoring" data-label="Hardware Monitoring"></div>
                </div>

                <!-- Submit Asset Type -->
                <button type="button" id="submit-asset-type" class="bg-green-500 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    Add Asset Type
                </button>

                <!-- Display Model Definition in JSON -->
                <button type="button" id="view-model-definition" class="bg-gray-700 text-white px-4 py-2 rounded mt-4" style="display: none;">
                    View Model JSON
                </button>
            </div>

            <!-- Step 3: Technique Scoring -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">MITRE ATT&CK Techniques Inventory</h3>
                <p class="text-sm text-gray-600 mb-4">Review the MITRE ATT&CK techniques relevant to each asset type.</p>
            
                <!-- Summary Table -->
                <table id="model-summary-table" class="w-full border-collapse border border-gray-300 text-sm">
                    <thead>
                        <tr class="bg-gray-700 text-white">
                            <th class="border border-gray-300 px-4 py-2">Environment</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Category</th>
                            <th class="border border-gray-300 px-4 py-2">Asset Type</th>
                            <th class="border border-gray-300 px-4 py-2">Count of MITRE ATT&CK Techniques</th>
                        </tr>
                    </thead>
                    <tbody id="model-summary-body"></tbody>
                </table>
            
                <!-- Techniques Table Container -->
                <div id="techniques-container" class="hidden mt-6">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-semibold">Techniques for <span id="selected-asset-type"></span></h4>
                        <button id="toggle-techniques-btn" type="button" bg-gray-600 text-white px-3 py-1 rounded">
                            Hide Techniques
                        </button>
                    </div>

                    <table id="techniques-table" class="w-full border-collapse border border-gray-300 text-sm">
                        <thead>
                            <tr class="bg-gray-700 text-white">
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique ID</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Technique Name</th>
                                <th class="border border-gray-300 px-4 py-2">ATT&CK Score</th>
                            </tr>
                        </thead>
                        <tbody id="techniques-body"></tbody>
                    </table>
                </div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>

            </div>

            <!-- Step 4: Radial Tree Visualization -->
            <div class="form-step">
                <h3 class="text-lg font-semibold mb-2">ATT&CK Technique Visualization</h3>
                <p class="text-sm text-gray-600 mb-4">Select a category to visualize:</p>

                <!-- Radio Button Selection for Correlation Type -->
                <div id="visualization-selection" class="mb-4">
                    <label><input type="radio" name="visualization-type" value="detections" checked> ATT&CK Detections</label>
                    <label><input type="radio" name="visualization-type" value="mitigations"> ATT&CK Mitigations</label>
                    <label><input type="radio" name="visualization-type" value="nist"> NIST Controls</label>
                    <label><input type="radio" name="visualization-type" value="cis"> CIS Safeguards</label>
                    <label><input type="radio" name="visualization-type" value="aws"> AWS Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="gcp"> GCP Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="azure"> Azure Capabilities</label>
                    <label><input type="radio" name="visualization-type" value="m365"> M365 Capabilities</label>
                </div>

                <!-- Radial Tree Visualization Container -->
                <div id="radial-tree-container" class="w-full h-96 border border-gray-300 rounded bg-white"></div>

                <button type="button" id="download-json" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Download JSON</button>
            </div>

            
        </form>

        <!-- JSON Output -->
        <pre id="json-output" class="bg-gray-100 text-black p-4 rounded mt-4" style="display: none;"></pre>
    </div>
    <script>
        // Need to add a function/query to create a consolidated mapping of techniques to mitigations, data sources, controls, and capabilities and store within IndexedDB
        // Need to add a function/query to map the consolidated mapping of techniques to the assets mapped to those techniques
        // Target JSON structure for asset-type:
        // "Linux Server OS": { // from assetTypeMappings.mapping_objects.[].capability_id
        //     "asset-category": "devices", // from assetTypeMappings.mapping_objects.[].capability_group
        //     "asset-type": "Linux Server OS", // from assetTypeMappings
        //     "model-values": { // "model-values" is not present in the indexeddb asset types store, it is added to the asset type instance in the model json when the user clicks the "Add Asset Type" button in step 2
        //         "environment": "AWS", // from user input, enum from ["AWS", "GCP", "Azure", "M365"]
        //         "monitoring-coverage": { // from user input, enum ["None", "Low", "Medium", "High"]
        //             "network-monitoring": "High",
        //             "process-monitoring": "Medium",
        //             "file-monitoring": "Low",
        //             "cloud-monitoring": "None",
        //             "hardware-monitoring": "None"
        //         }
        //         "record-count": 1000, // from user drop-down selection, "record-count" is only present if "asset-category" is "data"
        //     },
        //     "techniques": { // contextualized technique objects for each unique technique mapped to the asset type
        //         "T1001": { // from assetTypeMappings.mapping_objects.[].attack_object_id 
        //             "name": "Data Obfuscation", // from assetTypeMappings.mapping_objects.[].attack_object_name
        //             "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score], // from attack-prev-tid.json
        //             "data-sources": [], // from STIX, in "data_sources" array inside "attack-pattern" object
        //             "nist-controls": [], // from NIST mapex
        //             "cis-safeguards": [], // from CIS json
        //             "aws-capabilities": [], // from AWS mapex
        //             "gcp-capabilities": [], // from GCP mapex
        //             "azure-capabilities": [], // from Azure mapex
        //             "m365-capabilities": [], // from M365 mapex
        //             "mitigations": [], // from STIX, type = "course-of-action"
        //             "monitoring-coverage-eval": {
        //                 "process": true, // Boolean based on whether keys with value "process" from weight-keywords.json are present in "data-sources"
        //                 "network": false, // Boolean based on whether keys with value "network" from weight-keywords.json are present in "data-sources"
        //                 "file": true, // Boolean based on whether keys with value "file" from weight-keywords.json are present in "data-sources"
        //                 "cloud": false, // Boolean based on whether keys with value "cloud" from weight-keywords.json are present in "data-sources"
        //                 "hardware": true // Boolean based on whether keys with value "hardware" from weight-keywords.json are present in "data-sources"
        //             },
        //             "initial-score": 0.5 // initialScore = prevalenceScore + chokepointScore + actionabilityScore
        //         },
        //         "T1002": {
        //             "name": "Data Compressed",
        //             "prevEntry": [calc_tid_before, calc_tid_after, calc_prev_score], // from attack-prev-tid.json
        //             "data-sources": [], // from STIX, in "data_sources" array inside "attack-pattern" object
        //             "nist-controls": [], // from NIST mapex
        //             "cis-safeguards": [], // from CIS json
        //             "aws-capabilities": [], // from AWS mapex
        //             "gcp-capabilities": [], // from GCP mapex
        //             "azure-capabilities": [], // from Azure mapex
        //             "m365-capabilities": [], // from M365 mapex
        //             "mitigations": [], // from STIX, type = "course-of-action"
        //             "monitoring-coverage-eval": {
        //                 "process": true, // Boolean based on whether keys with value "process" from weight-keywords.json are present in "data-sources"
        //                 "network": false, // Boolean based on whether keys with value "network" from weight-keywords.json are present in "data-sources"
        //                 "file": true, // Boolean based on whether keys with value "file" from weight-keywords.json are present in "data-sources"
        //                 "cloud": false, // Boolean based on whether keys with value "cloud" from weight-keywords.json are present in "data-sources"
        //                 "hardware": true // Boolean based on whether keys with value "hardware" from weight-keywords.json are present in "data-sources"
        //             },
        //             "initial-score": 0.5 // initialScore = prevalenceScore + chokepointScore + actionabilityScore
        //         }
        //     }
        // }
        // Initialize IndexedDB
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("DataCacheDB", 1);
    
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
    
                    // Create object stores if they don't exist
                    const stores = [
                        { name: "techniques", keyPath: "id" },
                        { name: "dataSources", keyPath: "id" },
                        { name: "securityMappings", keyPath: "attack_object_id" },
                        { name: "weightKeywords", autoIncrement: true },
                        { name: "staticVariables", autoIncrement: true },
                        { name: "assets", keyPath: "id" }, // Stores only asset categories
                        { name: "mapping", keyPath: ["capability_id", "attack_object_id", "mapping_type"] },
                        { name: "assetType", keyPath: ["capability_id", "attack_object_id", "mapping_type"] }, // Stores asset types per category
                        { name: "securityControl", keyPath: ["capability_id", "attack_object_id", "mapping_type"] }, // Stores NIST mappings
                        { name: "cloudCapability", keyPath: ["capability_id", "attack_object_id", "mapping_type"] }, // Stores AWS, Azure, GCP, and M365 mappings
                        { name: "visualizationTree", keyPath: "id" },
                        { name: "settings", keyPath: "key" }, // Store dark mode, preferences
                        { name: "attackPatterns", keyPath: "technique_id" }, // Stores ATT&CK techniques from STIX 2.1
                        { name: "mitigations", keyPath: "mitigation_id" }, // Stores ATT&CK mitigations from STIX 2.1
                        { name: "attackMitigationMappings", keyPath: "mapping_id" }, // Stores ATT&CK relationships from STIX 2.1
                        { name: "cisSafeguardMappings", keyPath: ["cis_safeguard", "technique_id"] }, // Stores CIS safeguard mappings
                        { name: "attackPrevTid", keyPath: "attack_object_id" }, // Stores technique prevalence and tid data for ATT&CK score calcs
                        { name: "contextualizedAssetTypes", keyPath: "assetTypeId" }, // Stores contextualized asset types
                        { name: "contextualizedTechniques", keyPath: "techniqueId" } // Stores contextualized techniques
                    ];
    
                    stores.forEach(store => {
                        if (!db.objectStoreNames.contains(store.name)) {
                            db.createObjectStore(store.name, { keyPath: store.keyPath });
                        }
                    });
                };
    
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // List of JSON files and their target IndexedDB stores
        const jsonFileMappings = {
            "staticVariables": "static-variables.json",
            "weightKeywords": "weight-keywords.json"
        };

        // Fetch JSON and Store in IndexedDB
        async function fetchAndStoreJSONFiles() {
            const db = await initIndexedDB();

            for (const [storeName, fileName] of Object.entries(jsonFileMappings)) {
                const transaction = db.transaction(storeName, "readonly");
                const store = transaction.objectStore(storeName);
                const countRequest = store.count();

                countRequest.onsuccess = async () => {
                    if (countRequest.result === 0) {
                        console.log(`Fetching ${storeName} data from ${fileName}...`);
                        try {
                            const response = await fetch(fileName);
                            if (!response.ok) throw new Error(`Failed to fetch ${fileName}`);
                            const jsonData = await response.json();
                            await storeJSONData(storeName, jsonData);
                            console.log(`✅ Loaded ${storeName} into IndexedDB.`);
                        } catch (error) {
                            console.error(`Error fetching ${storeName}:`, error);
                        }
                    }
                };
            }
        }

        // Store JSON Data into IndexedDB
        async function storeJSONData(storeName, jsonData) {
            const db = await initIndexedDB();
            const transaction = db.transaction(storeName, "readwrite");
            const store = transaction.objectStore(storeName);

            if (Array.isArray(jsonData)) {
                jsonData.forEach(item => store.put(item));
            } else {
                store.put(jsonData);
            }
        }

        // Define MAPEX file categories
        const mapexFiles = {
            "assetTypeMappings": {
                "applicationsMappings": "enterprise-assets-applications-02.20.2025_attack-16.1-enterprise_json.json",
                "devicesMappings": "enterprise-assets-devices-02.20.2025_attack-16.1-enterprise_json.json",
                "networksMappings": "enterprise-assets-networks-02.20.2025_attack-16.1-enterprise_json.json",
                "dataMappings": "enterprise-assets-data-02.20.2025_attack-16.1-enterprise_json.json",
                "identitiesMappings": "enterprise-assets-identities-02.20.2025_attack-16.1-enterprise_json.json"
            },
            "securityControlMappings": {
                "nistMappings": "nist_800_53-rev5_attack-14.1-enterprise.json"
            },
            "cloudCapabilityMappings": {
                "m365Mappings": "m365-12.11.2023_attack-14.1-enterprise.json",
                "gcpMappings": "gcp-06.28.2022_attack-10.0-enterprise.json",
                "awsMappings": "aws-12.12.2024_attack-16.1-enterprise.json",
                "azureMappings": "azure-06.29.2021_attack-8.2-enterprise.json"
            }
        };

        // Import MAPEX JSON Data into IndexedDB Based on Mapping Type
        async function importMapexMappings(storeName, jsonData, mappingType) {
            if (!jsonData || !jsonData.mapping_objects || !Array.isArray(jsonData.mapping_objects)) {
                console.error(`Invalid JSON structure for ${storeName}`);
                return;
            }

            const db = await initIndexedDB();
            const transaction = db.transaction(mappingType, "readwrite");
            const store = transaction.objectStore(mappingType);

            jsonData.mapping_objects.forEach(mapping => {
                let mappingEntry;

                if (mappingType === "assetType") {
                    mappingEntry = {
                        mapping_id: `${mapping.capability_id}_${mapping.attack_object_id}_${mapping.mapping_type}`,
                        mapping_type: "assetType",
                        capability_id: mapping.capability_id,
                        capability_group: mapping.capability_group,
                        capability_description: mapping.capability_description || "",
                        attack_object_id: mapping.attack_object_id,
                        attack_object_name: mapping.attack_object_name,
                        mapping_category: mapping.mapping_type,
                        comments: mapping.comments || "",
                        references: mapping.references || []
                    };
                } 
                else if (mappingType === "securityControl") {
                    mappingEntry = {
                        mapping_id: `${mapping.capability_id}_${mapping.attack_object_id}_${mapping.mapping_type}`,
                        mapping_type: "securityControl",
                        capability_id: mapping.capability_id,
                        capability_description: mapping.capability_description || "",
                        attack_object_id: mapping.attack_object_id,
                        attack_object_name: mapping.attack_object_name,
                        score_category: mapping.score_category || "",
                        score_value: mapping.score_value || "",
                        comments: mapping.comments || "",
                        references: mapping.references || []
                    };
                } 
                else if (mappingType === "cloudCapability") {
                    mappingEntry = {
                        mapping_id: `${mapping.capability_id}_${mapping.attack_object_id}_${mapping.mapping_type}`,
                        mapping_type: "cloudCapability",
                        capability_id: mapping.capability_id,
                        capability_group: mapping.capability_group || "",
                        capability_description: mapping.capability_description || "",
                        attack_object_id: mapping.attack_object_id,
                        attack_object_name: mapping.attack_object_name,
                        score_category: mapping.score_category || "",
                        score_value: mapping.score_value || "",
                        related_score: mapping.related_score || "",
                        comments: mapping.comments || "",
                        references: mapping.references || []
                    };
                }
                console.log("importMapexMappings mapping_id:" `${mapping.capability_id}_${mapping.attack_object_id}_${mapping.mapping_type}`)
                store.put(mappingEntry);
            });

            console.log(`✅ Imported ${jsonData.mapping_objects.length} mappings into ${storeName} (${mappingType})`);
        }

        // Fetch and Import MAPEX JSON Files with Categorization
        async function fetchAndImportMapexFiles() {
            for (const [category, files] of Object.entries(mapexFiles)) {
                let mappingType;
                
                if (category === "assetTypeMappings") {
                    mappingType = "assetType";
                } 
                else if (category === "securityControlMappings") {
                    mappingType = "securityControl";
                } 
                else if (category === "cloudCapabilityMappings") {
                    mappingType = "cloudCapability";
                }

                for (const [storeName, filePath] of Object.entries(files)) {
                    try {
                        const response = await fetch(filePath);
                        if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
                        const jsonData = await response.json();
                        console.log("fetchAndImportMapexFiles", mappingType, jsonData, mappingType)
                        await importMapexMappings(mappingType, jsonData, mappingType);
                    } catch (error) {
                        console.error(`Error processing ${filePath}:`, error);
                    }
                }
            }
        }

        async function importStixData(jsonData) {
            if (!jsonData || !jsonData.objects || !Array.isArray(jsonData.objects)) {
                console.error("Invalid STIX 2.1 JSON structure");
                return;
            }

            const db = await initIndexedDB();
            const techniquesTransaction = db.transaction("attackPatterns", "readwrite");
            const mitigationsTransaction = db.transaction("mitigations", "readwrite");
            const mappingsTransaction = db.transaction("attackMitigationMappings", "readwrite");

            const techniquesStore = techniquesTransaction.objectStore("attackPatterns");
            const mitigationsStore = mitigationsTransaction.objectStore("mitigations");
            const mappingsStore = mappingsTransaction.objectStore("attackMitigationMappings");

            const techniques = {};
            const mitigations = {};
            const relationships = [];

            // Process each STIX object
            jsonData.objects.forEach(obj => {
                // Skip objects that are deprecated or revoked
                if (obj.x_mitre_deprecated === true || obj.revoked === true) return;

                if (obj.type === "attack-pattern") {
                    const externalRef = obj.external_references?.find(ref => ref.source_name === "mitre-attack") || {};
                    techniques[obj.id] = {
                        technique_id: externalRef.external_id || "Unknown",
                        technique_name: obj.name,
                        description: obj.description || "",
                        kill_chain_phases: obj.kill_chain_phases || [],
                        data_sources: obj.x_mitre_data_sources || [],
                        platforms: obj.x_mitre_platforms || [],
                        version: obj.x_mitre_version || "N/A",
                        external_references: obj.external_references || [],
                        detection: obj.x_mitre_detection || ""
                    };
                    techniquesStore.put(techniques[obj.id]);
                }

                if (obj.type === "course-of-action") {
                    const externalRef = obj.external_references?.find(ref => ref.source_name === "mitre-attack") || {};
                    mitigations[obj.id] = {
                        mitigation_id: externalRef.external_id || "Unknown",
                        mitigation_name: obj.name,
                        description: obj.description || "",
                        external_references: obj.external_references || []
                    };
                    mitigationsStore.put(mitigations[obj.id]);
                }

                if (obj.type === "relationship" && obj.relationship_type === "mitigates") {
                    relationships.push({
                        relationship_id: obj.id,
                        mitigation_id: obj.source_ref,
                        technique_id: obj.target_ref,
                        description: obj.description || "",
                        created: obj.created,
                        modified: obj.modified
                    });
                }
            });

            // Store technique-mitigation mappings
            relationships.forEach(mapping => {
                if (techniques[mapping.technique_id] && mitigations[mapping.mitigation_id]) {
                    mappingsStore.put({
                        mapping_id: mapping.relationship_id,
                        mitigation_id: mitigations[mapping.mitigation_id].mitigation_id,
                        mitigation_name: mitigations[mapping.mitigation_id].mitigation_name,
                        technique_id: techniques[mapping.technique_id].technique_id,
                        technique_name: techniques[mapping.technique_id].technique_name,
                        description: mapping.description,
                        created: mapping.created,
                        modified: mapping.modified
                    });
                }
            });

            console.log(`✅ Imported ${Object.keys(techniques).length} techniques, ${Object.keys(mitigations).length} mitigations, and ${relationships.length} relationships.`);
        }

        async function fetchAndImportStixFile() {
            try {
                const response = await fetch("enterprise-attack.json");
                if (!response.ok) throw new Error("Failed to fetch enterprise-attack.json");
                const jsonData = await response.json();
                await importStixData(jsonData);
            } catch (error) {
                console.error("Error processing enterprise-attack.json:", error);
            }
        }

        async function importCISSafeguardMappings(jsonData) {
            if (!jsonData || !Array.isArray(jsonData)) {
                console.error("Invalid CIS Safeguard JSON structure");
                return;
            }

            const db = await initIndexedDB();
            const transaction = db.transaction("cisSafeguardMappings", "readwrite");
            const store = transaction.objectStore("cisSafeguardMappings");

            const mappings = [];

            jsonData.forEach(entry => {
                const cisSafeguard = entry.cis_safeguard;
                if (!entry.attack_techniques || !Array.isArray(entry.attack_techniques)) return;

                entry.attack_techniques.forEach(technique => {
                    mappings.push({
                        cis_safeguard: cisSafeguard,
                        technique_id: technique.technique_id,
                        technique_name: technique.technique_name
                    });
                });
            });

            // Store CIS safeguard mappings
            mappings.forEach(mapping => store.put(mapping));

            console.log(`✅ Imported ${mappings.length} CIS safeguard mappings into IndexedDB.`);
        }

        async function fetchAndImportCISSafeguardFile() {
            try {
                const response = await fetch("cis_safeguard_to_techniques.json");
                if (!response.ok) throw new Error("Failed to fetch cis_safeguard_to_techniques.json");
                const jsonData = await response.json();
                await importCISSafeguardMappings(jsonData);
            } catch (error) {
                console.error("Error processing cis_safeguard_to_techniques.json:", error);
            }
        }

        async function importAttackPrevTid(jsonData) {
            if (!jsonData || !Array.isArray(jsonData)) {
                console.error("Invalid attack-prev-tid JSON structure");
                return;
            }

            const db = await initIndexedDB();
            const transaction = db.transaction("attackPrevTid", "readwrite");
            const store = transaction.objectStore("attackPrevTid");

            const mappings = jsonData.map(entry => ({
                attack_object_id: entry.attack_object_id,
                calc_tid_before: parseInt(entry.calc_tid_before, 10),
                calc_tid_after: parseInt(entry.calc_tid_after, 10),
                calc_prev_score: parseFloat(entry.calc_prev_score)
            }));

            mappings.forEach(mapping => store.put(mapping));

            console.log(`✅ Imported ${mappings.length} ATT&CK prevalence mappings into IndexedDB.`);
        }

        async function fetchAndImportAttackPrevTidFile() {
            try {
                const response = await fetch("attack-prev-tid.json");
                if (!response.ok) throw new Error("Failed to fetch attack-prev-tid.json");
                const jsonData = await response.json();
                await importAttackPrevTid(jsonData);
            } catch (error) {
                console.error("Error processing attack-prev-tid.json:", error);
            }
        }

        // async function dataLoading() {
        //     await initIndexedDB();
        //     await fetchAndStoreJSONFiles();  // Load general JSON files
        //     await fetchAndImportMapexFiles();  // Load MAPEX mappings
        //     await fetchAndImportStixFile();  // Load STIX data
        //     await fetchAndImportCISSafeguardFile();  // Load CIS Safeguard data
        //     await fetchAndImportAttackPrevTidFile();  // Load technique prevalence and tid data for ATT&CK score calcs
        //     await populateAssetCategories(); // Now categories should be available

        //     console.log("All data loaded successfully.");
        // }


        // Run the function when the page loads
        document.addEventListener("DOMContentLoaded", async () => {
            await initIndexedDB();
            console.log("IndexedDB initialized.");
            await fetchAndStoreJSONFiles();  // Load general JSON files
            console.log("General JSON files loaded.");
            await fetchAndImportMapexFiles();  // Load MAPEX mappings
            console.log("MAPEX mappings loaded.");
            await fetchAndImportStixFile();  // Load STIX data
            console.log("STIX data loaded.");
            await fetchAndImportCISSafeguardFile();  // Load CIS Safeguard data
            console.log("CIS Safeguard data loaded.");
            await fetchAndImportAttackPrevTidFile();  // Load technique prevalence and tid data for ATT&CK score calcs
            console.log("Technique prevalence and tid data loaded.");
            await populateAssetCategories(); // Now categories should be available
            console.log("Asset categories populated.");
            showStep(0);

            // set dark mode
            const savedMode = await getObjectById("settings", "darkMode");
            if (savedMode) document.body.classList.toggle("dark", savedMode.value === "dark");

            // document.querySelectorAll(".next-step").forEach(btn => btn.addEventListener("click", () => showStep(1)));
            // document.querySelectorAll(".prev-step").forEach(btn => btn.addEventListener("click", () => showStep(0)));
        });
    
        // Preload Default Asset Categories (No Asset Types)
        async function preloadAssetCategories() {
            const db = await initIndexedDB();
            const transaction = db.transaction("assets", "readonly");
            const store = transaction.objectStore("assets");
            const countRequest = store.count();
    
            countRequest.onsuccess = async () => {
                if (countRequest.result === 0) {
                    console.log("Preloading asset categories...");
                    const defaultCategories = [
                        { id: "devices", name: "Devices" },
                        { id: "networks", name: "Networks" },
                        { id: "applications", name: "Applications & Workloads" },
                        { id: "data", name: "Data" },
                        { id: "identities", name: "Identities" }
                    ];
    
                    const writeTransaction = db.transaction("assets", "readwrite");
                    const writeStore = writeTransaction.objectStore("assets");
    
                    for (const category of defaultCategories) {
                        writeStore.put(category);
                    }
                }
            };
        }
    
        // Retrieve Asset Categories from IndexedDB
        async function populateAssetCategories() {
            const assetCategories = await getAllFromStore("assets");
            const container = document.getElementById("asset-category-container");
    
            if (assetCategories.length === 0) {
                container.innerHTML = `<p class="text-red-500">No asset categories found. Please refresh the page.</p>`;
                return;
            }
    
            container.innerHTML = assetCategories.map(asset => `
                <button class="asset-category" data-category="${asset.id}">${asset.name}</button>
            `).join("");
    
            document.querySelectorAll(".asset-category").forEach(btn => {
                btn.addEventListener("click", () => populateAssetTypes(btn.dataset.category));
            });
        }
    
        // Retrieve Asset Types from IndexedDB for Selected Category
        async function populateAssetTypes(categoryId) {
            const assetTypes = await getObjectsByIndex("assetTypes", "categoryId", categoryId);
            const dropdown = document.getElementById("asset-type-dropdown");
    
            if (assetTypes.length === 0) {
                dropdown.innerHTML = `<option value="">No asset types available</option>`;
                dropdown.disabled = true;
                return;
            }
    
            dropdown.innerHTML = assetTypes.map(type => `<option value="${type.name}">${type.name}</option>`).join("");
            dropdown.disabled = false;
        }
    
        // Retrieve and Store Monitoring Coverage Settings
        async function saveMonitoringCoverage(assetId, coverageData) {
            await storeObject("monitoringCoverage", { id: assetId, coverage: coverageData });
        }
    
        async function getMonitoringCoverage(assetId) {
            return await getObjectById("monitoringCoverage", assetId);
        }
    
        // Generate Radial Tree Visualization
        async function generateRadialTree() {
            const techniques = await getAllObjects("visualizationTree");
    
            const svg = d3.select("#radial-tree-container").append("svg")
                .attr("width", 800).attr("height", 600)
                .append("g").attr("transform", "translate(400,300)");
    
            const hierarchy = d3.hierarchy({ children: techniques });
            const treeLayout = d3.tree().size([360, 250]);
            treeLayout(hierarchy);
    
            svg.selectAll("line")
                .data(hierarchy.links())
                .enter()
                .append("line")
                .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y)
                .attr("stroke", "black");
        }

        // Function to Handle Navigation Between Steps
        let currentStep = 0;
        const steps = document.querySelectorAll(".form-step");
        const nextButton = document.getElementById("next-step");
        const prevButton = document.getElementById("prev-step");
        const progressItems = document.querySelectorAll(".progress-bar li");

        // Function to update steps
        function showStep(step) {
            // Hide all steps and remove active class
            steps.forEach((el, index) => {
                el.classList.toggle("active", index === step);
                el.style.display = index === step ? "block" : "none";
            });

            // Update progress bar
            progressItems.forEach((el, index) => {
                el.classList.toggle("active", index === step);
            });

            // Hide back button on first step
            prevButton.classList.toggle("hidden", step === 0);

            // Change "Next" button to "Finish" on the last step
            nextButton.innerText = step === steps.length - 1 ? "Finish" : "Next";
        }

        // Function to Hide the Techniques Table and JSON Output
        function hideDynamicElements() {
            document.getElementById("techniques-container").classList.add("hidden");
            document.getElementById("json-output").style.display = "none";
        }

        // Next Button Click Event
        nextButton.addEventListener("click", async () => {
            if (currentStep < steps.length - 1) {
                if (currentStep === 0) {
                    buildOrganizationAttributes();
                }
                if (currentStep === 1) {
                    // ✅ Only recalculate if scores do not exist
                    const scoresExist = modelDefinition.asset_types.some(asset => asset.attack_scores?.length > 0);
                    if (!scoresExist) {
                        await calculateAllTechniqueScores();
                    }
                    updateModelDisplay();
                    generateModelSummaryTable();
                }
                if (currentStep === 2) {
                    // ✅ Wait for JSON files to be fully loaded before updating model
                    if (!jsonCache.nistMapping || !jsonCache.enterpriseAttack) {
                        console.error("❌ Error: Required JSON files not loaded.");
                        showToast("Error: Required JSON files not loaded.", "error");
                        return;
                    }
                    await updateModelWithSecurityMappings();
                    generateRadialTree();
                }

                currentStep++;
                showStep(currentStep);
                hideDynamicElements();
            } else {
                alert("Form Submitted!"); // Replace this with actual form submission logic
            }
        });

        // Back Button Click Event
        prevButton.addEventListener("click", () => {
            if (currentStep > 0) {
                currentStep--;
                showStep(currentStep);
                hideDynamicElements();
                updateModelDisplay(); // ✅ Ensure JSON output is updated
            }
        });

        // ✅ Attach event for navigating to Step 4 directly from Step 3
        const goToVisualizationButton = document.getElementById("go-to-visualization");
        if (goToVisualizationButton) {
            goToVisualizationButton.addEventListener("click", async function () {
                await updateModelWithSecurityMappings(); // Add security mappings before visualization
                currentStep = 3; // Move to Step 4
                showStep(currentStep);
                generateRadialTree(); // Render the visualization
            });
        }

        // ✅ Handle radio button selection change
        document.querySelectorAll("input[name='visualization-type']").forEach((radio) => {
            radio.addEventListener("change", function () {
                selectedVisualizationType = this.value;
                generateRadialTree(); // Re-render the tree on selection change
            });
        });

        // Initialize the first step
        // showStep(currentStep);
   
        // Dark Mode Toggle
        async function toggleDarkMode() {
            const body = document.body;
            body.classList.toggle("dark");
            const mode = body.classList.contains("dark") ? "dark" : "light";
            await storeObject("settings", { key: "darkMode", value: mode });
        }
    
        // JSON Export & Download
        async function exportModelAsJSON() {
            const techniques = await getAllObjects("techniques");
            const blob = new Blob([JSON.stringify(techniques, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "model-data.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    
        document.getElementById("download-json").addEventListener("click", exportModelAsJSON);

        // Function to Build Organization Attributes from Checkboxes
        function buildOrganizationAttributes() {
            document.querySelectorAll("#organization-details input[type='checkbox']").forEach(input => {
                modelDefinition.organization_attributes[input.id] = input.checked;  // ✅ Ensure proper assignment
            });

            // console.log("Saved Organization Attributes:", modelDefinition.organization_attributes);
        }

        function generateModelSummaryTable() {
            const tableBody = document.getElementById("model-summary-body");
            tableBody.innerHTML = "";

            modelDefinition.asset_types.forEach(asset => {
                const techniques = asset.attack_scores || [];

                const avgScore = techniques.length
                    ? (techniques.reduce((sum, t) => sum + parseFloat(t.score), 0) / techniques.length).toFixed(4)
                    : "N/A";

                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${asset.environment}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_category}</td>
                    <td class="border border-gray-300 px-4 py-2">${asset.asset_type}</td>
                    <td class="border border-gray-300 px-4 py-2 text-blue-500 cursor-pointer">
                        ${techniques.length} techniques (Avg Score: ${avgScore})
                    </td>
                `;

                // ✅ Pass asset type name instead of JSON
                row.querySelector("td:last-child").addEventListener("click", () => {
                    displayTechniquesTable(asset.asset_type);
                });

                tableBody.appendChild(row);
            });
        }


        async function displayTechniquesTable(assetTypeName) {
            const tableBody = document.getElementById("techniques-body");
            tableBody.innerHTML = "";

            document.getElementById("selected-asset-type").textContent = assetTypeName;
            document.getElementById("techniques-container").classList.remove("hidden");

            // Find the asset type object
            const selectedAssetType = modelDefinition.asset_types.find(asset => asset.asset_type === assetTypeName);
            if (!selectedAssetType) {
                console.error(`Error: Asset type '${assetTypeName}' not found in model definition.`);
                return;
            }

            // Use precomputed attack scores
            const techniques = selectedAssetType.attack_scores || [];

            techniques.forEach(technique => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_id}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.attack_object_name}</td>
                    <td class="border border-gray-300 px-4 py-2">${technique.score}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        document.getElementById("submit-asset-type").addEventListener("click", async () => {
            const assetTypeName = document.getElementById("asset-type-dropdown").value;
            const environment   = document.getElementById("environment-dropdown").value;
            const selectedCategory = document.querySelector('input[name="asset-category"]:checked').value;
            // gather monitoring coverage inputs, e.g.:
            const coverage = {
                "network-monitoring": selectedNetworkCoverage,
                "process-monitoring": selectedProcessCoverage,
                "file-monitoring": selectedFileCoverage,
                "cloud-monitoring": selectedCloudCoverage,
                "hardware-monitoring": selectedHardwareCoverage
            };
            let recordCount;
            if (selectedCategory === "data") {
                recordCount = parseInt(document.getElementById("record-count-dropdown").value, 10);
            }

            await updateModelValuesForAssetType(assetTypeName, environment, coverage, recordCount);
            // Possibly show a success message or move to the next step.
        });

        //
        // ATT&CK Score Calculation Functions
        //
        /**
         * Returns the prevalence score for a given technique.
         * 
         * @param {string} techniqueId - The ATT&CK Technique ID (e.g., "T1003").
         * @returns {Promise<number>} - The numeric prevalence score, or 0 if not found.
         */
        async function calculatePrevalenceScore(techniqueId) {
            try {
                // 1. Attempt to read from in-memory data if loaded via getJSONData.
                const attackPrev = getJSONData("attackPrevTid");
                if (attackPrev && Array.isArray(attackPrev)) {
                const prevEntry = attackPrev.find(
                    entry => entry.attack_object_id === techniqueId
                );
                if (prevEntry && typeof prevEntry.calc_prev_score === "number") {
                    return prevEntry.calc_prev_score;
                } else if (prevEntry && typeof prevEntry.calc_prev_score === "string") {
                    return parseFloat(prevEntry.calc_prev_score) || 0;
                }
                }

                // 2. If not found in memory, check the IndexedDB "attackPrevTid" store.
                const db = await initIndexedDB();
                const tx = db.transaction("attackPrevTid", "readonly");
                const store = tx.objectStore("attackPrevTid");

                // Because the store’s primary key is "attack_object_id",
                // you can directly get by the techniqueId if it matches the key.
                const dbEntry = await new Promise((resolve, reject) => {
                const request = store.get(techniqueId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
                });

                if (dbEntry && dbEntry.calc_prev_score !== undefined) {
                return parseFloat(dbEntry.calc_prev_score) || 0;
                }

                // 3. Default to 0 if no matching entry is found.
                return 0;

            } catch (error) {
                console.error("Error in calculatePrevalenceScore for technique:", techniqueId, error);
                return 0;
            }
        }

        /**
         * Computes the chokepoint score given calc_tid_before and calc_tid_after values.
         * 
         * @param {number} tidBefore - parseFloat(calc_tid_before) or 0 if missing
         * @param {number} tidAfter  - parseFloat(calc_tid_after)  or 0 if missing
         * @returns {number}         - The computed chokepointScore
         */
        function computeChokepointFromValues(tidBefore, tidAfter) {
            try {
                // 1. Retrieve your staticVariables from memory (or however you normally do).
                const staticVariables = getJSONData("staticVariables") || {};

                // Provide short references to all the cutoffs and weights:
                const beforeLower = staticVariables.chokepoint_before_lower_cutoff || 0;
                const beforeUpper = staticVariables.chokepoint_before_upper_cutoff || 1;
                const afterLower  = staticVariables.chokepoint_after_lower_cutoff  || 0;
                const afterUpper  = staticVariables.chokepoint_after_upper_cutoff  || 1;
                const wBefore1    = staticVariables.chokepoint_w_before1           || 1;
                const ratio       = staticVariables.chokepoint_before_to_after_ratio || 1;

                // 2. Clamp function to ensure values stay within [0, 1]
                function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
                }

                // 3. Compute the clamped "utilities" for before/after
                //    Scale tidBefore and tidAfter based on lower/upper cutoffs and clamp
                const beforeClamped = clamp(
                (tidBefore - beforeLower) / (beforeUpper - beforeLower),
                0, 
                1
                );
                const afterClamped  = clamp(
                (tidAfter  - afterLower)  / (afterUpper  - afterLower),
                0, 
                1
                );

                // 4. Compute weights for the formula
                //    a) Weight portion for "after" (wAfter1)
                const wAfter1 = (wBefore1 / ratio) 
                                * (afterUpper - afterLower)
                                / (beforeUpper - beforeLower);

                //    b) WeightBefore & WeightAfter
                const weightBefore = wBefore1 / (wAfter1 + wBefore1);
                const weightAfter  = wAfter1 / (wAfter1 + wBefore1);

                // 5. Combine them for the final chokepointScore
                const chokepointScore = (weightBefore * beforeClamped) 
                                    + (weightAfter  * afterClamped);

                return chokepointScore;

            } catch (error) {
                console.error("Error in computeChokepointFromValues:", error);
                return 0; // Return 0 if something goes wrong
            }
        }

        /**
         * Computes the "actionabilityScore" for a given contextualized technique object.
         * 
         * Assumes the technique object already contains arrays for:
         *  - "nist-controls"       (array of NIST control objects)
         *  - "cis-safeguards"      (array of CIS safeguard objects)
         *  - "detections"          (array or some structure representing how many detections apply)
         * 
         * Also applies user-defined cutoffs and weighting factors from staticVariables:
         *   - actionability_mitigations_lower_cutoff
         *   - actionability_mitigations_upper_cutoff
         *   - actionability_detections_lower_cutoff
         *   - actionability_detections_upper_cutoff
         *   - actionability_w_miti1
         *   - actionability_mitigations_to_detections_ratio
         * 
         * @param {Object} techniqueObj - A contextualized technique object, e.g.:
         *   {
         *      "nist-controls": [...],
         *      "cis-safeguards": [...],
         *      "detections": [...], // optional
         *      ...
         *   }
         * @returns {number} - The computed actionability score (0..1, typically)
         */
        function computeActionablityScore(techniqueObj) {
            try {
                // 1. Extract the relevant counts from the technique object.
                //    If the arrays aren't present, default to an empty array.
                const nistCount = Array.isArray(techniqueObj["nist-controls"])
                ? techniqueObj["nist-controls"].length
                : 0;
                const cisCount = Array.isArray(techniqueObj["cis-safeguards"])
                ? techniqueObj["cis-safeguards"].length
                : 0;
                
                // If your contextual object includes a direct detection array or count:
                const detectionCount = Array.isArray(techniqueObj.detections)
                ? techniqueObj.detections.length
                : 0;

                // 2. Load actionability cutoffs and weighting factors from staticVariables
                const staticVariables = getJSONData("staticVariables") || {};

                const mitigationsLowerCutoff = staticVariables.actionability_mitigations_lower_cutoff || 0;
                const mitigationsUpperCutoff = staticVariables.actionability_mitigations_upper_cutoff || 1;
                const detectionsLowerCutoff  = staticVariables.actionability_detections_lower_cutoff  || 0;
                const detectionsUpperCutoff  = staticVariables.actionability_detections_upper_cutoff  || 1;

                // 3. Compute the "mitigationsUtility" (clamped between 0 and 1)
                const rawMiti = (nistCount + cisCount) - mitigationsLowerCutoff;
                const mitigationsUtility = Math.min(
                Math.max(rawMiti / (mitigationsUpperCutoff - mitigationsLowerCutoff), 0),
                1
                );

                // 4. Compute the "detectionsUtility" (clamped as well)
                const rawDetect = detectionCount - detectionsLowerCutoff;
                const detectionsUtility = Math.min(
                Math.max(rawDetect / (detectionsUpperCutoff - detectionsLowerCutoff), 0),
                1
                );

                // 5. Weigh them according to your actionability formula
                const wMiti1 = staticVariables.actionability_w_miti1 || 1;
                const ratio  = staticVariables.actionability_mitigations_to_detections_ratio || 1;

                // The partial weight for detections
                const actionabilityWeightDetect1 = (wMiti1 / ratio) *
                (detectionsUpperCutoff - detectionsLowerCutoff) /
                (mitigationsUpperCutoff - mitigationsLowerCutoff);

                // The relative weights for mitigations & detections
                const actionabilityWeightMiti   = wMiti1 / (actionabilityWeightDetect1 + wMiti1);
                const actionabilityWeightDetect = actionabilityWeightDetect1 / (actionabilityWeightDetect1 + wMiti1);

                // 6. Combine them for the final "actionabilityScore"
                const actionabilityScore =
                (actionabilityWeightMiti   * mitigationsUtility) +
                (actionabilityWeightDetect * detectionsUtility);

                return actionabilityScore;

            } catch (error) {
                console.error("Error in computeActionablityScore:", error);
                return 0; // fallback if something goes wrong
            }
        }


        /**
         * Build a dictionary of contextualized technique objects.
         * Each technique object has all required attributes EXCEPT "initial-score".
         * 
         * @returns {Promise<Object>} - Returns an object of shape:
         *   {
         *     "T1001": {
         *        name: "...",
         *        prevEntry: [calc_tid_before, calc_tid_after, calc_prev_score],
         *        "data-sources": [...],
         *        "nist-controls": [...],
         *        "cis-safeguards": [...],
         *        "aws-capabilities": [...],
         *        "gcp-capabilities": [...],
         *        "azure-capabilities": [...],
         *        "m365-capabilities": [...],
         *        "mitigations": [...],
         *        "monitoring-coverage-eval": {
         *           process: true/false,
         *           network: ...
         *           file: ...
         *           cloud: ...
         *           hardware: ...
         *        }
         *        // NO "initial-score" yet
         *     },
         *     "T1002": { ... },
         *     ...
         *   }
         */
        async function buildContextualTechniqueObjects() {
            // 1. Initialize or open IndexedDB
            const db = await initIndexedDB();

            // 2. Create or open the new store that will hold these contextual technique objects.
            //    If your schema is already set to create "contextualizedTechniques" (or similar),
            //    it should exist. Otherwise, you'll need an upgrade function.
            //    For brevity, assume it already exists:
            const tx = db.transaction(
                ["attackPrevTid", "attackPatterns", "nistMappings", "cisSafeguardMappings", 
                "awsMappings", "gcpMappings", "azureMappings", "m365Mappings", 
                "attackMitigationMappings", "weightKeywords", "contextualizedTechniques"],
                "readonly"
            );

            const attackPrevStore    = tx.objectStore("attackPrevTid");
            const attackPatternsStore= tx.objectStore("attackPatterns");
            const nistStore          = tx.objectStore("nistMappings");
            const cisStore           = tx.objectStore("cisSafeguardMappings");
            const awsStore           = tx.objectStore("awsMappings");
            const gcpStore           = tx.objectStore("gcpMappings");
            const azureStore         = tx.objectStore("azureMappings");
            const m365Store          = tx.objectStore("m365Mappings");
            const mitigationStore    = tx.objectStore("attackMitigationMappings");
            const weightKeywordStore = tx.objectStore("weightKeywords");
            // We'll write to "contextualizedTechniques" in a separate "readwrite" transaction below

            // 3. Fetch all relevant data into memory arrays for easier processing.
            //    (You can also do partial queries, but usually getAll is simpler if data isn't huge.)
            const [
                attackPrevAll,
                attackPatternsAll,
                nistAll,
                cisAll,
                awsAll,
                gcpAll,
                azureAll,
                m365All,
                mitigationAll,
                weightKeywordsAll
            ] = await Promise.all([
                getAllFromStore(attackPrevStore),
                getAllFromStore(attackPatternsStore),
                getAllFromStore(nistStore),
                getAllFromStore(cisStore),
                getAllFromStore(awsStore),
                getAllFromStore(gcpStore),
                getAllFromStore(azureStore),
                getAllFromStore(m365Store),
                getAllFromStore(mitigationStore),
                getAllFromStore(weightKeywordStore)
            ]);

            // 4. Convert these arrays into dictionaries or indexes for quick lookups.
            //    For instance, attackPatternsAll might be an array of objects with:
            //    { technique_id: "T1001", data_sources: [...], ... }
            //    So let's build a map from technique_id => object
            const attackPatternsMap = new Map(
                attackPatternsAll.map(obj => [obj.technique_id, obj])
            );

            // Similarly, build maps for prevalence data: attack_object_id => object
            const attackPrevMap = new Map(
                attackPrevAll.map(obj => [obj.attack_object_id, obj])
            );

            // NIST, CIS, cloud capabilities typically have "attack_object_id" or "technique_id".
            // We'll group them by technique for easy retrieval.
            const nistMap = buildGroupedMap(nistAll, "attack_object_id");      // technique => [control entries]
            const cisMap  = buildCisSafeguardMap(cisAll);                      // technique => [safeguard entries]
            const awsMap  = buildGroupedMap(awsAll, "attack_object_id");       // technique => [AWS capability entries]
            const gcpMap  = buildGroupedMap(gcpAll, "attack_object_id");
            const azureMap= buildGroupedMap(azureAll, "attack_object_id");
            const m365Map = buildGroupedMap(m365All, "attack_object_id");

            // Mitigation map
            const mitigationGroupedMap = buildGroupedMap(mitigationAll, "technique_id");

            // Weight keywords is typically an array of:
            //   { keywords: "process creation, exec", category: "process" } etc.
            // We'll store them in an array or map as needed.
            const weightKeywordsArray = weightKeywordsAll; // or convert to map if desired

            // 5. Figure out the complete set of technique IDs to process.
            //    We can gather them from attackPatternsMap keys or from the union of all maps.
            const allTechniqueIds = new Set([
                ...attackPatternsMap.keys(),
                ...attackPrevMap.keys(),
                ...nistMap.keys(),
                ...cisMap.keys(),
                ...awsMap.keys(),
                ...gcpMap.keys(),
                ...azureMap.keys(),
                ...m365Map.keys(),
                ...mitigationGroupedMap.keys()
            ]);

            // 6. For each technique ID, build the contextual object (without "initial-score").
            const techniqueObjects = {};
            
            for (const techniqueId of allTechniqueIds) {
                const obj = {};

                // a) name
                const patternObj = attackPatternsMap.get(techniqueId);
                obj.name = patternObj ? patternObj.technique_name : techniqueId;

                // b) prevEntry => [calc_tid_before, calc_tid_after, calc_prev_score]
                const prev = attackPrevMap.get(techniqueId);
                obj.prevEntry = prev
                ? [prev.calc_tid_before, prev.calc_tid_after, prev.calc_prev_score]
                : [0, 0, 0];

                // c) data-sources => from patternObj.x_mitre_data_sources (or data_sources)
                obj["data-sources"] = patternObj && Array.isArray(patternObj.data_sources)
                ? patternObj.data_sources
                : [];

                // d) nist-controls => from nistMap
                obj["nist-controls"] = nistMap.get(techniqueId) || [];

                // e) cis-safeguards => from cisMap
                obj["cis-safeguards"] = cisMap.get(techniqueId) || [];

                // f) Cloud capabilities: AWS, GCP, Azure, M365
                obj["aws-capabilities"]   = awsMap.get(techniqueId)   || [];
                obj["gcp-capabilities"]   = gcpMap.get(techniqueId)   || [];
                obj["azure-capabilities"] = azureMap.get(techniqueId) || [];
                obj["m365-capabilities"]  = m365Map.get(techniqueId)  || [];

                // g) mitigations => from mitigationGroupedMap
                //    The stored objects might have "mitigation_id", "mitigation_name", etc.
                //    We store them as an array or object as you see fit.
                obj["mitigations"] = mitigationGroupedMap.get(techniqueId) || [];

                // h) monitoring-coverage-eval => boolean fields for process, network, file, cloud, hardware
                //    We'll set them based on whether data-sources includes any substring
                //    that matches a keyword whose category is "process", "network", etc.
                obj["monitoring-coverage-eval"] = evaluateMonitoringCoverage(
                obj["data-sources"],
                weightKeywordsArray
                );

                techniqueObjects[techniqueId] = obj;
            }

            // 7. Optionally store them in a separate IDB store "contextualizedTechniques"
            //    If you want to store them permanently, do so in a readwrite transaction.
            const txWrite = db.transaction("contextualizedTechniques", "readwrite");
            const storeWrite = txWrite.objectStore("contextualizedTechniques");

            for (const [techId, techniqueData] of Object.entries(techniqueObjects)) {
                // We can store them as: { id: "T1001", data: { ... } }
                // or simply store them keyed by "techniqueId".
                storeWrite.put({ techniqueId: techId, ...techniqueData });
            }

            await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
            });

            // 8. Return the newly built dictionary so you can also use it in memory
            return techniqueObjects;
            }

            /**
             * Helper function to retrieve all objects from an objectStore as an array.
             */
            function getAllFromStore(store) {
            return new Promise((resolve, reject) => {
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror   = () => reject(req.error);
            });
        }

        /**
         * Helper to group an array of store objects by a "keyField".
         *   e.g. buildGroupedMap([{attack_object_id:'T1001', ...}, {...}], 'attack_object_id')
         * 
         * Returns a Map { techniqueId => [ all matching objects ] }
         */
        function buildGroupedMap(array, keyField) {
            const map = new Map();
            array.forEach(item => {
                const techId = item[keyField];
                if (!techId) return; // skip if no key
                if (!map.has(techId)) {
                map.set(techId, []);
                }
                map.get(techId).push(item);
            });
            return map;
            }

            /**
             * Example of building a technique => [CIS entries[]] map from cisSafeguardMappings,
             * which might store records like: { cis_safeguard: 'CIS-3.14', technique_id: 'T1001', ... }
             */
            function buildCisSafeguardMap(array) {
            const map = new Map();
            array.forEach(item => {
                const techniqueId = item.technique_id;
                if (!map.has(techniqueId)) {
                map.set(techniqueId, []);
                }
                map.get(techniqueId).push(item);
            });
            return map;
        }

        /**
         * Evaluate the presence of process/network/file/etc for data-sources based on weight-keywords.
         * 
         * dataSources - e.g. ["Process command-line parameters", "File creation", ...]
         * weightKeywordsArray - e.g. [ { keywords: "process,exec", category: "process" }, ... ]
         * 
         * Returns an object:
         *  {
         *     process:  true/false,
         *     network:  true/false,
         *     file:     ...,
         *     cloud:    ...,
         *     hardware: ...
         *  }
         */
        function evaluateMonitoringCoverage(dataSources, weightKeywordsArray) {
            const coverage = {
                process: false,
                network: false,
                file: false,
                cloud: false,
                hardware: false
            };

            // Convert data sources to lowercase for substring matching
            const lowerSources = dataSources.map(s => s.toLowerCase());

            // For each weight-keywords entry, see if any data-source includes any of the keywords
            // If so, set coverage[category] = true
            weightKeywordsArray.forEach(item => {
                // item might look like: {keywords: "process creation, exec, etc", category: "process"}
                if (!item.keywords || !item.category) return;

                // split the keywords on commas if needed
                const keywordsList = item.keywords.split(",").map(kw => kw.trim().toLowerCase());

                // check if any data source includes a keyword
                const matched = lowerSources.some(ds => 
                keywordsList.some(kw => ds.includes(kw))
                );

                if (matched && coverage.hasOwnProperty(item.category)) {
                coverage[item.category] = true;
                }
            });

            return coverage;
        }

        /**
         * Calculates and sets the "initial-score" for a single technique object,
         * using the existing partial data inside it.
         * 
         * initialScore = prevalenceScore + chokepointScore + actionabilityScore
         * 
         * @param {Object} techniqueObj - The contextualized technique object, e.g.:
         *    {
         *      name: "Data Obfuscation",
         *      prevEntry: [tidBefore, tidAfter, prevScore],
         *      "data-sources": [...],
         *      ...
         *      "monitoring-coverage-eval": { process: true, ... }
         *    }
         * @returns {number} - The numeric initial-score
         */
        function computeTechniqueInitialScore(techniqueObj) {
            // 1. Extract the relevant fields
            const [calc_tid_before, calc_tid_after, calc_prev_score] = techniqueObj.prevEntry || [0, 0, 0];

            // Prevalence is typically calc_prev_score
            // If you have a separate function, e.g., calculatePrevalenceScore, you can call it instead.
            const prevalenceScore = parseFloat(calc_prev_score) || 0;

            // Chokepoint might rely on tidBefore / tidAfter. 
            // If you have a separate function, e.g. calculateChokepointScore, you can call it:
            //   const chokepointScore = await calculateChokepointScore(techniqueId);
            // But if you're just doing it inline here:
            const chokepointScore = computeChokepointFromValues(
                parseFloat(calc_tid_before) || 0,
                parseFloat(calc_tid_after)  || 0
            );

            // Actionability might require counting NIST, CIS, Detections, etc.
            // If you have a function like calculateActionabilityScore(techniqueId),
            // you need the technique ID. But here, you can also do it from the arrays:
            const actionabilityScore = computeActionablityScore(techniqueObj);

            // 2. Summation
            const initialScore = prevalenceScore + chokepointScore + actionabilityScore;

            // 3. Return
            return initialScore;
        }

        async function generateTechniquesAndScores() {
            const techniqueDictionary = await buildContextualTechniqueObjects();

            for (const techniqueId in techniqueDictionary) {
                const techObj = techniqueDictionary[techniqueId];
                // Now that "techObj" has prevEntry, data-sources, etc., we can compute initial-score
                const initScore = computeTechniqueInitialScore(techObj);
                techObj["initial-score"] = initScore;
            }

            // If you want to save the updated "initial-score" back to IndexedDB,
            // do so in a readwrite transaction to "contextualizedTechniques" store.
            const db = await initIndexedDB();
            const txWrite = db.transaction("contextualizedTechniques", "readwrite");
            const store = txWrite.objectStore("contextualizedTechniques");
            
            for (const techniqueId in techniqueDictionary) {
                store.put({
                techniqueId,
                ...techniqueDictionary[techniqueId] // includes "initial-score" now
                });
            }

            await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
            });

            console.log("All contextual technique objects updated with initial-score and stored.");
        }  
        

        //
        // Contextual Asset Type Construction
        //
        /**
         * Builds a contextual asset-type object for each unique assetType found in your
         * MAPEX “assetTypeMappings” (devicesMappings, networksMappings, etc.) and enriches
         * them with the relevant technique data (prevEntry, data-sources, etc.).
         * 
         * Finally, writes them to the "contextualizedAssetTypes" store in IndexedDB,
         * keyed by a field "assetTypeId" (e.g. "Linux Server OS").
         */
        async function buildContextualAssetTypes() {
            try {
                const db = await initIndexedDB();

                // 1. Gather all assetTypeMappings from your MAPEX store(s).
                //    For example, if you've stored them in "devicesMappings", "networksMappings", etc.,
                //    you can fetch them all or you can unify them into a single store. 
                //    Here is a conceptual example of retrieving them:
                const storeNames = [
                "devicesMappings",
                "networksMappings",
                "applicationsMappings",
                "dataMappings",
                "identitiesMappings"
                ];

                // We'll gather them into a single array in memory
                let allAssetMappings = [];
                for (const storeName of storeNames) {
                // If these object stores exist, fetch everything
                if (db.objectStoreNames.contains(storeName)) {
                    const storeData = await getAllFromStore(db, storeName);
                    allAssetMappings = allAssetMappings.concat(storeData);
                }
                }

                // 2. Group assetTypeMappings by capability_id (e.g. "Linux Server OS").
                //    We'll create a dictionary: { "Linux Server OS": [ {capability_id..., attack_object_id..., ...}, ... ] }
                const groupedByAssetType = {};
                for (const entry of allAssetMappings) {
                const assetTypeName = entry.capability_id;    // e.g. "Linux Server OS"
                const assetCategory = entry.capability_group; // e.g. "devices"

                if (!groupedByAssetType[assetTypeName]) {
                    groupedByAssetType[assetTypeName] = {
                    assetCategory,
                    entries: [] // all technique mappings referencing this asset type
                    };
                }
                groupedByAssetType[assetTypeName].entries.push(entry);
                }

                // 3. For each unique asset type, build the final object shape:
                //    {
                //       assetTypeId: "Linux Server OS",
                //       "asset-category": "devices",
                //       "asset-type": "Linux Server OS",
                //       "model-values": {},  // We'll populate in Step 2 (Add Asset Type) 
                //       "techniques": { "T1001": {...}, "T1002": {...} }
                //    }
                const contextualAssetTypes = {};

                for (const [assetTypeName, info] of Object.entries(groupedByAssetType)) {
                const assetCategory = info.assetCategory;
                // Build the skeleton object
                const assetTypeObj = {
                    assetTypeId: assetTypeName,  // our unique keyPath
                    "asset-category": assetCategory,
                    "asset-type": assetTypeName,
                    "model-values": {}, 
                    "techniques": {}
                };

                // For each technique mapping referencing this asset type
                for (const mapping of info.entries) {
                    const techniqueId   = mapping.attack_object_id;   // e.g. "T1001"
                    const techniqueName = mapping.attack_object_name; // e.g. "Data Obfuscation"

                    // Build the partial technique object
                    // We'll call a helper "buildContextualTechniqueObject(techniqueId, techniqueName)" 
                    // that merges in STIX data (data-sources, mitigations, prevEntry, etc.).
                    // Or you can do it inline. For clarity, let's just call a helper:
                    const techniqueObj = await buildContextualTechniqueObject(techniqueId, techniqueName);

                    // Add it to the assetTypeObj
                    assetTypeObj.techniques[techniqueId] = techniqueObj;
                }

                contextualAssetTypes[assetTypeName] = assetTypeObj;
                }

                // 4. Write these new objects to the "contextualizedAssetTypes" store in a single transaction
                const txWrite = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = txWrite.objectStore("contextualizedAssetTypes");

                for (const [assetTypeName, assetTypeObj] of Object.entries(contextualAssetTypes)) {
                store.put(assetTypeObj);
                }

                await new Promise((resolve, reject) => {
                txWrite.oncomplete = () => resolve();
                txWrite.onerror = () => reject(txWrite.error);
                });

                console.log("✅ Built contextual asset types and stored in 'contextualizedAssetTypes'.");
                return contextualAssetTypes;

            } catch (error) {
                console.error("Error in buildContextualAssetTypes:", error);
                return {};
            }
        }

        /**
         * Build a single technique object with all fields except "initial-score".
         * 
         * @param {string} techniqueId   e.g. "T1001"
         * @param {string} techniqueName e.g. "Data Obfuscation"
         * @returns {Promise<Object>} e.g. {
         *   name: "Data Obfuscation",
         *   prevEntry: [tidBefore, tidAfter, prevScore],
         *   "data-sources": [...],
         *   "nist-controls": [...],
         *   "cis-safeguards": [...],
         *   ...
         *   "monitoring-coverage-eval": {...}
         * }
         */
        async function buildContextualTechniqueObject(techniqueId, techniqueName) {
            // 1. Fetch from IDB anything you need: "attackPrevTid", "attackPatterns", "nistMappings", etc.
            const db = await initIndexedDB();
            const tx = db.transaction([
                "attackPrevTid",
                "attackPatterns",
                "nistMappings",
                "cisSafeguardMappings",
                "awsMappings",
                "gcpMappings",
                "azureMappings",
                "m365Mappings",
                "attackMitigationMappings",
                "weightKeywords"
            ], "readonly");

            // Just for convenience
            const attackPrevStore = tx.objectStore("attackPrevTid");
            const patternsStore    = tx.objectStore("attackPatterns");
            const nistStore        = tx.objectStore("nistMappings");
            const cisStore         = tx.objectStore("cisSafeguardMappings");
            const awsStore         = tx.objectStore("awsMappings");
            const gcpStore         = tx.objectStore("gcpMappings");
            const azureStore       = tx.objectStore("azureMappings");
            const m365Store        = tx.objectStore("m365Mappings");
            const mitigationStore  = tx.objectStore("attackMitigationMappings");
            const weightKwStore    = tx.objectStore("weightKeywords");

            // 2. Retrieve the necessary data from each store 
            // (You can read everything or do partial queries. For brevity, let's do partial .getAll() and filter in memory.)
            const [
                attackPrevAll, 
                attackPatternsAll, 
                nistAll,
                cisAll,
                awsAll,
                gcpAll,
                azureAll,
                m365All,
                mitigationAll,
                weightKwAll
            ] = await Promise.all([
                getAllFromStoreIDB(attackPrevStore),
                getAllFromStoreIDB(patternsStore),
                getAllFromStoreIDB(nistStore),
                getAllFromStoreIDB(cisStore),
                getAllFromStoreIDB(awsStore),
                getAllFromStoreIDB(gcpStore),
                getAllFromStoreIDB(azureStore),
                getAllFromStoreIDB(m365Store),
                getAllFromStoreIDB(mitigationStore),
                getAllFromStoreIDB(weightKwStore)
            ]);

            // 3. Find the relevant records for techniqueId
            //    a) attackPrevTid => tidBefore, tidAfter, prevScore
            let tidBefore = 0, tidAfter = 0, prevScore = 0;
            const foundPrev = attackPrevAll.find(item => item.attack_object_id === techniqueId);
            if (foundPrev) {
                tidBefore = parseFloat(foundPrev.calc_tid_before) || 0;
                tidAfter  = parseFloat(foundPrev.calc_tid_after)  || 0;
                prevScore = parseFloat(foundPrev.calc_prev_score) || 0;
            }

            //    b) data-sources from "attackPatterns"
            let dataSources = [];
            const foundPattern = attackPatternsAll.find(p => p.technique_id === techniqueId);
            if (foundPattern && Array.isArray(foundPattern.data_sources)) {
                dataSources = foundPattern.data_sources;
            }

            //    c) nist-controls from nistAll, where item.attack_object_id === techniqueId
            const nistControls = nistAll.filter(item => item.attack_object_id === techniqueId);

            //    d) cis-safeguards
            const cisSafeguards = cisAll.filter(item => item.technique_id === techniqueId);

            //    e) AWS, GCP, Azure, M365 capabilities
            const awsCaps   = awsAll.filter(item => item.attack_object_id === techniqueId);
            const gcpCaps   = gcpAll.filter(item => item.attack_object_id === techniqueId);
            const azureCaps = azureAll.filter(item => item.attack_object_id === techniqueId);
            const m365Caps  = m365All.filter(item => item.attack_object_id === techniqueId);

            //    f) mitigations from "attackMitigationMappings"
            const techniqueMitigations = mitigationAll.filter(m => m.technique_id === techniqueId);

            // 4. Evaluate monitoring coverage
            const coverageEval = evaluateMonitoringCoverage(dataSources, weightKwAll);

            // 5. Build and return final technique object
            return {
                name: techniqueName || techniqueId,
                prevEntry: [ tidBefore, tidAfter, prevScore ],
                "data-sources": dataSources,
                "nist-controls": nistControls,
                "cis-safeguards": cisSafeguards,
                "aws-capabilities": awsCaps,
                "gcp-capabilities": gcpCaps,
                "azure-capabilities": azureCaps,
                "m365-capabilities": m365Caps,
                "mitigations": techniqueMitigations,
                "monitoring-coverage-eval": coverageEval
                // "initial-score" is computed later
            };
            }

            /**
             * Helper to read all data from an object store in a given transaction.
             */
            function getAllFromStoreIDB(store) {
            return new Promise((resolve, reject) => {
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror   = () => reject(req.error);
            });
        }

        /**
         * Called when the user clicks "Add Asset Type" in Step 2,
         * after selecting environment, coverage, record count, etc.
         * This attaches "model-values" to the relevant record in "contextualizedAssetTypes".
         * 
         * @param {string} assetTypeName  e.g. "Linux Server OS"
         * @param {string} environment    e.g. "AWS"
         * @param {Object} coverageObj    e.g. { "network-monitoring": "High", ...}
         * @param {number} [recordCount]  e.g. 1000 (if user selected it, and assetCategory === "data")
         */
        async function updateModelValuesForAssetType(assetTypeName, environment, coverageObj, recordCount) {
            try {
                const db = await initIndexedDB();
                const tx = db.transaction("contextualizedAssetTypes", "readwrite");
                const store = tx.objectStore("contextualizedAssetTypes");

                // 1. Retrieve the existing assetType record by key. The keyPath is "assetTypeId" (the name).
                const existingRecord = await new Promise((resolve, reject) => {
                const req = store.get(assetTypeName);
                req.onsuccess = () => resolve(req.result);
                req.onerror   = () => reject(req.error);
                });

                if (!existingRecord) {
                console.warn(`No record found for assetTypeId: ${assetTypeName}`);
                return;
                }

                // 2. Attach/update the "model-values"
                existingRecord["model-values"] = {
                environment,
                "monitoring-coverage": coverageObj || {}
                };
                if (recordCount != null) {
                existingRecord["model-values"]["record-count"] = recordCount;
                }

                // 3. Write it back to the store
                store.put(existingRecord);

                await new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror    = () => reject(tx.error);
                });

                console.log(`✅ Updated model-values for assetTypeId: ${assetTypeName}`);
            } catch (error) {
                console.error("Error in updateModelValuesForAssetType:", error);
            }
        }



    </script>
         
  
</body>

</html>
